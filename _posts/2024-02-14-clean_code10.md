---
title: "[파이썬] 파이썬다운 함수를 만들어보자!"

categories:
    - Python
tags:
    - Python
    - Coding
    - Review
last_modified_at: 2024-02-13T21:00:00

toc: true
toc_sticky: true
toc_label: "On This Page"
---

> 함수(function)는 파이썬 프로그래밍에 있어서 필수적인 기능입니다. 그렇다면 대충 정의한 함수 말고 파이썬다운 함수는 무엇일까요? 이번 장에서는 파이썬다운 함수에 대해서 정리하고자 합니다.<br>

> 이 포스트의 내용은 저자 Al Sweigart의 "클린 코드, 이제는 파이썬이다" 10장 내용임을 사전에 미리 밝힙니다!

&#160; 함수(function)는 주로 반복 작성되는 코드 중복을 해소하기 위해 많이 쓰이는 방법입니다. 코드 중복으로 인한 버그를 방지하고 코드 유지보수에 편의성을 증대시키기 위함입니다. 하지만 함수를 작성하기 위해서는 많은 요소를 고려하여 결정이 필요합니다. 

# 1. 함수명
&#160; 일반적으로 함수는 특정 동작을 수행하도록 정의되기 때문에 함수 이름에 동사가 많이 들어가는 편입니다. 저도 동사를 활용하여 함수명을 짓곤 합니다. 그리고 초보자 분들이 많이 하는 실수가 바로 함수명을 약어나 너무 짧은 언어로 축약시키는 것입니다. 매번 긴 함수명을 타이핑 하는 것이 귀찮아서거나 약어를 많이 사용해 축약하는 것이 더 멋있다고 생각해서일 수 있습니다. 하지만 함수명을 지나치게 축약하는 것은 좋은 방법이 아닙니다. **길고 설명적인 이름**을 사용하는 것이 좋습니다. 추가로 파이썬의 내장 함수 또는 모듈 이름은 절대 사용하면 안됩니다.

# 2. 함수 크기의 트레이드오프!?
&#160; 함수는 짧은게 좋을까요 긴게 좋을까요? 저는 그냥 필요한 만큼 작성해서 사용합니다만, 꽤 논쟁(?)적인 주제라고 합니다. 두 방식 모두 장, 단점이 있다고 합니다. 
> **짧은 코드 장점**
> - 함수 코드를 이해하기 쉽다.
> - 필요한 파라미터가 적다.
> - 부수 효과를 일으킬 가능성이 적다.
> - 테스트와 디버그가 쉽다.
> - 예외가 더 적게 발생한다.

> **짧은 코드 단점**
> - 필요한 함수 개수가 증가한다.
> - 함수가 많아지므로 프로그래밍이 더 복잡해진다.
> - 함수가 많아지므로 모든 함수에 대해 정확한 네이밍이 어렵다.
> - 작성할 문서가 많아진다.
> - 함수 간의 관계가 복잡해진다. 

&#160; 위와 같이 함수 크기에는 트레이드오프가 존재합니다. 책에서는 다음 예제를 보이며 설명합니다.
```python
# long version
def getPlayerMove(towers):
    """플레이어에게 이동 명령을 요청한다. (fromTower, toTower)를 반환한다."""
    
    while True:  # 플레이어가 유효한 이동 명령을 입력할 때까지 계속 요청한다.
        print('탑의 "시작"과 "끝"의 글자 또는 QUIT를 입력하십시오.')
        print("(예: 탑 A에서 탑 B로 원판을 이동하려면 AB를 입력합니다.)")
        print()
        response = input("> ").upper().strip()

        if response == "QUIT":
            print("즐겁게 퍼즐을 풀어주셔서 감사합니다.")
            sys.exit()
        
        # 사용자가 유효한 탑 문자를 입력했는지 확인한다.
        if response not in ("AB", "AC", "BA", "BC", "CA", "CB"):
            print("AB, AC, BA, BC, CA, CB 중 하나를 입력하십시오.")
            continue  # 플레이어에게 이동 명령을 다시 요청한다.
        
        # 더 설명적인 변수 이름을 사용한다.
        fromTower, toTower = response[0], response[1]

        if len(towers[fromTower]) == 0:
            # from 탑은 비어 있을 수 없다.
            print("원판이 없는 탑을 선택했습니다.")
            continue  # 플레이어에게 이동 명령을 다시 요청한다.
        elif len(tower[toTower]) == 0:
            # 어떤 원판이라도 빈 to 탑으로 이동이 가능하다.
            return fromTower, toTower
        elif towers[toTower][-1] < tower[fromTower][-1]:
            print("더 작은 원판에 더 큰 원판을 올릴 수 없습니다.")
            continue  # 플레이어에게 이동 명령을 다시 요청한다.
        else:  # 유효한 움직임이므로 선택된 탑을 반환한다.
            return fromTower, toTower
# ===================================================================
# short & many version
def getPlayerMove(towers):
    """플레이어에게 이동 명령을 요청한다. (fromTower, toTower)를 반환한다."""
    
    while True:  # 플레이어가 유효한 이동 명령을 입력할 때까지 계속 요청한다.
        reponse = askForPlayerMove()
        terminateIfResponseIsQuit(response)
        if not isValidtowerLetters(response):
            continue # 플레이어에게 이동 명령을 다시 요청한다.
        
        # 더 설명적인 변수 이름을 사용한다.
        fromTower, toTower = response[0], response[1]

        if towerWithNoDisksSelected(towers, fromTower):
            continue # 플레이어에게 이동 명령을 다시 요청한다.
        elif len(tower[toTower]) == 0:
            # 어떤 원판이라도 빈 to 탑으로 이동이 가능하다.
            return fromTower, toTower
        elif largerDiskIsOnSmallerDisk(towers, fromTower, toTower):
            continue  # 플레이어에게 이동 명령을 다시 요청한다.
        else:  # 유효한 움직임이므로 선택된 탑을 반환한다.
            return fromTower, toTower

def askForPlayerMove():
    """플러이어에게 질문 내용을 출력하고, 선택한 타워를 반환한다."""
    print('탑의 "시작"과 "끝"의 글자 또는 QUIT를 입력하십시오.')
    print("(예: 탑 A에서 탑 B로 원판을 이동하려면 AB를 입력합니다.)")
    print()
    return input("> ").upper().strip()

def terminateIfResponseIsQuit(response):
    """응답이 'QUI'인 경우 프로그램을 종료한다."""
    if response == "QUIT":
            print("즐겁게 퍼즐을 풀어주셔서 감사합니다.")
            sys.exit()

def isValidTowerLetters(towerLetters):
    """'towerLetters'가 유효하면 True를 반환한다."""
    if response not in ("AB", "AC", "BA", "BC", "CA", "CB"):
        print("AB, AC, BA, BC, CA, CB 중 하나를 입력하십시오.")
        return False
    return True

def towerWithNoDisksSelected(towers, selectedTower):
    """'selectedTower'에 원판이 없으면 True를 반환한다."""
    if len(towers[fromTower]) == 0:
        # from 탑은 비어 있을 수 없다.
        print("원판이 없는 탑을 선택했습니다.")
        return True
    return False

def largerDiskIsOnSmallerDisk(towers, fromTower, toTower):
    """더 큰 원판이 더 작은 원판으로 이동할 경우 True를 반환한다."""
    if towers[toTower][-1] < tower[fromTower][-1]:
        print("더 작은 원판에 더 큰 원판을 올릴 수 없습니다.")
        return True
    return False
```

&#160; 위 파이썬 스크립트에는 long & short 버전의 함수가 작성되어 있습니다. 저자가 short 버전을 극단적으로 작성한 것 같지만 여러분들이 보기에 어떠신가요? 무엇이 더 읽고 이해하기 편하신가요? long 버전은 총 34행이며, short 버전은 총 56행입니다. short 버전에 개별 함수들은 이해하기 편하지만 전체적인 프로그램의 흐름을 따라가기에는 더 복잡하게 느껴집니다. 또한 매번 새로운 네이밍과 독스트링을 활용한 추가 정보를 생성해야 합니다. 위 예시는 **무조건 짧은 함수가 이상적이지 않다**라는 것을 보여줍니다. 매번 일률적으로 적용되는 이상적인 크기는 없을 것입니다. 그 보다는 상황에 맞게 적절한 사이즈를 잘 선택하는 것이 최선이라고 생각합니다. 

# 3. 함수 파라미터와 인수
&#160; 너무 많은 파라미터는 이상적이지는 좋지 않습니다. 0 ~ 3개 정도의 파라미터를 사용하는 규칙을 정해놓는 것이 좋습니다. 
1. **기본 인수**<br>
&#160; 기본 인수를 사용하면 함수 파라미터의 복잡도를 감소시킬 수 있습니다. 기본 인수(default argument)는 함수를 호출할 때, 인수를 따로 입력하지 않아도 기본으로 사용되는 값을 의미합니다. 
2. *와 **를 사용해 함수에 인수 전달하기<Br>
&#160; 

# 9. 마치며...
&#160; 파이썬을 활용하다보면 정말 생산적이고 훌룡한 언어임에는 틀림이 없다 생각합니다. 그러다보면 파이썬도 버그가 있을까? 특이한 점이 있을까? 의심하기 쉽지 않지만, 역시 파이썬도 인간이 개발한 언어이고 허점은 분명히 존재할 수 있습니다. 그렇기에 이런 사소한 부분도 숙지하고 있다면 혹시나 발생할 수 있는 에러에 대해 미리 대응할 수 있고 프로그래머로서 실력을 증가시킬 수 있을 것입니다!