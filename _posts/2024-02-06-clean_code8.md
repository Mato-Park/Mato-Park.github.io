---
title: "[파이썬] 빠지기 쉬운 함정들. 이것만은 피하자!"

categories:
    - Python
tags:
    - Python
    - Coding
    - Review
last_modified_at: 2024-02-06T21:55:00

toc: true
toc_sticky: true
toc_label: "On This Page"
---

> 이번 포스트는 파이썬을 사용하면서 빠지기 쉬운 함정들을 알아보고 어떻게 하면 이 함정들을 피할 수 있는지 정리해봤습니다. <br>

> 이 포스트의 내용은 저자 Al Sweigart의 "클린 코드, 이제는 파이썬이다" 8장 내용임을 사전에 미리 밝힙니다!

&#160; 파이썬은 제가 가장 많이 사용하는 데이터 분석 도구 중 하나입니다. 사용하다 보면 종종 알 수 없는 warnings가 발생하곤 했지만 잘 모르기에 넘어가곤 했습니다. 아무래도 파이썬의 모든 작동원리를 알지 못하기 때문입니다. 이 책을 읽으면서 그동안 발생했던 warnings의 의미, 모르고 지나쳤던 것들을 알 수 있었기에 정리해보고자 합니다!

# 1. 루프문 진행 중에는 리스트에 아이템을 추가/삭제하지 말자
&#160; 리스트를 반복하는 루프문 내에서 리스트에 아이템을 추가/삭제하는 경우에는 버그가 발생할 수 있습니다. 책에 실린 예제와 함께 보겠습니다. <br>
```python
clothes = ['pants', 'red sock']
for clothing in clothes:  # 리스트 반복
    if 'sock' in clothing:  # 'sock' 문자열 찾기
        clothes.append(clothing)  # 일치하는 clothing 리스트에 추가
        print('Added a sock:', clothing)
```

실제로 위 코드를 파이썬에서 실행하게되면 프로그램이 무한정 돌게 됩니다. 왜 그렇게 되는 걸까? 루프문이 처음 동작할 때는 clothing이 pants이므로 리스트에 추가되지 않고 리스트에 다음 아이템으로 넘어가게 됩니다. 두 번째 반복할 때, 리스트에 red sock이 추가되고 clothes 리스트는 ['pants', 'red sock', 'red sock']으로 새 아이템이 추가됩니다. 하지만 for 문이 시작할 때 리스트에는 2개의 아이템이 있어서 for 반복문이 2번만 수행될 것 같지만 리스트에 새로운 아이템이 추가되면서 for 반복문은 다음 아이템에 대해 수행되게 됩니다. 이런식으로 리스트에 아이템이 무한하게 추가되고 for 반복문 또한 무한으로 돌게되는 것입니다. <br>

&#160; 그렇다면 어떻게 하면 될까? 다음과 같이 코드를 수정하게 되면 더 이상 위와 같은 에러는 발생하지 않게 됩니다.
```python
clothes = ['skirt', 'red sock', 'blue sock']
newClothes = []
for clothing in clothes:
    if 'sock' in clothing:
        newClothes.append(clothing)  # clothes 리스트가 아닌 newClothes 리스트에 아이템을 추가
clothes.append(newClothes)  # newClothes에 있는 아이템들을 기존 clothes리스트에 추가하기
```

&#160; 조금 번거롭긴 하지만 새로운 리스트 객체를 생성한 다음 아이템을 추가해줍니다. 그 다음 기존 리스트에 생성된 리스트에 아이템을 추가해주면 원하는 결과를 얻을 수 있게 됩니다.
<br>
&#160; 또한 앞서 말한 것처럼 리스트를 반복할 떄 아이템을 삭제하는 것도 지양해야합니다. 역시 예를 보고 설명하겠습니다.

```python
animals = ['dog', 'dog', 'cat', 'lion', 'dog']
for i, animal in enumerate(animals):
    if animal != 'dog':  # dog가 아닌 동물들을 리스트에서 제거
        del animals[i]
```
&#160; animals의 최종 결과물을 보면 ['dog', 'dog', 'lion', 'dog']가 남게 됩니다. 'lion' 아이템이 제거됮 않고 살아있네요. 왜 그런걸까요? for 반복문에 세번째 실행될 때, 리스트에서 'cat'이 제거되고 ['dog', 'dog', 'lion', 'dog']가 남게 됩니다. 다음번 4번째 실행될 때, 반복자는 3이되므로 리스트에서 'lion'을 가져오는 것이 아니라 건너띄고 'dog'를 가져오게 되는 겁니다. 따라서 'lion'이 제거되지 않고 남아있게 됩니다. 위와 같은 에러를 피하기 위해서는 아래와 같이 사용할 수 있습니다.

```python
animals = ['dog', 'dog', 'cat', 'lion', 'dog']
dogs = []
for animal in animals:
    if animal == 'dog':
        dogs.append(animal)
animals = dogs  # 기존 리스트를 교체함

# 혹은 리스트 컴프리헨션을 사용할 수 있다.
animals = [animal for animal in animals if animal == 'dog']
```
<br>
# 2. 가변 값을 복사할 때는 항상 copy.copy()를!
&#160; 파린이 시절 가장 이해 안됐던 warning중에 하나가 dataframe객체를 다루다가 발생하는 SettingWithCopyWarning이었습니다. 데이터 전처리 작업을 하다보면 dataframe 새로운 변수에 할당해서 수정을 하게되는 경우가 있는데 그때마다 warning이 발생했습니다. 왜 이런 warning이 발생하게 될까요? 파이썬의 할당문은 절대 객체를 복사하지 않습니다. 그저 기존 객체에 대한 **참조**를 복사하기에 발생하게 됩니다. (여기에 파이썬은 chained 연산을 허용하기에 발생하게 되는데 여기서 다루진 않겠습니다.) 아래 예를 보겠습니다.

```python
animals = ['cat', 'dog', 'lion', 'tiger']
name = animals
animals[2] = 'LION'  # animal 리스트 아이템을 수정했습니다. name 리스트에도 영향을 미칠까요?
```

&#160; animal 리스트에 대해서만 수정을 했지만 실제로 확인해보면 name 리스트의 아이템도 수정된 것을 확인할 수 있습니다. 앞서 말헀듯이 할당문은 객체에 대한 참조를 복제하는 것이기에 animals와 name모두 컴퓨터의 메모리에 동일한 리스트 객체를 참조하고 있기 때문입니다. (함수 호출에 전달된 가변 객체도 동일한 원리가 적용됩니다.)<br><br>
&#160; 따라서 위와 같은 에러를 피하기 위해서는 반드시 **copy.copy() 메소드를 활용해 객체의 복사본**을 만들어야 합니다! copy.deepcopy() 메소드는 가변 객체 내에 있는 모든 가변 객체를 복사할 수 있습니다. deepcopy()는 약간 느리지만 모든 가변 객체에 대해 복사하기 때문에 더 안전하다는 장점이 있습니다.

# 3. 기본 인수에 가변 객체는 사용 X
&#160; 파이썬 프로그래밍에서 함수를 정의할 때, 파라미터에 대해 기본 인수(default argument)를 설정할 수 있습니다. 기본 인수가 설정되어 있으면 함수를 실행할 때 인수를 입력하지 않으면 기본 인수를 사용해 함수가 실행되게 됩니다. 중요한 것은 함수를 정의할 때, 리스트나 딕셔너리 같은 가변 객체를 기본 인수로 설정해서는 안 된다는 것입니다. 가변 객체를 기본 인수로 사용하면 미묘한 버그가 발생할 수 있는데 예를 들어 설명해보겠습니다.
```python
def addAnimals(animal, animal_list = ['cat', 'dog']):
    animal_list.insert(1, animal)
    return animal_list

myAnimal = addAnimals('bird')
myAnimal = addAnumals('pig')  # myAnimal 리스트는 ['cat', 'dog', 'bird', 'pig']가 됩니다. 
```

&#160; 위 예제에서, 기본 인수로 설정된 리스트(['cat', 'dog'])는 언제 생성되는 것일까요? 함수를 호출할 떄마다 새로운 리스트 객체가 생성되는 것이 아니라 맨 처음 함수를 정의할 때 리스트 객체가 생성되게 됩니다. 따라서 이 addAnimals 함수를 호출할 때마다 리스트 객체를 재사용하게 됩니다. 따라서 가변 객체를 기본 인수로 사용하는 것은 지양해야 합니다. 하지만 만약 기본 인수로 설정해야 할 때 어떻게 하면 될까요? 바로 None으로 설정하는 것입니다.
```python
def addAnimals(animal, animal_list = None):
    if animal_list is None:
        animal_list = ['cat', 'dog']
    animal_list.insert(1, animal)
    return animal_list
```

&#160; 위와 같이 함수를 정의하면 함수를 호출할 때마다 리스트를 새롭게 생성하게 됩니다. 

# 4. 문자열 연결 적절하게 하기!
&#160; 파이썬에서 문자열은 불변 객체로 문자열을 수정하는 것처럼 보이는 코드도 실은 새로운 문자열을 생성합니다. f-문자열 역시 새로운 문자열 객체를 생성하게 됩니다. 문제는 수 많은 문자열을 연결하게 되면 프로그램이 매우 느려질 수 있습니다. 다음과 같은 예를 봅시다.
```python
finalString = ''
for i in range(100000):
    finalString += 'mato '
```

&#160; 위 루프문은 10만 번을 반복하면서 새로운 문자열 객체를 생성하고 버리는 것을 반복하면서 엄청난 메모리 낭비가 발생하게 됩니다. 따라서 문자열을 만드는 파이썬다운 방법은 아래와 같습니다.
```python
finalString = []
for i in range(100000):
    finalString.append('mato')

finalString = ' '.join(finalString)
```

&#160; 리스트 객체에 값을 반복하여 추가한 다음 문자열의 join 메소드를 활용하여 문자열 객체를 생성해줍니다. 실제로 프로그램을 실행해 런타임을 비교하면 굉장히 큰 시간 차이가 발생하게 되는 것을 알 수 있습니다.

# 5. sort()가 알파벳 순으로 정렬할까?
&#160; 파이썬에서 sort() 방식은 알파벳 정렬이 아닌 아스키 정렬을 따릅니다. 따라서 영어 알파벳의 대문자의 코드포인트(정수)가 소문자의 코드포인트 보다 작습니다. 그래서 알파벳을 정렬하면 대문자 Z가 소문자 a보다 앞에 오게 됩니다. 만약, 알파벳 정렬을 하려면 str.lower 메소드를 key 파라미터에 전달해주면 됩니다.
```python
letters = ['z', 'A', 'a', 'Z']
letters.sort(key = str.lower)  # ['A', 'a', 'z', 'Z']로 정렬됨
```

<br>
# 6. 부동소스는 완벽하게 정확할까?
&#160; 컴퓨터는 1과 0의 이진수 시스템 자릿수만 저장할 수 있습니다. 따라서 우리가 자주 사용하는 십진수의 수를 표시하기 위해서는 수의 대응하는 이진수로 변환해야 합니다. 보통 이 과정은 우리들에게 보여지지 않습니다. 재밌는 것은 부동소수의 표현이 항상 정환한 것은 아니라는 것입니다. 아래 유명한 예를 보시죠.
```python
0.3 == 0.1 + 0.1 + 0.1 
```

&#160; 놀랍게도 False가 반환됩니다. 실제로 0.1 + 0.1 + 0.1은 0.300000000004를 반환합니다. 이 요상한 덧셈 결과는 컴퓨터가 부동소수를 표현하고 다루는 방식에 의해 야기되는 반올림 에러(rounding error)의 결과입니다. 이는 비단 파이썬만의 문제는 아닙니다(CPU에서 실행되는 모든 언어에서 동일합니다!). 또 하나 신기한 예는, 기술적인 이유로 2^53보다 큰 모든 숫자를 나타낼 수 없습니다.
```python
float(2**53) == float(2**53) + 1
```

&#160; 앞서 얘기했듯이 2^53보다 큰 숫자를 표현할 수 없기에 True가 반환됩니다. 만약, 과학이나 혹은 재무 계산을 위해 정확한 정밀도가 필요하다면 decimal 모듈을 사용하면 됩니다. 비록 속도는 조금 느릴 수 있더라도 decimal 객체는 부동소수 값을 정확하게 대체합니다. decimal.Decimal('0.1')은 정확한 숫자 0.1을 나타내는 객체를 생성합니다.<br>

# 7. != 는 연달아 쓰지 말기!
&#160; 논리 연산을 할 때, 논리 연산자를 연달아 쓰곤 하지만 부등 연산자(!=)는 연달아 쓰면 안 됩니다. 아래 예를 들어보겠습니다.
```python
a, b, c = 'cat', 'dog', 'cat'
a != b != c  
```

&#160; 위 논리 연산의 값은 어떻게 될까요? 놀랍게도 False가 아닌 True가 반환됩니다. 눈치채신 분도 계시겠지만 a != b != c는 (a != b) and (b != c) and (a != c)가 아니라 (a != b) and (b != c)입니다. 직관적으로는 세 값이 같아야지만 True일 것 같지만 그렇지 않습니다. 

# 8. 단일 아이템 튜플에는 쉼표를!
&#160; 코드에 튜플 값을 쓸 때는 단일 아이템만 포함돼도 쉼표(,)가 꼭 필요합니다.
```python
animals = ('cat')
animals[0]
# c가 반환됨
animals = ('cat', )
animals[0]
# cat이 반환됨
```

&#160; 쉼표 하나 차이로 달라지게 되는데, 쉼표가 없으면 ('cat')은 문자열 값으로 평가되기 때문입니다.<br>

# 9. 마치며...
&#160; 이 장에서 다룬 내용들은 어찌보면 사소할 수 있는 내용들입니다. 하지만 만에 하나라도 프로그램을 작성하다가 이런 문제와 마주친다면 쉽게 버그를 찾아내기 어려울 수 있겠죠. 사소하더라도 이런 사항들을 알아둔다면 디버깅하는 데 매우 큰 도움이 될 수 있을 거라 생각합니다.