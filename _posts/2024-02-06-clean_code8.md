---
title: "[파이썬] 빠지기 쉬운 함정들. 이것만은 피하자!"

categories:
    - Python
tags:
    - Python
    - Coding
    - Review
last_modified_at: 2024-02-06T21:55:00

toc: true
toc_sticky: true
toc_label: "On This Page"
---

> 이번 포스트는 파이썬을 사용하면서 빠지기 쉬운 함정들을 알아보고 어떻게 하면 이 함정들을 피할 수 있는지 정리해봤습니다. <br>

> 이 포스트의 내용은 저자 Al Sweigart의 "클린 코드, 이제는 파이썬이다" 8장 내용임을 사전에 미리 밝힙니다!

&#160; 파이썬은 제가 가장 많이 사용하는 데이터 분석 도구 중 하나입니다. 사용하다 보면 종종 알 수 없는 warnings가 발생하곤 했지만 잘 모르기에 넘어가곤 했습니다. 아무래도 파이썬의 모든 작동원리를 알지 못하기 때문입니다. 이 책을 읽으면서 그동안 발생했던 warnings의 의미, 모르고 지나쳤던 것들을 알 수 있었기에 정리해보고자 합니다!

# 1. 루프문 진행 중에는 리스트에 아이템을 추가/삭제하지 말자
&#160; 리스트를 반복하는 루프문 내에서 리스트에 아이템을 추가/삭제하는 경우에는 버그가 발생할 수 있습니다. 책에 실린 예제와 함께 보겠습니다. <br>
```python
clothes = ['pants', 'red sock']
for clothing in clothes:  # 리스트 반복
    if 'sock' in clothing:  # 'sock' 문자열 찾기
        clothes.append(clothing)  # 일치하는 clothing 리스트에 추가
        print('Added a sock:', clothing)
```

실제로 위 코드를 파이썬에서 실행하게되면 프로그램이 무한정 돌게 됩니다. 왜 그렇게 되는 걸까? 루프문이 처음 동작할 때는 clothing이 pants이므로 리스트에 추가되지 않고 리스트에 다음 아이템으로 넘어가게 됩니다. 두 번째 반복할 때, 리스트에 red sock이 추가되고 clothes 리스트는 ['pants', 'red sock', 'red sock']으로 새 아이템이 추가됩니다. 하지만 for 문이 시작할 때 리스트에는 2개의 아이템이 있어서 for 반복문이 2번만 수행될 것 같지만 리스트에 새로운 아이템이 추가되면서 for 반복문은 다음 아이템에 대해 수행되게 됩니다. 이런식으로 리스트에 아이템이 무한하게 추가되고 for 반복문 또한 무한으로 돌게되는 것입니다. <br>

&#160; 그렇다면 어떻게 하면 될까? 다음과 같이 코드를 수정하게 되면 더 이상 위와 같은 에러는 발생하지 않게 됩니다.
```python
clothes = ['skirt', 'red sock', 'blue sock']
newClothes = []
for clothing in clothes:
    if 'sock' in clothing:
        newClothes.append(clothing)  # clothes 리스트가 아닌 newClothes 리스트에 아이템을 추가
clothes.append(newClothes)  # newClothes에 있는 아이템들을 기존 clothes리스트에 추가하기
```

&#160; 조금 번거롭긴 하지만 새로운 리스트 객체를 생성한 다음 아이템을 추가해줍니다. 그 다음 기존 리스트에 생성된 리스트에 아이템을 추가해주면 원하는 결과를 얻을 수 있게 됩니다.
<br>
&#160; 또한 앞서 말한 것처럼 리스트를 반복할 떄 아이템을 삭제하는 것도 지양해야합니다. 역시 예를 보고 설명하겠습니다.

```python
animals = ['dog', 'dog', 'cat', 'lion', 'dog']
for i, animal in enumerate(animals):
    if animal != 'dog':  # dog가 아닌 동물들을 리스트에서 제거
        del animals[i]
```
&#160; animals의 최종 결과물을 보면 ['dog', 'dog', 'lion', 'dog']가 남게 됩니다. 'lion' 아이템이 제거됮 않고 살아있네요. 왜 그런걸까요? for 반복문에 세번째 실행될 때, 리스트에서 'cat'이 제거되고 ['dog', 'dog', 'lion', 'dog']가 남게 됩니다. 다음번 4번째 실행될 때, 반복자는 3이되므로 리스트에서 'lion'을 가져오는 것이 아니라 건너띄고 'dog'를 가져오게 되는 겁니다. 따라서 'lion'이 제거되지 않고 남아있게 됩니다. 위와 같은 에러를 피하기 위해서는 아래와 같이 사용할 수 있습니다.

```python
animals = ['dog', 'dog', 'cat', 'lion', 'dog']
dogs = []
for animal in animals:
    if animal == 'dog':
        dogs.append(animal)
animals = dogs  # 기존 리스트를 교체함

# 혹은 리스트 컴프리헨션을 사용할 수 있다.
animals = [animal for animal in animals if animal == 'dog']
```
<br>
# 2. 가변 값을 복사할 때는 항상 copy.copy()를!
&#160; 파린이 시절 가장 이해 안됐던 warning중에 하나가 dataframe객체를 다루다가 발생하는 SettingWithCopyWarning이었습니다. 데이터 전처리 작업을 하다보면 dataframe 새로운 변수에 할당해서 수정을 하게되는 경우가 있는데 그때마다 warning이 발생했습니다. 왜 이런 warning이 발생하게 될까요? 파이썬의 할당문은 절대 객체를 복사하지 않습니다. 그저 기존 객체에 대한 **참조**를 복사하기에 발생하게 됩니다. (여기에 파이썬은 chained 연산을 허용하기에 발생하게 되는데 여기서 다루진 않겠습니다.) 아래 예를 보겠습니다.

```python
animals = ['cat', 'dog', 'lion', 'tiger']
name = animals
animals[2] = 'LION'  # animal 리스트 아이템을 수정했습니다. name 리스트에도 영향을 미칠까요?
```

&#160; animal 리스트에 대해서만 수정을 했지만 실제로 확인해보면 name 리스트의 아이템도 수정된 것을 확인할 수 있습니다. 앞서 말헀듯이 할당문은 객체에 대한 참조를 복제하는 것이기에 animals와 name모두 컴퓨터의 메모리에 동일한 리스트 객체를 참조하고 있기 때문입니다. (함수 호출에 전달된 가변 객체도 동일한 원리가 적용됩니다.)<br><br>
&#160; 따라서 위와 같은 에러를 피하기 위해서는 반드시 **copy.copy() 메소드를 활용해 객체의 복사본**을 만들어야 합니다! copy.deepcopy() 메소드는 가변 객체 내에 있는 모든 가변 객체를 복사할 수 있습니다. deepcopy()는 약간 느리지만 모든 가변 객체에 대해 복사하기 때문에 더 안전하다는 장점이 있습니다.