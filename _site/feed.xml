<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-09-16T13:21:00+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">끊임없이 성장하는 데이터 분석가</title><subtitle>조금씩 쌓아가다 보면 큰 산이 되겠지</subtitle><author><name>박마토</name></author><entry><title type="html">[SQL] LeetCode 풀이: Advanced Select and Joins(1/2)</title><link href="http://localhost:4000/data/SQL_LeetCode8/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이: Advanced Select and Joins(1/2)" /><published>2023-09-16T00:00:00+09:00</published><updated>2023-09-13T06:00:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode8</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode8/"><![CDATA[<p>  안녕하세요. 이번 Section은 Advanced Select and Joins입니다.</p>

<h1 id="5-advanced-and-select-joins">5. Advanced and Select Joins</h1>
<h2 id="51-1731-the-number-of-employees-which-report-to-each-employee">5.1 1731. The Number of Employees Which Report to Each Employee</h2>
<p>  모든 manager에 이름과 다이렉트로 보고하는 employee에 수, 그리고 employee의 평균 나이를 구하는 문제입니다.
단계를 나눠보면,</p>
<blockquote>
  <ol>
    <li>manager 알아내기</li>
    <li>manager에게 리포트하는 employee 수 집계하기</li>
    <li>manager에게 리포트하는 employee의 평균 나이 집계하기</li>
  </ol>
</blockquote>

<p>순으로 정리하면 될 것 같습니다.</p>

<h3 id="511-solution">5.1.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">employee_id</span>             <span class="k">as</span> <span class="n">employee_id</span><span class="p">,</span>
    <span class="n">a</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
    <span class="k">count</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">employee_id</span><span class="p">)</span>      <span class="k">as</span> <span class="n">reports_count</span><span class="p">,</span>
    <span class="n">round</span><span class="p">(</span><span class="k">avg</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">age</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>      <span class="k">as</span> <span class="n">average_age</span>
<span class="k">FROM</span>
    <span class="n">Employees</span> <span class="n">a</span>
<span class="k">INNER</span> <span class="k">Join</span> <span class="n">Employees</span> <span class="n">b</span>
    <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">employee_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">reports_to</span>
<span class="k">GROUP</span> <span class="k">BY</span>
    <span class="n">a</span><span class="p">.</span><span class="n">employee_id</span>
<span class="k">ORDER</span> <span class="k">By</span>
    <span class="n">a</span><span class="p">.</span><span class="n">employee_id</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  manager를 찾아내기 위해 Self Table Join을 활용했습니다. Join Key를 a 테이블에서는 employee_i와 b 테이블에서 reports_to로 설정해 줍니다. 게다가 INNER Join을 했기 때문에 a.employee_id와 b.reports_to가 두 테이블에 모두 있는 케이스만 Join이 됩니다. 그려보면 a 테이블에는 매니저만 남고, b 테이블이 employee가 join되는 그림입니다. 따라서 최종 테이블에 manager만 남게 됩니다.<br />
  그 다음부터는 집계함수를 이용하여 집계하면 문제는 풀립니다!</p>

<h2 id="52-1789-primary-department-for-each-employee">5.2 1789. Primary Department for Each Employee</h2>
<p>  Employee 별로 primary department를 구하는 문제입니다. 이 문제에서 고려해야 할 점은 employee가 속한 department가 꼭 1개가 아니라 1개 이상인 경우가 있다는 것입니다.</p>

<h3 id="521-solution">5.2.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">employee_id</span><span class="p">,</span>
    <span class="n">department_id</span>
<span class="k">FROM</span> 
    <span class="n">Employee</span>
<span class="k">WHERE</span>
    <span class="n">primary_flag</span> <span class="o">=</span> <span class="s1">'Y'</span>
<span class="k">UNION</span>
<span class="k">SELECT</span>
    <span class="n">employee_id</span><span class="p">,</span>
    <span class="n">department_id</span>
<span class="k">FROM</span>
    <span class="n">Employee</span>
<span class="k">Where</span>
    <span class="n">employee_id</span> <span class="k">in</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">employee_id</span> <span class="k">FROM</span> <span class="n">Employee</span> 
                    <span class="k">Group</span> <span class="k">By</span> <span class="n">employee_id</span> <span class="k">Having</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">;</span>

</code></pre></div></div>
<p>  Employee 별로 속한 department수가 상이하기 때문에 아예 나눠서 처리하는 게 적절해 보입니다. 1. department가 2개 이상인 경우, primary_flag = ‘Y’인 조건으로 primary department를 구하고 2. 1개일 경우는 그 department가 primary department이기에 department수가 1개인 경우만 조건으로 걸어서 primary department를 구해줍니다. 그 다음에는 Union을 활용해 두 결과를 하나의 테이블로 구해주면 됩니다!</p>

<h3 id="522-good-to-know">5.2.2 Good to Know</h3>
<p>  SQL에서는 UNION과 UNION ALL을 활용해 두 테이블을 하나의 테이블로 합칠 수 있습니다. 파이썬에서 pd.concat()과 유사한 것으로 생각하면 되겠네요. 사용법은 간단합니다.
<code class="language-plaintext highlighter-rouge">(A 테이블) UNION (ALL) (B 테이블)</code> 입니다. 컬럼명을 기준으로 union되는 것 같으니 컬럼명에 주의하고 활용하면 됩니다. UNION의 경우에는 중복값을 제거하는 반면, UNION ALL은 중복값을 제거해주지 않으므로 상황에 맞게 사용하시면 됩니다!</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[  안녕하세요. 이번 Section은 Advanced Select and Joins입니다.]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이: Sorting and Grouping(2/2)</title><link href="http://localhost:4000/data/SQL_LeetCode7/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이: Sorting and Grouping(2/2)" /><published>2023-09-12T00:00:00+09:00</published><updated>2023-09-13T06:00:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode7</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode7/"><![CDATA[<p>  안녕하세요. 드디어 문제는 다 풀었습니다! 문제 풀었던 것들 정리하면서 부족한 부분은 채우고자 합니다. 문제를 어떻게 풀었는지와 공부한 것들만 적고 필요없는 부분은 굳이 안 적으려고 합니다.</p>

<h1 id="4-sorting-and-grouping">4. Sorting and Grouping</h1>
<h2 id="46-1729-find-followers-count">4.6 1729 Find Followers Count</h2>
<p>  각 user 별로 follower가 몇 명인지를 구하는 문제입니다. 쉬운 문제네요.</p>

<h3 id="461-solution">4.6.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">user_id</span><span class="p">,</span>
    <span class="k">count</span><span class="p">(</span><span class="n">follower_id</span><span class="p">)</span>  <span class="k">as</span> <span class="n">followers_count</span>
<span class="k">FROM</span>
    <span class="n">Followers</span>
<span class="k">Group</span> <span class="k">By</span>
    <span class="n">user_id</span>
<span class="k">Order</span> <span class="k">By</span>
    <span class="n">user_id</span> <span class="k">asc</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  user 별로 follwer 수를 집계하면 됩니다!</p>

<h2 id="47-619-biggest-single-number">4.7 619. Biggest Single Number</h2>
<p>  MyNumbers Table에 num 중 오직 한 번만 나타난 것 중 가장 큰 값을 구하는 문제입니다. num 별로 수를 count로 집계하여 그 값이 1인 num만 가져오는 조건을 주면 될 것 같습니다.</p>
<h3 id="471-solution">4.7.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="k">Max</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>    <span class="k">as</span> <span class="n">num</span>
<span class="k">FROM</span>
    <span class="n">MyNumbers</span>
<span class="k">WHERE</span>
    <span class="n">num</span> <span class="k">in</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">num</span> <span class="k">FROM</span> <span class="n">MyNumbers</span> <span class="k">Group</span> <span class="k">By</span> <span class="n">num</span> <span class="k">HAVING</span> <span class="k">count</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  문제를 보고 떠올렸던 것은 우선 NyNumbers에서 중복되지 않은 값만 추려서 가져오자였습니다. 그래서 HAVING을 사용해서 <code class="language-plaintext highlighter-rouge">count(num) = 1</code> 조건을 걸어서 중복된 값들은 제거했습니다.
그 다음에 <code class="language-plaintext highlighter-rouge">in</code>을 사용해 해당 num만 가져온 후, <code class="language-plaintext highlighter-rouge">max</code>값을 구했습니다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[  안녕하세요. 드디어 문제는 다 풀었습니다! 문제 풀었던 것들 정리하면서 부족한 부분은 채우고자 합니다. 문제를 어떻게 풀었는지와 공부한 것들만 적고 필요없는 부분은 굳이 안 적으려고 합니다.]]></summary></entry><entry><title type="html">[회고록] 23년 9월 1주차: 에너지 절감(2/2)</title><link href="http://localhost:4000/data/weekly_memoir_9/" rel="alternate" type="text/html" title="[회고록] 23년 9월 1주차: 에너지 절감(2/2)" /><published>2023-09-04T00:00:00+09:00</published><updated>2023-09-05T07:24:00+09:00</updated><id>http://localhost:4000/data/weekly_memoir_9</id><content type="html" xml:base="http://localhost:4000/data/weekly_memoir_9/"><![CDATA[<p>  안녕하세요. 지난 <a href="https://mato-park.github.io/data/weekly_memoir_5/">회고록</a>에서 적었던 에너지 절감 프로젝트가 마무리되어 가고 있습니다. 프로젝트를 진행하면서 <a href="https://mato-park.github.io/data/weekly_memoir_7/">분석 모델링</a>도 수행하기도 했고 이 얘기에 이어서 마무리 짓지 못했던 회고록을 이어서 작성해보겠습니다. 
<br /><br /></p>

<h2 id="4-에너지-절감-포인트-도출">4. 에너지 절감 포인트 도출</h2>
<p>  앞의 과정이 끝났다면 에너지 별로 문제점 진단이 끝났을 것입니다. 그럼 데이터 분석을 통한 에너지 절감이 가능한 경우는 다음과 같이 정리가 될 것입니다.</p>
<blockquote>
  <ol>
    <li>에너지 사용량의 산포(범위, 표준편차, 분산, 사분위 범위 등)가 큰 경우</li>
    <li>과거 설비 운전 패턴이 다양한 경우</li>
    <li>공정 품질 수준이 관리선 대비 여유가 큰 경우</li>
    <li>에너지 관련 관리 지표의 변동이 있는 경우</li>
  </ol>
</blockquote>

<p>  각 상황 별로 분석한 내용에 대해서 간략하게 정리하겠습니다.</p>

<h3 id="41-에너지-사용량-산포-원인분석">4.1 에너지 사용량 산포 원인분석</h3>
<p>  말 그대로 에너지 사용량 산포가 큰 이유를 찾아내는 것입니다. 어떤 공정, 품질 인자로 인하여 에너지 사용량의 변동이 큰지 탐색해 나갑니다. 우선 공정 별로 <strong>공정 메커니즘 이해</strong>가 중요합니다. 왜냐하면 공정 별로 중요한 외생 변수는 무엇인지, 후보인자를 선별해야 하기 때문입니다. 중요 외생변수를 통제해가면서 에너지 사용량과 상관성이 높은 변수들을 탐색해 나갑니다. 주로 EDA를 하면서 인자들을 탐색하고 필요하다면 분석 모델링을 통해 다변량이 에너지 사용량에 미치는 효과를 추정해내기도 합니다.<br /><br />
  주요 인자들을 통제했음에도 불구하고 산포가 남아있는 경우가 바로 에너지 절감 포인트입니다. 공정 최적화가 되지 못해 에너지 사용량의 낭비가 있거나, 너무 과도하게 품질을 관리하고 있는 경우기 있을 수 있습니다. 주요 인자들을 제외한 공정 인자의 변동이 에너지 사용량의 영향을 미친다면 최적화를 통해 에너지 절감이 가능합니다.<br /><br />
  에너지 사용량의 산포가 있음에도 공정 인자와 매치되지 않는 경우는 설비 이상을 의심해봐야 합니다. 하지만 이 부분은 데이터로 볼 수 있는 부분이 아니기에, 우리는 문제점만 전달하고 현업 담당자에게 뒷 일은 맡겨야 합니다.</p>

<h3 id="42-최적-설비-운전-패턴-도출">4.2 최적 설비 운전 패턴 도출</h3>
<p>  특정 공정 관리 인자의 온도를 맞추기 위해서 열매의 온도와 유량을 조정하면서 열교환을 합니다. 이때 다양한 운전 패턴이 있을 수 있습니다. 그렇다면 이 운전 패턴 간 에너지 사용량을 비교해보고 어떤 운전 패턴이 최적인지 탐색해볼 수 있습니다. 쉽게 예를 들면, 여름에 더울 때 에어컨 온도를 낮추고 바람 세기를 적게 하는 것이 더 효율적인지 혹은 온도를 조금 높이고 바람 세기를 세게 하는 것이 효율적인지를 비교해보는 것이라 생각하면 될 것 같습니다. <br /><br />
  너무 쉽고 당연한 얘기죠? 하지만 의외로 이런 곳에서 절감포인트가 나옵니다. 데이터 인프라가 약한 조직이라면 과거 긴 시간의 데이터를 활용하지 못하기 때문에 분명히 놓치고 있는 것이 있을 수 있기 때문에 확인하면 좋은 포인트입니다.</p>

<h3 id="43-공정-품질-수준이-관리선-대비-여유가-큰-경우">4.3 공정 품질 수준이 관리선 대비 여유가 큰 경우</h3>
<p>  공정 관리 수준이 너무 타이트할 수 있습니다. 공정의 여유가 있다면 품질 수준을 조금 낮추고 에너지 사용량을 줄이는 방안도 고려해 볼 수 있습니다. 다만 이 부분도 분석가의 역할은 현황만 진단하고 나머지 판단은 현업에 맡겨야 합니다.</p>

<h3 id="44-에너지-관리-지표의-변동이-있는-경우">4.4 에너지 관리 지표의 변동이 있는 경우</h3>
<p>  예를 들어, 냉수 온도를 일정하게 유지해야 하는데 계절 별로 온도가 변동하는 경우가 있습니다. 이 경우, 데이터를 확인해 특별한 이유가 있는지 혹은 연관된 인자의 변동을 살펴보고 특별한 이유가 없다면 모종의 이유로 에너지가 낭비되고 있을 수 있습니다. 이 부분도 확인해보면 에너지 절감 포인트를 도출하는데 도움이 될 수 있습니다.</p>

<h2 id="5-개선안-도출">5. 개선안 도출</h2>
<p>  분석을 통해 도출한 에너지 절감 포인트를 활용하여 에너지 사용량 개선안을 내야 합니다. 사실 이 부분부터는 분석가의 역할이 아니라 현업 담당자의 역할입니다. 분석을 통해 발견한 인자를 최적화하거나 혹은 분석 결과를 기반으로 아이디어를 도출해 개선안을 수립하고 실제 공정에 Test해보고 결과를 비교해봅니다. <br /><br /> 
  뻔한 얘기지만 좋은 개선안을 내기 위해서는 좋은 분석의 선행이 필수인 것 같습니다. 왜냐하면 현업 담당자들을 에너지 절감을 위해 이미 다양한 아이디어를 내고 개선 활동을 하고 있기에, 새로운 것을 제시하고 설득하기 위해서는 철저한 논리와 데이터 기반의 객관적인 근거가 필요하기 때문입니다.</p>

<h2 id="6-모니터링-시스템-구축">6. 모니터링 시스템 구축</h2>
<p>  분석하고 개선안 내서 적용하면 끝일까요? 아닙니다. 에너지 사용량이 잘 관리되고 있는지 모니터링 할 수 있는 시스템이 필요합니다. 이번 프로젝트에서는 BI Tool을 활용해 향후 일별로 에너지 사용량을 모니터링 할 수 있는 시각화 대시보드 App을 개발하여 활용할 수 있게 했습니다. 앞으로는 과거 데이터와 비교하여 현재 에너지 사용량이 적절한지 판단할 수 있는 시스템이 갖춰졌습니다. 조직원 모두가 에너지 사용량을 확인할 수 있고 분석할 수 있습니다. 어쩌면 데이터 기반 의사결정 문화에도 큰 도움이 되리라 생각합니다.</p>

<h2 id="7-프로젝트를-마치며">7. 프로젝트를 마치며..</h2>
<p>  에너지 절감 분석 프로젝트를 해보니 <strong>현업 담당자들이 놓치고 있던 부분을 데이터를 활용해 짚어내는 것</strong>이 주효했던 것 같습니다. 생각보다(?) 현업 담당자들은 다 잘하고 있고 문제없다 얘기하지만, 데이터를 까보면 아닌 경우가 허다했습니다. 그리고 분석의 난이도가 높아서 어렵다기보다는 공장의 모든 설비와 에너지를 살펴봐야 했기에 힘들었던 분석이었습니다. 그래도 에너지 별로 낭비요소를 찾아내고 개선이 이뤄지는 것을 보면서 역시 뿌듯하고 즐거웠던 프로젝트였습니다. 물론 아직 끝나지 않았습니다…</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="Memoir" /><summary type="html"><![CDATA[  안녕하세요. 지난 회고록에서 적었던 에너지 절감 프로젝트가 마무리되어 가고 있습니다. 프로젝트를 진행하면서 분석 모델링도 수행하기도 했고 이 얘기에 이어서 마무리 짓지 못했던 회고록을 이어서 작성해보겠습니다.]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이: Sorting and Grouping(1/2)</title><link href="http://localhost:4000/data/SQL_LeetCode6/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이: Sorting and Grouping(1/2)" /><published>2023-07-31T00:00:00+09:00</published><updated>2023-08-01T06:00:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode6</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode6/"><![CDATA[<p>  안녕하세요. LeetCode50 50문제 별로 없네 생각하면서 시작했는데 고민해보고 정리하면서 하다보니 예상보다는 길어지네요. 부지런히 공부해서 8월달 내에는 끝내야겠습니다</p>

<h1 id="4-sorting-and-grouping">4. Sorting and Grouping</h1>
<h2 id="41-number-of-unique-subjects-taught-by-each-teacher">4.1 Number of Unique Subjects Taught by Each Teacher</h2>
<h3 id="411-table-description--question">4.1.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Teacher</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>teacher_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>subject_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>dept_id(PK)</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>(subject_id, dept_id) is the primary key for this table.<br />
Each row in this table indicates that the teacher with teacher_id teaches the subject subject_id in the department dept_id.</p>
</blockquote>

<p><strong>Question</strong><br /></p>
<ul>
  <li>Calculate the number of unique subjects each teacher teaches in the university.</li>
  <li>Return the result table in any order.</li>
</ul>

<h3 id="412-solution">4.1.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">teacher_id</span><span class="p">,</span>
    <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="n">subject_id</span><span class="p">)</span>  <span class="k">as</span> <span class="n">cnt</span>
<span class="k">FROM</span>
    <span class="n">Teacher</span>
<span class="k">GROUP</span> <span class="k">BY</span>
    <span class="n">teacher_id</span>
</code></pre></div></div>
<p>  선생님 별로 가르치는 과목 수를 구하면 된다. 중복을 제거하기 위하여 count 함수 안에 ‘distinct’를 적어주자 끝!</p>

<h2 id="42-user-activity-for-the-past-30-days-1">4.2 User Activity for the Past 30 Days 1</h2>
<h3 id="421-table-description--question">4.2.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Activity</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>user_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>session_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>activity_date</td>
      <td>date</td>
    </tr>
    <tr>
      <td>activity_type</td>
      <td>enum</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>There is no primary key for this table, it may have duplicate rows.<br />
The activity_type column is an ENUM of type (‘open_session’, ‘end_session’, ‘scroll_down’, ‘send_message’).<br />
The table shows the user activities for a social media website. <br />
Note that each session belongs to exactly one user.</p>
</blockquote>

<p><strong>Question</strong><br /></p>
<ul>
  <li>Write an SQL query to find the daily active user count for a period of 30 days ending 2019-07-27 inclusively. A user was active on someday if they made at least one activity on that day.</li>
  <li>Return the result table in any order.</li>
</ul>

<h3 id="422-solution">4.2.2 Solution</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Select</span>
    <span class="n">activity_date</span>   <span class="k">As</span> <span class="k">day</span><span class="p">,</span>
    <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="n">user_id</span><span class="p">)</span> <span class="k">As</span> <span class="n">active_users</span>
<span class="k">FROM</span>
    <span class="n">Activity</span>
<span class="k">WHERE</span>
    <span class="n">activity_date</span> <span class="k">BETWEEN</span> <span class="n">Date_Sub</span><span class="p">(</span><span class="s1">'2019-07-27'</span><span class="p">,</span> <span class="n">INTERVAL</span> <span class="mi">29</span> <span class="k">DAY</span><span class="p">)</span>
    <span class="k">AND</span> <span class="s1">'2019-07-27'</span>
<span class="k">GROUP</span> <span class="k">BY</span>
    <span class="n">activity_date</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  2019년 7월 27일을 기준으로 30일 전부터 기준일까지 일자별로 활성화 유저 수를 계산하면 된다. count를 사용하여 수를 집계하고 기간은 Where 절에 Between과 date_sub를 활용하여 기간 조건을 설정했다.</p>

<h2 id="43-product-sales-analysis-3">4.3 Product Sales Analysis 3</h2>
<h3 id="431-table-description--question">4.3.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Sales</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>sale_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>product_id(FK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>year(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>quantity</td>
      <td>int</td>
    </tr>
    <tr>
      <td>price</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>(sale_id, year) is the primary key of this table.<br />
product_id is a foreign key to Product table.<br />
Each row of this table shows a sale on the product product_id in a certain year.<br />
Note that the price is per unit.</p>
</blockquote>

<p>table: Product</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>product_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>product_name</td>
      <td>varchar</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>product_id is the primary key of this table.<br />
Each row of this table indicates the product name of each product.<br /></p>
</blockquote>

<p><strong>Question</strong> <br /></p>
<ul>
  <li>Write an SQL query that selects the product id, year, quantity, and price for the first year of every product sold.</li>
  <li>Return the resulting table in any order.</li>
</ul>

<p>  product별로 첫 해에 판매한 수량과 판매가격을 구하는 문제이다.</p>

<h3 id="432-solution">4.3.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">product_id</span><span class="p">,</span>
    <span class="nb">year</span>        <span class="k">As</span> <span class="n">first_year</span><span class="p">,</span>
    <span class="n">quantity</span><span class="p">,</span>
    <span class="n">price</span>
<span class="k">FROM</span>
    <span class="n">Sales</span>
<span class="k">Where</span>
    <span class="p">(</span><span class="n">product_id</span><span class="p">,</span> <span class="nb">year</span><span class="p">)</span> <span class="k">in</span> <span class="p">(</span><span class="k">Select</span> <span class="n">product_id</span><span class="p">,</span> <span class="k">Min</span><span class="p">(</span><span class="nb">year</span><span class="p">)</span> <span class="k">as</span> <span class="nb">year</span>
     <span class="k">From</span> <span class="n">Sales</span> <span class="k">Group</span> <span class="k">By</span> <span class="n">product_id</span><span class="p">)</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  각 Product 별로 첫 해에 해당하는 Record를 어떻게 가져올까 고민을 많이 했었다. 처음에 떠올린 아이디어는 프로덕트 별로 연도를 오름차순으로 정렬한 다음 가장 위에 있는 Record를 가져오는 것이었다. 구글링도 해봤지만 내가 생각했던 솔루션은 찾기 어려웠다. 따라서 다른 방법을 고민하다가 찾은 것이 위 쿼리문이다.<br />
  아이디어는 간단하다. 프로덕트 별로 첫 해는 year 값이 가장 <strong>낮은</strong> 값일 것이다. 왜냐하면 날짜는 일정한 방향으로 흐르기 때문이다. 따라서 WHERE 절에 subquery를 활용하여 프로덕트 별로 year가 가장 낮은 Record를 가져올 수 있는 조건 절을 추가했다.</p>

<h2 id="44-class-more-than-5-students">4.4 Class More Than 5 Students</h2>
<h3 id="441-table-descriptoin--question">4.4.1 Table descriptoin &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Courses</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>student(PK)</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>class(PK)</td>
      <td>varchar</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>(student, class) is the primary key column for this table.<br />
Each row of this table indicates the name of a student and the class in which they are enrolled.</p>
</blockquote>

<p><strong>Question</strong> <br /></p>
<ul>
  <li>Find all the classes that have at least five students.<br /></li>
  <li>Return the result table in any order.</li>
</ul>

<h3 id="382-solution">3.8.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="k">class</span>
<span class="k">FROM</span>
    <span class="n">Courses</span>
<span class="k">Group</span> <span class="k">By</span>
    <span class="k">class</span>
<span class="k">Having</span>
    <span class="k">Count</span><span class="p">(</span><span class="n">student</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span>
<span class="p">;</span>
</code></pre></div></div>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[  안녕하세요. LeetCode50 50문제 별로 없네 생각하면서 시작했는데 고민해보고 정리하면서 하다보니 예상보다는 길어지네요. 부지런히 공부해서 8월달 내에는 끝내야겠습니다]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이: Basic Aggregate Functions(2/2)</title><link href="http://localhost:4000/data/SQL_LeetCode5/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이: Basic Aggregate Functions(2/2)" /><published>2023-07-23T00:00:00+09:00</published><updated>2023-07-21T07:08:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode5</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode5/"><![CDATA[<p>  안녕하세요. 이번 포스트부터는 LeetCode50 Aggregate Functions 두번째 파트 이어 가겠습니다.</p>

<h1 id="3-basic-aggregate-functions">3. Basic Aggregate Functions</h1>
<h2 id="35-queries-quality-and-percentage">3.5 Queries Quality and Percentage</h2>
<h3 id="351-table-description--question">3.5.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Queries</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>query_name</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>result</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>position</td>
      <td>int</td>
    </tr>
    <tr>
      <td>rating</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>There is no primary key for this table, it may have duplicate rows.<br />
This table contains information collected from some queries on a database.<br />
The position column has a value from 1 to 500.<br />
The rating column has a value from 1 to 5. Query with rating less than 3 is a poor query.<br /></p>
</blockquote>

<p><strong>Question</strong><br /></p>
<ul>
  <li>We define query quality as: The average of the ratio between query rating and its position.</li>
  <li>We also define poor query percentage as: The percentage of all queries with rating less than 3.</li>
  <li>Write an SQL query to find each query_name, the quality and poor_query_percentage.</li>
  <li>Both quality and poor_query_percentage should be rounded to 2 decimal places.</li>
  <li>Return the result table in any order.</li>
</ul>

<h3 id="352-solution">3.5.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">query_name</span><span class="p">,</span>
    <span class="n">round</span><span class="p">(</span><span class="k">Avg</span><span class="p">(</span><span class="n">rating</span><span class="o">/</span><span class="k">position</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>      <span class="k">as</span> <span class="n">quality</span><span class="p">,</span>
    <span class="n">round</span><span class="p">(</span><span class="k">Avg</span><span class="p">(</span><span class="k">Case</span> <span class="k">When</span> <span class="n">rating</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">end</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>     <span class="k">as</span> <span class="n">poor_query_percentage</span>
    <span class="c1">-- round(avg(rating &lt; 3) * 100, 2) as poor_query_percentage</span>
<span class="k">FROM</span>
    <span class="n">Queries</span>
<span class="k">Group</span> <span class="k">By</span>
    <span class="n">query_name</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  문제에서 요구한 대로 quality와 poor_query_percentage를 구하면 된다. 다만, poor_query_percentage를 구하는 방법은 사람마다 스타일에 따라 다양한 방법으로 풀 수 있을 것 같다. 난 CASE 구문을 사용해서 rating 3을 기준으로 나눠줘서 Avg를 구했다. 다른 사람들의 풀이를 참조해보니 단순하게 <code class="language-plaintext highlighter-rouge">rating &lt; 3</code>구문으로도 구현한 방법도 있었다.</p>

<h2 id="36-monthly-transactions-i">3.6 Monthly Transactions I</h2>
<h3 id="361-table-description--question">3.6.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Prices</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>country</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>state</td>
      <td>enum</td>
    </tr>
    <tr>
      <td>amount</td>
      <td>int</td>
    </tr>
    <tr>
      <td>trans_date</td>
      <td>date</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>The table has information about incoming transactions.<br />
The state column is an enum of type [“approved”, “declined”].<br /></p>
</blockquote>

<p><strong>Question</strong><br />
Write an SQL query to find for each month and country, the number of transactions and their total amount, the number of approved transactions and their total amount.<br />
Return the result table in any order.</p>

<h3 id="362-solution">3.6.2 Solution</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">DATE_FORMAT</span><span class="p">(</span><span class="n">trans_date</span><span class="p">,</span> <span class="s1">'%Y-%m'</span><span class="p">)</span>        <span class="k">as</span> <span class="k">month</span><span class="p">,</span>
    <span class="n">country</span><span class="p">,</span>
    <span class="k">Count</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>                               <span class="k">as</span> <span class="n">trans_count</span><span class="p">,</span>
    <span class="k">SUM</span><span class="p">(</span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="k">state</span><span class="o">=</span><span class="nv">"approved"</span> <span class="k">THEN</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">End</span><span class="p">)</span>                 <span class="k">as</span> <span class="n">approved_count</span><span class="p">,</span>
    <span class="k">SUM</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>     <span class="k">As</span> <span class="n">trans_total_amount</span><span class="p">,</span>
    <span class="k">SUM</span><span class="p">(</span><span class="k">CASE</span> <span class="k">When</span> <span class="k">state</span><span class="o">=</span><span class="nv">"approved"</span> <span class="k">THEN</span> <span class="n">amount</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">END</span><span class="p">)</span>          <span class="k">as</span> <span class="n">approved_total_amount</span>
<span class="k">FROM</span>
    <span class="n">Transactions</span>
<span class="k">Group</span> <span class="k">By</span>
    <span class="k">month</span><span class="p">,</span>
    <span class="n">country</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  집계함수를 적절히 사용하면 간단하게 풀 수 있는 문제이다. CASE구문과 IF 구문은 취향에 따라 쓰면 될 것 같다. 사실 취향보다는 성능이 좋거나 가독성이 좋은 코드로 활용하는게 좋겠지만, 성능비교는 어려우므로 내 취향에 맞는 코드를 선택했다.</p>

<h2 id="37-immediate-food-delivery-ii">3.7 Immediate Food Delivery II</h2>
<h3 id="371-table-description--question">3.7.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Delivery</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>delivery_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>customer_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>order_date</td>
      <td>date</td>
    </tr>
    <tr>
      <td>customer_pref_delivery_date</td>
      <td>date</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>The table holds information about food delivery to customers that make orders at some date and specify a preferred delivery date (on the same order date or after it).</p>
</blockquote>

<p><strong>Question</strong> <br /></p>
<ul>
  <li>If the customer’s preferred delivery date is the same as the order date, then the order is called immediate; otherwise, it is called scheduled.<br /></li>
  <li>The first order of a customer is the order with the earliest order date that the customer made. It is guaranteed that a customer has precisely one first order.<br /></li>
  <li>Write an SQL query to find the percentage of immediate orders in the first orders of all customers, rounded to 2 decimal places.<br /></li>
</ul>

<p>  고객 별 첫주문이 Immediate Order인 비율을 구해야 하는 문제이다. 그렇다면 1. 고객 별로 첫 주문날짜를 구해야 하며, 2. 첫 주문이 Immediate인지 schedule인지 구해야 한다.</p>

<h3 id="372-solution">3.7.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">round</span><span class="p">((</span><span class="k">SUM</span><span class="p">(</span><span class="k">CASE</span> <span class="k">WHEN</span> 
        <span class="n">b</span><span class="p">.</span><span class="n">first_order_date</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">customer_pref_delivery_date</span>
        <span class="k">THEN</span> <span class="mi">1</span> <span class="k">ELSE</span> <span class="mi">0</span> <span class="k">END</span><span class="p">)</span> <span class="o">/</span> <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="n">a</span><span class="p">.</span><span class="n">customer_id</span><span class="p">))</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>        <span class="k">as</span> <span class="n">immediate_percentage</span>
<span class="k">FROM</span>
    <span class="n">Delivery</span> <span class="n">a</span>
<span class="k">LEFT</span> <span class="k">Join</span>
    <span class="p">(</span><span class="k">SELECT</span>
        <span class="n">customer_id</span><span class="p">,</span>
        <span class="k">Min</span><span class="p">(</span><span class="n">order_date</span><span class="p">)</span> <span class="k">as</span> <span class="n">first_order_date</span>
    <span class="k">FROM</span>
        <span class="n">Delivery</span>
    <span class="k">Group</span> <span class="k">By</span>
        <span class="n">customer_id</span>
    <span class="p">)</span> <span class="n">b</span>
    <span class="k">On</span> <span class="n">a</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">customer_id</span>
<span class="k">ORDER</span> <span class="k">By</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">customer_id</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">order_date</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  처음 고민했던 부분은 고객 별 첫 주문 날짜를 어떻게 구해야할까였다. Immediate인지, schedule인지 판단하는 두 번째 부분은 크게 어렵지 않게 풀 수 있었다. 그룹 별 sorting하여 first value를 찾아볼까도 했었는데 어려워서 진행하진 않았다. 다음 Idea로는 서브퀴리를 활용해 ‘first_order_date’를 구하여 Join하는 것이었다. 그에 맞게 SQL query를 작성하였고 문제는 잘 풀렸다.</p>

<h3 id="373-improved">3.7.3 Improved</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">where</span> <span class="p">(</span><span class="n">customer_id</span><span class="p">,</span> <span class="n">order_date</span><span class="p">)</span> <span class="k">in</span>
<span class="p">(</span>
    <span class="k">Select</span> <span class="n">customer_id</span><span class="p">,</span> <span class="k">min</span><span class="p">(</span><span class="n">order_date</span><span class="p">)</span> <span class="k">from</span> <span class="n">Delivery</span> <span class="k">group</span> <span class="k">by</span> <span class="n">customer_id</span>
<span class="p">)</span>
</code></pre></div></div>
<p>  문제를 풀고 다른 분들의 solutions을 참조해봤는데 역시나 좋은 답변이 있었다. 다른 사람들은 WHERE () in (); 절을 사용한 Solution들이 많았다. Join절 없이 (customer_id, order_rate)가 (customer_id, min(order_date))와 일치하는 Record들만 가져올 수 있도록 조건을 설정해서 first_order_date를 구할 수 있었다.</p>

<h2 id="38-game-play-analysis-iv">3.8 Game Play Analysis IV</h2>
<h3 id="381-table-descriptoin--question">3.8.1 Table descriptoin &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Activity</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>player_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>device_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>event_date</td>
      <td>date</td>
    </tr>
    <tr>
      <td>games_played</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>(player_id, event_date) is the primary key of this table.<br />
This table shows the activity of players of some games.<br />
Each row is a record of a player who logged in and played a number of games (possibly 0) before logging out on someday using some device.</p>
</blockquote>

<p><strong>Question</strong> <br /></p>
<ul>
  <li>Write an SQL query to report the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to count the number of players that logged in for at least two consecutive days starting from their first login date, then divide that number by the total number of players.<br /></li>
</ul>

<p>  이틀 연속으로 접속한 유저의 비율을 구하는 문제이다.</p>
<h3 id="382-solution">3.8.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">ROUND</span><span class="p">(</span><span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">player_id</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">player_id</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Activity</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="k">AS</span> <span class="n">fraction</span>
<span class="k">FROM</span>
  <span class="n">Activity</span>
<span class="k">WHERE</span>
  <span class="p">(</span><span class="n">player_id</span><span class="p">,</span> <span class="n">DATE_SUB</span><span class="p">(</span><span class="n">event_date</span><span class="p">,</span> <span class="n">INTERVAL</span> <span class="mi">1</span> <span class="k">DAY</span><span class="p">))</span>
  <span class="k">IN</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">player_id</span><span class="p">,</span> <span class="k">MIN</span><span class="p">(</span><span class="n">event_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">first_login</span> <span class="k">FROM</span> <span class="n">Activity</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">player_id</span>
  <span class="p">)</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  이 문제는 사실 못 풀었다. 그래서 다름 사람들은 어떻게 풀었는지 Solution을 보면서 공부했다. 위 SQL Query는 앞선 문제와 유사한 WHERE () IN () 절을 사용했다. 풀어보면, 각 event_date - 1일자와 첫 event_date(Min으로 구함)가 같은 Record만을 가져오는 것이다. 그렇다면 이틀 연속으로 접속한 유저 수를 구할 수 있고(<code class="language-plaintext highlighter-rouge">Count(Distinct player_id)</code>), subquery를 활용해 전체 유저 수(<code class="language-plaintext highlighter-rouge">SELECT Count(Distinct player_id) FROM Activity</code>)를 구하여 나눠주는 방식이다. <br /><br /></p>

<p>  또 다른 방식으로는 다음과 같은 Solution이 있었다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> 
    <span class="n">player_id</span><span class="p">,</span> 
    <span class="n">DATE_SUB</span><span class="p">(</span><span class="n">event_date</span><span class="p">,</span> <span class="n">INTERVAL</span> <span class="mi">1</span> <span class="k">DAY</span><span class="p">)</span><span class="o">=</span><span class="k">min</span><span class="p">(</span><span class="n">event_date</span><span class="p">)</span> <span class="n">over</span><span class="p">(</span><span class="k">partition</span> <span class="k">by</span> <span class="n">player_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">is_return</span> 
<span class="k">FROM</span>
    <span class="n">activity</span>
</code></pre></div></div>
<p>  전체 쿼리는 아니고 is_return을 구하는 쿼리인데, 이튿날 접속한 유저를 구하는 쿼리이다. <code class="language-plaintext highlighter-rouge">Over(partition by *)</code>구문은 * 별로 집계를 수행할 때 쓰는 구문이다. <code class="language-plaintext highlighter-rouge">GROUP BY</code>절과 유사하면서도 차이점이 있는데, 1. 집계된 값을 반환하면서 동시에 기존 행 값도 함께 볼 수 있으며, ```Over()``절과 함께 Window함수와 함께 사용할 수 있다. 이 부분도 따로 정리해야겠다.<br />
  위 구문을 보면, player_id 별로 event_date - 1일자가 min(event_date)와 같으면 1 다르면 0을 반환해 이틀 연속으로 접속한 유저를 구분할 수 있게끔 한 구문이라고 해석하면 될 것 같다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[  안녕하세요. 이번 포스트부터는 LeetCode50 Aggregate Functions 두번째 파트 이어 가겠습니다.]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이: Basic Aggregate Functions(1/2)</title><link href="http://localhost:4000/data/SQL_LeetCode4/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이: Basic Aggregate Functions(1/2)" /><published>2023-07-20T00:00:00+09:00</published><updated>2023-07-21T07:08:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode4</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode4/"><![CDATA[<p>  안녕하세요. 이번 포스트부터는 LeetCode50 Aggregate Functions 이어 가겠습니다. 문제를 풀어보다가 중간중간 막히는 부분이 많았던 구간인 것 같습니다.😂</p>

<h1 id="집계-함수aggregate-funstion란">집계 함수(Aggregate Funstion)란?</h1>
<p>  집계 함수란 <strong>테이블 전체 혹은 여러 행으로부터 하나의 결과값을 반환하는 함수</strong>입니다. 예를 들어, Avg, Sum, Max, Min, Count 등 함수가 집계 함수이며, GROUP BY 절과 함께 사용됩니다.</p>

<h1 id="3-basic-aggregate-functions">3. Basic Aggregate Functions</h1>
<h2 id="31-not-boring-movies">3.1 Not Boring Movies</h2>
<h3 id="311-table-description--question">3.1.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Cinema</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>movie</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>description</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>rating</td>
      <td>float</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Each row contains information about the name of a movie, its genre, and its rating.<br />
rating is a 2 decimal places float in the range [0, 10]</p>
</blockquote>

<p><strong>Question</strong><br /></p>
<ul>
  <li>Write an SQL query to report the movies with an odd-numbered ID and a description that is not “boring”.</li>
  <li>Return the result table ordered by rating in descending order..<br /></li>
</ul>

<h3 id="312-solution">3.1.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">id</span><span class="p">,</span>
    <span class="n">movie</span><span class="p">,</span>
    <span class="n">description</span><span class="p">,</span>
    <span class="n">rating</span>
<span class="k">FROM</span> 
    <span class="n">Cinema</span>
<span class="k">Where</span>
    <span class="n">description</span> <span class="o">!=</span> <span class="s1">'boring'</span> <span class="k">and</span>
    <span class="n">id</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="c1">-- or mod(id, 2) &lt;&gt; 0</span>
<span class="k">Order</span> <span class="k">By</span>
    <span class="n">rating</span> <span class="k">desc</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  간단한 문제이다. 지루하지 않은 영화를 필터링하기 위하여 <code class="language-plaintext highlighter-rouge">description != 'boring'</code> 조건절을 추가한 다음, 홀수인 id를 추출하기 위한 조건절을 추가하면 된다.<br />
  홀수인 id를 고르기 위해서는 id(int)를 2로 나눴을 때 나머지가 0인지 1인지 체크하면 된다.<br /></p>

<h3 id="313-good-to-know">3.1.3 Good to Know</h3>
<p>  나머지를 구하는 방법은 여러가지가 있다. 우선 ‘%’ 연산자도 나머지를 반환하는 연산자인데 위 풀이에서 <code class="language-plaintext highlighter-rouge">id % 2</code>는 id를 2로 나눈 나머지를 반환한다. mod(a,b)함수도 나머지를 반환하는 함수이며 a를 b로 나눈 나머지를 반환한다.</p>

<h2 id="32-average-selling-price">3.2 Average Selling Price</h2>
<h3 id="321-table-description--question">3.2.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Prices</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>product_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>start_date(PK)</td>
      <td>date</td>
    </tr>
    <tr>
      <td>end_date(PK)</td>
      <td>date</td>
    </tr>
    <tr>
      <td>price</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Each row of this table indicates the price of the product_id in the period from start_date to end_date.<br />
For each product_id there will be no two overlapping periods. That means there will be no two intersecting periods for the same product_id.<br /></p>
</blockquote>

<p>table: UnitsSold</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>product_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>purchase_date</td>
      <td>date</td>
    </tr>
    <tr>
      <td>units</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>There is no primary key for this table, it may contain duplicates.<br />
Each row of this table indicates the date, units, and product_id of each product sold.</p>
</blockquote>

<p><strong>Question</strong><br />
Write an SQL query to find the average selling price for each product. average_price should be rounded to 2 decimal places.<br />
Return the result table in any order.</p>

<h3 id="322-solution">3.2.2 Solution</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">product_id</span>    <span class="k">As</span> <span class="n">product_id</span><span class="p">,</span>
    <span class="n">round</span><span class="p">(</span><span class="k">sum</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">price</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">units</span><span class="p">)</span> <span class="o">/</span> <span class="k">sum</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">units</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>         <span class="k">as</span> <span class="n">average_price</span>
<span class="k">From</span>
    <span class="n">Prices</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span>
    <span class="n">UnitsSold</span> <span class="n">b</span>
    <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">product_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">product_id</span> <span class="k">and</span> <span class="n">a</span><span class="p">.</span><span class="n">start_date</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">.</span><span class="n">purchase_date</span> <span class="k">and</span> <span class="n">a</span><span class="p">.</span><span class="n">end_date</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">.</span><span class="n">purchase_date</span>
<span class="k">GROUP</span> <span class="k">BY</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">product_id</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  관건은 UnitsSold 테이블의 purchase_date가 Prices 테이블의 start_date와 end_date사이에 오도록 하는 것이다. 어떻게 하면 될까 고민해보다가 JOIN절의 On절에서 처리해보자 생각해보고 무작정해봤다. 그런데 Join이 잘 되길래 문제를 수월하게 풀 수 있었다. <br />
  기존에 쓰던 툴은 이렇게 특정 Column이 어떤 기간 내에 오도록 Join하는 경우 제공하는 기능이 있었다. WildMatch라는 함수가 제공되어서 Key와 start인수, end인수를 입력하면 자동으로 매칭해줬다. 그래서 SQL도 유사한 함수가 있나 찾아봤는데 제공하는 함수는 없길래 다른 방법을 생각해봤고 적용했다.</p>

<h3 id="323-improve">3.2.3 Improve</h3>
<p>  무작정 적은 코드라 맞는지 틀린지 알 수가 없어 문제를 풀어보고나면 다른 사람들의 풀이를 참조해보곤 하는데 좋은 코드가 있었다!</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 내가 작성한 쿼리문</span>
<span class="k">Left</span> <span class="k">Join</span>
    <span class="n">UnitsSold</span> <span class="n">b</span>
    <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">product_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">product_id</span> <span class="k">and</span> <span class="n">a</span><span class="p">.</span><span class="n">start_date</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">.</span><span class="n">purchase_date</span> <span class="k">and</span> <span class="n">a</span><span class="p">.</span><span class="n">end_date</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">.</span><span class="n">purchase_date</span>
<span class="c1">-- 다름 사람들의 solution 참조해서 개선</span>
<span class="k">Left</span> <span class="k">Join</span>
    <span class="n">UnitsSold</span> <span class="n">b</span>
    <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">product_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">product_id</span> <span class="k">and</span>  <span class="n">b</span><span class="p">.</span><span class="n">purchase_date</span> <span class="k">Between</span> <span class="n">a</span><span class="p">.</span><span class="n">start_date</span> <span class="k">and</span> <span class="n">a</span><span class="p">.</span><span class="n">end_date</span>
</code></pre></div></div>
<p>  Between구문이 있는지 몰랐었다. 속도가 뭐가 빠른지는 대용량 데이터를 테스트 해보지 않아서 잘 모르겠다. 다만, 아래 코드가 직관적으로 읽기 수월하다고 생각한다.</p>

<h2 id="33-project-employees-i">3.3 Project Employees I</h2>
<h3 id="331-table-description--question">3.3.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Project</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>project_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>employee_id(PK)</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>employee_id is a foreign key to Employee table.<br />
Each row of this table indicates that the employee with employee_id is working on the project with project_id.</p>
</blockquote>

<p>table: Employee</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>employee_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>name</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>experience_years</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>employee_id is the primary key of this table. It’s guaranteed that experience_years is not NULL.<br />
Each row of this table contains information about one employee.</p>
</blockquote>

<p><strong>Question</strong> <br />
Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.<br />
Return the result table ordered by student_id and subject_name.</p>

<h3 id="332-solution">3.3.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">project_id</span>                          <span class="k">as</span> <span class="n">project_id</span><span class="p">,</span>
    <span class="n">round</span><span class="p">(</span><span class="k">Avg</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">experience_years</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>     <span class="k">as</span> <span class="n">average_years</span>
<span class="k">FROM</span>
    <span class="n">Project</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span>
    <span class="n">Employee</span> <span class="n">b</span>
    <span class="k">On</span> <span class="n">a</span><span class="p">.</span><span class="n">employee_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">employee_id</span>
<span class="k">Group</span> <span class="k">By</span>
    <span class="n">a</span><span class="p">.</span><span class="n">project_id</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  기본적인 문제로 어려운 문제는 아니라 생각한다.</p>

<h2 id="34-percentage-of-users-attended-a-contest">3.4 Percentage of Users Attended a Contest</h2>
<h3 id="341-table-descriptoin--question">3.4.1 Table descriptoin &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Users</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>user_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>user_name</td>
      <td>varchar</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Each row of this table contains the name and the id of a user.</p>
</blockquote>

<p>table: Register</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>contest_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>user_id(PK)</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Each row of this table contains the id of a user and the contest they registered into.</p>
</blockquote>

<p><strong>Question</strong> <br />
Write an SQL query to find the percentage of the users registered in each contest rounded to two decimals.<br />
Return the result table ordered by percentage in descending order. In case of a tie, order it by contest_id in ascending order.</p>

<h3 id="342-solution">3.4.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">contest_id</span>                                <span class="k">as</span> <span class="n">contest_id</span><span class="p">,</span>
    <span class="n">Round</span><span class="p">(</span><span class="k">Count</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">contest_id</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">count</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span> <span class="k">From</span> <span class="n">Users</span> <span class="n">b</span> <span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>     <span class="k">as</span> <span class="n">percentage</span>
<span class="k">FROM</span>
    <span class="n">Register</span> <span class="n">a</span>
<span class="k">Group</span> <span class="k">by</span>
    <span class="n">a</span><span class="p">.</span><span class="n">contest_id</span>
<span class="k">Order</span> <span class="k">by</span>
    <span class="n">percentage</span> <span class="k">desc</span><span class="p">,</span> <span class="n">contest_id</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  이 문제는 쉽지 않았고 고민을 많이 했었다. 각 contest별로 참석율을 구하기 위해서는 총 user_id 수를 구한다음 나눠줘야 했다. 방법은 위 SQL코드처럼 subquery를 활용하는 방법이다. SELECT 절에서 사용됐고 단일 상수값을 반환하는 Subquery이다. Subquery는 아직은 생소해서 날잡고 한 번 정리해야 할 것 같다.</p>

<!-- ### 3.4.3 Good to Know
&#160; 우선 첫번째 방법은 위 SQL코드처럼 subquery를 활용하는 방법이다. SELECT 절에서 사용됐고 단일 상수값을 반환하는 Subquery이다. Subquery는 아직은 생소해서 날잡고 한 번 정리해야 할 것 같다.<br>
&#160; 두번째 방법은 해당 값을 변수로 선언하여 활용하는 방법이다. 
```sql
DECLARE @user int = (select count(*) from Users)

SELECT
    a.contest_id, round((count(r.user_id) * 1) / @user * 100, 2)    as percentage
FROM 
    Register a
GROUP BY a.contest_id 
ORDER BY  percentage Desc,  a.contest_id Asc
```
변수를 선언해서 활용하는 SQL 구문을 짜는 것도 꽤 깔끔해보인다. -->]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[  안녕하세요. 이번 포스트부터는 LeetCode50 Aggregate Functions 이어 가겠습니다. 문제를 풀어보다가 중간중간 막히는 부분이 많았던 구간인 것 같습니다.😂]]></summary></entry><entry><title type="html">[데이터분석] 4개 인자를 한 산점도에 나타내기</title><link href="http://localhost:4000/data/data_analysis1/" rel="alternate" type="text/html" title="[데이터분석] 4개 인자를 한 산점도에 나타내기" /><published>2023-07-16T00:00:00+09:00</published><updated>2023-07-17T08:52:00+09:00</updated><id>http://localhost:4000/data/data_analysis1</id><content type="html" xml:base="http://localhost:4000/data/data_analysis1/"><![CDATA[<p>  4개 인자를 한 산점도 차트에 표현하는 미션이 주어졌습니다. 4개 인자를 한 산점도에..?? 왜 4개의 인자를 한 산점도로 표현해야했는지 그리고 어떻게 해결했는지 기록하고자 합니다.</p>

<h2 id="1-배경">1. 배경</h2>
<p>  데이터 분석을 통한 에너지 사용 절감 프로젝트의 일환으로 에너지 사용량을 모니터링 할 수 있는 대시보드 화면을 개발하던 중, 팀장님께서 현재 에너지 사용량이 적정한 수준으로 사용되고 있는지 확인할 수 있는 시각화 차트를 만들어보라고 하셨다. 데이터 분석을 통해 에너지 사용에 영향을 미치는 중요한 3가지 인자를 도출했고, 이를 기반으로 어떻게 하면 클라이언트가 쉽게 볼 수 있는 시각화 차트를 구성할 수 있을지 고민해봤습니다. 우선, 어떤 차트를 통해 표현할 지를 정해야 했는데 인자 간 관계를 볼 때 기본적으로 사용하는 산점도를 활용해 표현해보고자 했습니다.</p>
<blockquote>
  <p>※ BI Tool로 Qlik Sense를 활용하는데 3차원 산점도는 제공하고 있지 않아 주로 2차원 산점도를 활용해 대시보드를 개발하고 있습니다. ?3차원 산점도 Extension을 찾아볼까?</p>
</blockquote>

<h2 id="2-문제점">2. 문제점</h2>
<p>  다만 1개의 Y인자와 3개의 X인자 즉 4개의 인자를 한 산점도에 표현해야 하는 문제점이 있었습니다. 산점도는 보통 Y축과 X축 그리고 Z축(색으로 표시)을 활용하여 3개 인자 간 관계를 표현하기엔 적합하지만 4개 인자를 한번에 표현하기에는 한계가 있었습니다. 측정값을 활용해 Point의 크기를 조절하여 하나의 차원을 더 추가할 수 있지만, 가시성이 많이 떨어지는 문제가 있었습니다. 어떻게 해결할 수 있을지 이런 저런 방법을 고민했었고, 몇 가지 떠올렸던 아이디어는 다음과 같습니다.</p>

<h3 id="21-대안1-매개변수-활용해보기">2.1 대안1: 매개변수 활용해보기</h3>
<p>  Y축은 에너지 사용량으로 고정한 채, X축과 Z축을 매개 변수를 활용해 원하는 인자를 선택하여 산점도를 그릴 수 있게끔 해봤습니다. 장점은 사용자가 매개 변수를 활용해 원하는 대로 인자를 클릭하면서 데이터를 볼 수 있지만, 4개 인자를 한 번에 표현하지 못하는 것은 여전했습니다. 이는 사용자가 인자를 클릭해가면서 머릿속에 상상해가면서 비교하거나, 따로 캡쳐를 떠가면서 비교해야 하기에 활용도가 많이 떨어지는 아쉬움이 있습니다.</p>

<h3 id="22-대안2-여러-산점도를-그리기">2.2 대안2: 여러 산점도를 그리기</h3>
<p>  대시보드를 만들 때, 굳이 하나의 산점도만 그려야 한다는 법은 없습니다. 그래서 여러 개의 산점도를 한 화면에 그려보면 어떨까 생각했습니다. 그려보고 나니 여러개의 산점도를 통해 정보를 얻을 수 있지만, 여전히 4개의 인자를 한 산점도에서 확인하지 못하는 한계가 있었습니다. 또 하나의 문제는 차트가 많아지는 것은 사용자가 받아들여야 하는 정보가 그 만큼 증가한다는 것이고 복잡해지기 때문에 사용 편의성도 떨어지게 됩니다.</p>

<h2 id="3-해결책">3. 해결책!</h2>
<p>  이런저런 고민을 해봤지만 해결이 잘 안되던 차에 팀장님과 회의를 하면서 한 가지 기발한 아이디어를 주셨습니다. 기본 아이디어는 <span style="color:red"><strong>인자의 개수를 4개 → 3개로 줄이는 것</strong></span>이었습니다. 왜 생각을 못했던 걸까요? 듣고 나니 명쾌하고 심플했습니다. 인자의 개수를 줄이면 2차원 산점도로도 충분히 표현이 가능합니다. 그렇다면 어떻게 줄일 수 있었을까요?</p>

<h3 id="31-x1인자-영향력-없애기">3.1 X1인자 영향력 없애기</h3>
<p>  3가지 X인자를 각각 X1, X2, X3인자라고 하겠습니다. X3인자는 외기 온도이며, 외생적으로 주어지는 변수입니다. 이제 나머지 X1인자와 X2인자에 대해서 쉽게 예를 들어보겠습니다. 우리가 맛있는 라면을 끓이기 위해서는 냄비에 물과 라면을 각각 넣어줘야 합니다. 라면을 많이 넣을수록 물도 많이 넣어야하고 물이 많아질수록 GAS 사용량도 늘어나겠죠?(비유가 찰떡이네요🤣) 여기서 X1인자를 라면 양, X2인자를 물 투입량, Y인자를 GAS사용량이라고 해보겠습니다. 에너지 사용 관점에서 이렇게 표현해보면 어떨까요? <strong>&lt;라면 1g당 물 투입량, 라면 1g당 GAS 사용량&gt;</strong> 자연스럽게 3개 인자를 2개 인자로 줄일 수 있게 됐습니다! 또한 라면 양에 따라 에너지 사용량에 미치는 영향까지 제거하여 비교할 수 있게 됐습니다. 간단하지만 왜 생각을 못했었는지..ㅎㅎㅎ<br /><br />
  사실 어떤 한 인자를 나눠줌으로써 효과를 제거하는 방법이 새로운 방법은 아니고 많이 쓰이는 방법입니다. 심지어 제가 석사과정 중에 응용미시계량, 계량을 전공하면서 정말 많이 썼던 방법이었습니다. 까먹고 있었을 뿐… 예를 들면 경제학에서는 인구수에 따른 효과를 제거하기 위해 2가지 방법을 사용하는데, 하나는 X변수로 회귀식에 추가하거나 다른 하나는 Y인자를 인구수로 나눠서 1인당 Y값으로 변환해 인구수에 따른 효과를 제거하는 방법을 사용합니다. 아무래도 도메인 영역이 다르다보니 지레 단정짓고 다양한 시도를 해보지 못했던 것 같습니다. 긍정적이라면 앞으로는 이 방법을 활용할 수 있겠죠?ㅎㅎ</p>

<h2 id="마치며">마치며</h2>
<p>  비록 까먹고 있던 스킬이지만 이번 프로젝트를 통해 다시 한 번 복기할 수 있었습니다. 4개 인자를 한 산점도에 어떻게 표시하지? 이 포인트에 너무 매몰되어 있었던 것 같습니다. 이렇게 데이터를 시각적으로 표현하는 방법은 너무나 다양하고 정답이 없기에 이렇게 경험을 쌓아가면서 내실을 다져가야겠습니다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="Data Analysis" /><category term="Visualization" /><category term="Scatter Plot" /><summary type="html"><![CDATA[  4개 인자를 한 산점도 차트에 표현하는 미션이 주어졌습니다. 4개 인자를 한 산점도에..?? 왜 4개의 인자를 한 산점도로 표현해야했는지 그리고 어떻게 해결했는지 기록하고자 합니다.]]></summary></entry><entry><title type="html">[회고록] 23년 7월 3주차: 커뮤니케이션</title><link href="http://localhost:4000/data/weekly_memoir_8/" rel="alternate" type="text/html" title="[회고록] 23년 7월 3주차: 커뮤니케이션" /><published>2023-07-15T00:00:00+09:00</published><updated>2023-07-17T08:52:00+09:00</updated><id>http://localhost:4000/data/weekly_memoir_8</id><content type="html" xml:base="http://localhost:4000/data/weekly_memoir_8/"><![CDATA[<p>  이번주는 커뮤니케이션 관련하여 2가지 이슈가 있었습니다. 한 번은 팀 회의를 하면서 서로의 커뮤니케이션을 보면서 느꼈던 점과 다른 한 번은 클라이언트와 화상회의를 하면서 느꼈던 점들을 기록해보고자 합니다. 테마를 정해보자면 다음과 같이 정리할 수 있을 것 같습니다.</p>
<blockquote>
  <ol>
    <li>효율적인 커뮤니케이션</li>
    <li>보수적인(&amp;방어적인) 클라이언트 설득하기</li>
  </ol>
</blockquote>

<h2 id="1-효율적인-커뮤니케이션">1. 효율적인 커뮤니케이션</h2>
<p>  업무에 있어서 효율적인 커뮤니케이션이란 무엇일까요? <br />
⇨ <strong>원하는 바 혹은 현 상황을 명확하게 정리해서 빠르게 상대방이 이해할 수 있도록 전달하는 것</strong>이라고 생각합니다. <br /><br /></p>

<p>  업무에 있어서 상호간에 효율적인 커뮤니케이션은 매우 중요합니다. 프로젝트 방향에 대해 명확한 의사결정을 내리거나 문제를 제대로 풀어내는 과정에서 서로 오해를 없애고, 시간 낭비를 줄이기 위해서는 효율적인 커뮤니케이션이 필요합니다. 효율적인 커뮤니케이션의 중요성에 대해서는 많은 분들이 동의하실 거라 생각합니다. 다만, 효율적인 커뮤니케이션이 잘 될 때도 있지만 안되는 경우도 종종 있습니다. 왜 효율적인 커뮤니케이션이 어렵고, 어떻게 하면 좋을지에 대한 스스로의 고민을 적어보고자 합니다. <br /><br /></p>

<h3 id="11-왜-어려울까">1.1 왜 어려울까?</h3>
<blockquote>
  <p>※ 지극히 개인적인 경험에 의한 고찰입니다. 특히 주니어의 입장으로 겪은 경험들입니다.</p>
</blockquote>

<p>  일을 처음 시작하면서 어려웠던 점 중에 하나가 <span style="color:red"><strong>내가 해야할 말과 하고싶은 말을 구분하는 것</strong></span>이었습니다. 실무자들은 자신이 맡은 실무와 관련된 사항들을 일일이 나열하면서 커뮤니케이션 하는 경우가 왕왕 있습니다. 하지만, 중요한 것은 관리자나 의사결정권자들에게 디테일한 부분은 부차적인 것이라는 점입니다. 당장 의사결정에 필요한 핵심 정보, 근거가 필요합니다. 그렇기에 같은 장소에 있지만 서로 다른 얘기를 하면서 커뮤니케이션은 정체되고 서로를 탓하게 되는 경우가 생기는 것 같습니다.<br /><br />
  그 다음으로는 본인이 <strong>해당 사항에 대해 완벽하게 숙지하지 못할 때</strong> 커뮤니케이션이 제대로 이루어지지 않았습니다. 저도 어떤 사항에 대해 잘 숙지하고 있다고 생각했음에도 막상 누군가 물어봐서 말로 대답을 할 때, 대답을 제대로 하지 못한 경우가 있습니다. 이는 사실 애매하게 알고 있던 것이었습니다. 제대로 알지 못하기에 제대로 답하지 못하고 둘러대기 시작합니다. 그렇게 되면 이 커뮤니케이션은 점점 꼬이게 됩니다.</p>

<h3 id="12-어떻게-해야할까">1.2 어떻게 해야할까?</h3>
<p>  우선 중요한 것은 <strong>상대방이 무엇을 원하는지 정확히 파악</strong>해야 합니다. 눈치가 빠른 사람이라면 쉽겠지만 그렇지 않은 분이라면 애매한 경우엔 무조건 되물어서 상대방의 질문의 의도를 명확히 파악해야 합니다. 질문의 의도만 명확히 파악해도 반 이상은 해결되는 것 같습니다. <br /><br />
  그 다음으로는 <strong>두괄식</strong>으로 하는게 훨씬 효율적이라 생각합니다. 해야할 말과 하고싶은 말이 상이한 경우 해야할 말을 먼저하고 그 후에 하고싶은 말을 해야합니다. 일단, 질문사항이나 요구사항에 명확한 답변을 제시하고 그에 따른 디테일은 후에 나열하면서 커뮤니케이션을 이어가는 것도 한 방법이라 생각합니다. 디테일이 먼저 나가면 커뮤니케이션이 제자리에서 빙빙 돌게 되는 경우를 보게 됩니다. <br /><br />
  아무래도 실무자 입장에서는 해당 사항에 대한 이슈 사항을 사소한 것이라도 얘기하고 싶기 마련입니다. 물론 이도 중요합니다. 숨기거나 놓치게 되면 나중에 문제가 생길 소지가 높기 때문입니다. 다만, 상대방의 궁금증을 먼저 해결한 후에 유도하여 논의를 진행시키는 것도 꽤 유용한 커뮤니케이션 스킬이라 생각합니다. <br /><br />
  마지막으로 커뮤니케이션을 하면서 횡설수설하게 되면 멈추고 본인이 현 이슈에 대해서 제대로 인지하고 있는지 돌아봐야 합니다. 그리고 정말 제대로 인지하지 못하고 있는 것이라면 인정한 후에 양해를 구하고 제대로 숙지한 다음에 진행해야 합니다. 고집부리고 억지부리면 시간만 흐르고 나중에 더 챙피할 일이 생길 수도 있습니다.</p>

<p>  저도 효율적이고 명확한 커뮤니케이션을 하기 위해 노력하고 있습니다. 하지만 종종 실수를 하고, 시행착오를 겪습니다. 실수를 줄이고자 복기하기 위하여 기록하고 곱씹어보며 노력하는 중입니다😊</p>

<h2 id="2-보수적인방어적인-클라이언트-설득하기">2. 보수적인(&amp;방어적인) 클라이언트 설득하기</h2>
<p>  우리 팀은 데이터 분석을 통한 컨설팅을 진행하기에 고객에게 기존의 업무 Process 대비 데이터에 기반한 새로운 업무 Process를 제시하는 경우가 있습니다. 데이터 기반의 업무 효율화, 의사결정 체계로의 전환으로 일종의 DT라고 볼 수 있겠습니다. 이러하다보니, 연차가 오래되고 보수적인 클라이언트의 경우 우리 팀의 제안에 대하여 굉장히 방어적인 태도를 보이는 경우가 잦습니다. 열심히 일해서 결과물을 가져갔는데 클라이언트의 반응이 “우린 이런거 필요없어요.”로 나올 때, 저도 사람인지라 허탈함이 밀려옵니다. <br /><br />
  지난 클라이언트와의 미팅에도 이러한 상황이 발생했습니다. 우리 팀은 당황했지만 결국은 팀장님이 클라이언트를 설득하는데 성공했습니다. 그 모습을 보면서 정말 배운 것이 많았고 꼭 기록해놔야 겠다고 생각했습니다.</p>

<h3 id="21-확신">2.1 확신</h3>
<p>  우리 팀은 우리가 제안하는 방향에 대해서 확신이 있었습니다. 다만, 아무래도 새로운 업무 Process이다보니 거부감이 심했습니다. 보수적인 클라이언트는 우리 팀이 제시한 내용에 대해 이해하기 어렵고 복잡하다 이렇게 까지 필요없다라고 계속 거부했습니다. 다만, 뉘앙스를 봤을 때 우리 팀이 제시한 방안이 틀린 것이 아니라 귀찮고 이해하기 어려우니 받아들이려고 하지 않는 태도로 보였습니다. 아마 팀장님은 이 부분을 캐치하고 파고드신 것 같습니다.</p>

<h3 id="22-설득">2.2 설득</h3>
<p>  우리 팀은 우리가 제시한 방안에 대해서 조금 더 쉽게 풀어서 설명을 했고, <span style="color:red"><strong>이 제안이 기존 업무 Process 대비 어떠한 장점을 갖고 있는 지</strong></span>를 설명했습니다. 우리가 잡은 Point는 다음과 같습니다.</p>
<blockquote>
  <ol>
    <li>데이터를 통한 빠른 문제 원인 파악 가능 - 효율성 제고</li>
    <li>1번을 통한 명확한 업무 지시 및 문제 해결 가능</li>
  </ol>
</blockquote>

<p>  설득을 하면서 클라이언트가 갖고 있는 오해를 풀어드렸고, 왜 이 제안이 기존에 업무 Process대비 장점이 있는지 어필했습니다. 그럼에도 불구하고 클라이언트에 태도는 완강했습니다. 하지만 팀장님은 포기하지 않고 끈질기게 설득에 들어갔습니다. 제가 봤을 때에 클라이언트가 마음을 열기 시작한 부분은 같이 차트를 보면서 데이터를 어떻게 해석해야 하는지 얘기하면서 부터였던 것 같습니다. 제 개인적인 느낌이라 아닐수도 있습니다. 다만, 지속적으로 설득하다보니 클라이언트도 우리가 제시한 논리에 공감하기 시작했고 고민하기 시작하더니 결국엔 한 번 해보겠다고 하면서 설득에 성공했습니다.</p>

<h3 id="23-뚝심">2.3 뚝심</h3>
<p>  분석 컨설팅을 하다보면 클라이언트를 설득하기 위해서 뚝심있게 밀고 나가야 할 때가 필요합니다. 클라이언트가 도메인 지식에 월등하기 때문에 보통은 클라이언트 의견에 좌지우지되기 쉽상이지만, 아니라고 생각할때는 강력하게 밀어붙여 설득이 필요합니다. 그러다 보면 부딪히는 경우도 생기지만, 논리적으로 탄탄하다면 결국엔 설득이 되는 것 같습니다(논리가 안 통하는 상대는 아직 만나본 적이 없기에 잘 모르겠습니다…). 클라이언트에게 너무 끌려다니기보단 확신을 갖고 밀어붙이는 태도도 필요하다는 것을 많이 배웠습니다.</p>

<h2 id="마치며">마치며</h2>
<p>  이번 주는 커뮤니케이션에 관한 다양한 이슈가 있었습니다. 커뮤니케이션은 분석 스킬, 실무 스킬과는 다른 의미로 매우 그리고 항상 어렵습니다. 낙담할 때도 있곤 하지만 더 나은 커뮤니케이션을 위하여 조금씩 개선시켜 나아가고자 합니다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="Memoir" /><summary type="html"><![CDATA[  이번주는 커뮤니케이션 관련하여 2가지 이슈가 있었습니다. 한 번은 팀 회의를 하면서 서로의 커뮤니케이션을 보면서 느꼈던 점과 다른 한 번은 클라이언트와 화상회의를 하면서 느꼈던 점들을 기록해보고자 합니다. 테마를 정해보자면 다음과 같이 정리할 수 있을 것 같습니다. 효율적인 커뮤니케이션 보수적인(&amp;방어적인) 클라이언트 설득하기]]></summary></entry><entry><title type="html">[회고록] 23년 7월 2주차: 분석 모델링 수행</title><link href="http://localhost:4000/data/weekly_memoir_7/" rel="alternate" type="text/html" title="[회고록] 23년 7월 2주차: 분석 모델링 수행" /><published>2023-07-05T00:00:00+09:00</published><updated>2023-07-06T07:30:00+09:00</updated><id>http://localhost:4000/data/weekly_memoir_7</id><content type="html" xml:base="http://localhost:4000/data/weekly_memoir_7/"><![CDATA[<p>  지난 2주는 에너지 사용량 증감 원인 분석하고 그 결과를 문서화 하느라 정신 없이 지나갔네요. 월간 보고회를 진행하기 위해 쳇바퀴 처럼 반복되는 매월이지만 최근 꽤나 재미있는 분석을 진행했습니다. 이번에는 분석 모델링을 통해서 Y인자의 변동을 설명하고자 하였고 흥미로운 결과가 나와서 기록하고자 합니다.</p>

<h2 id="1-배경이유">1. 배경/이유</h2>
<p>  저는 현재 공장 에너지 절감 프로젝트를 수행하고 있고, 에너지 별 문제를 진단하고 분석을 통해 절감 요소를 도출하거나 에너지 사용량 증감을 설명하는 인자들을 도출하는 작업을 하고 있습니다. 이전까지는 에너지 별 공정 매커니즘에 기반하여 후보영향인자들을 선정한 다음 인자별로 단변량 분석을 통해 문제를 풀어나갔습니다(믿기 어렵겠지만 상당 부분 단변량 분석을 통해 문제가 해결이 됩니다). 하지만, 이번에 분석한 에너지 사용량은 단변량으로 분석하기에는 한계가 있었습니다. 다양한 변수가 복학접으로 영향을 미치다보니 단변량 분석을 통해서는 명확한 관계가 드러나지 않았기 때문이었습니다. 따라서, 우리는 분석 모델링을 통해 에너지 Y인자의 변동을 잘 설명할 수 있는 X인자의 조합을 찾고 그 효과를 추정하기 위해 분석 모델링을 수행하였습니다.</p>

<h2 id="2-기준">2. 기준</h2>
<p>  다양한 인자들의 조합 중 최적의 조합을 찾기 위해서는 기준이 필요하다. 우리는 주로 <span style="color:red"><strong>설명력(R^2)</strong></span>을 기준으로 판단을 한다(예측 모형이 아니다!). 왜냐하면 우리는 Y인자의 변동을 가장 잘 설명할 수 있는 모형을 찾고자 하기 때문이다. <br />
  그 외에도 중요하게 따져봐야 할 것들이 있다. 선형 회귀식을 사용할 때에는 부호가 매커니즘과 일치하는지를 따져봐야 한다. 매커니즘과 맞지 않는 부호가 나올 경우, 클라이언트를 설득할 수 없다. 이 때에는 누락변수가 있는 것은 아닌지 이유를 살펴보고 보완을 해야 한다. <br />
   또 중요한 점은 클라이언트가 납득할 수 있어야 한다. 흔히 도메인 지식이 약한 분석가 혹은 조직이 하는 실수가 수 많은 변수들을 떄려넣고 설명력 혹은 예측력이 가장 높은 모형을 클라이언트에게 제공하는 것인데, 이러한 결과를 제시할 경우 클라이언트에게 신뢰받기는 힘들 것이다. (이는 산업 분야마다 다르다. 하지만 분야를 막론하더라도 컨설팅을 수행하는 조직이라면 이 점을 반드시 유의해야 한다.)<br />
  따라서 내 기준을 아래와 같이 정했다.</p>
<blockquote>
  <p><strong>최우선 기준은 설명력이다. 다만, 설명력을 조금 손해보더라도 해석이 우월한 조합이 있다면 그 조합을 선택하자</strong></p>
</blockquote>

<p>  어떻게 보면 주관적이고 분석가의 의도가 들어갈 수 밖에 없다. 그렇기에 항상 결과에 대해 의심하고 신중하게 선택하여야 한다. 이런 점에서 분석가 일을 하다보면 테크니컬한 문제들은 별게 아니란 생각이 든다. 항상 이렇게 분석하고 선택하는 과정이 훨씬 더 어렵다.</p>

<h2 id="3-결과">3. 결과</h2>
<p>  설명력과 매커니즘을 기반으로 선형회귀 모형을 활용해 다양한 인자들의 조합을 탐색하였고 3가지 인자의 조합을 최종 선택하였다. 3가지 인자로 선형 회귀 모형을 Fit 했을 때, Y인자 변동의 78%를 설명하는 결과를 얻을 수 있었다. 계수들의 부호도 모두 공정 매커니즘과 일치했고, 해석에도 만족스러웠다.</p>

<h2 id="4-활용">4. 활용</h2>
<p>  우리가 분석한 결과가 어떻게 활용될까? 우리는 분석 결과에 따르면 특정 X인자 (설비효율)가 개선될 경우, 금액적 효과가 대략 xx원이 될 것이라고 클라이언트에게 리포트 했다(물론 정말 그런지는 클라이언트가 정밀하게 따져보고 검증해야 하는 과정이 필요하다). 그 수치는 클라이언트가 예상했던 금액 효과 보다 컸다. 알고보니 클라이언트 사에서는 에너지 사용 절감을 위해 설비 교체 투자 건을 진행하고자 했지만, 투자 대비 절감 효과가 낮을 것으로 예상돼 보류 중인 상황이었다. (현재 경기가 안 좋다보니 투자에 매우 민감한 상황이다.) 하지만, 분석 결과에 따르면 설비 교체로 인한 절감 효과가 매우 클 것으로 예상되기에 클라이언트사에 의사결정 사항에 영향을 줄 수 있게 됐고, 변화가 생길 수도 있을 것이다.<br />
  결국 어떤 조직이 데이터를 기반으로 의사결정 한다는 의미는 데이터 분석을 통해 객관적인 증거를 활용한다는 것이라 생각한다. 거기서 나의 역할은 더 신뢰할 수 있는 근거를 만들기 위해 엄밀한 분석을 수행하는 것이라 생각한다.</p>

<h2 id="5-흥미로운-점">5. 흥미로운 점</h2>
<p>  경제학 석사를 전공하면서 무수히 많은 회귀식을 생성했고 해석했다. 다만, 실무를 하면서 잠깐 멀어졌기에 감각(?)이 떨어졌다고 해야하나 여튼 그런 상황이었다. 단변량 분석에서 Y인자와 X인자 간의 관계가 명확하게 도출되지 않았지만, 다변량 분석 모델링을 통해 명쾌하게 해석되는 결과를 보면서 참 많은 생각이 들었다. 왜 단변량 분석에서는 잘 안보이고 다변량 분석에서는 잘 보였을까? 생각해봤을 때, 여러 인자가 복합적으로 영향을 미치기 때문이라 생각한다. 단변량 분석과 다변량 분석을 비교해보면 다음과 같을 것이다.</p>
<blockquote>
  <ul>
    <li>단변량 분석: 여러 인자들이 중요한 순서(상관성이 높은 순 혹은 매커니즘 기반 순서)대로 Y인자 변동에 영향을 끼치는 경우, 단변량 분석이 용이함<br />
  주로 상관성이 높은 X1인자를 고정한 후, Y인자의 산포를 설명하는 X2인자를 탐색하는 방법으로 분석을 수행함</li>
    <li>다변량 분석: 다양한 인자들이 Y인자에 영향을 끼치는 경우, 다변량 분석이 용이함<br />
  적합한 모델을 선정하고 모델링을 통해 분석을 수행함</li>
  </ul>
</blockquote>

<p>  또 하나 깨달은 것은 <strong>상황에 맞게 적합한 분석 방법을 적용해야 한다는 것</strong>이었다. 너무 당연한 얘기이려나? 그래도 단순히 알고 있는 것과 경험해보는 것은 다르기에 개인적으로도 아주 유익한 2주였다. 간만에 재밌었고 보람찬 분석이었다. 이런거 보면 모델링이 더 적성에 맞을지도..??ㅎㅎ</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="Memoir" /><summary type="html"><![CDATA[  지난 2주는 에너지 사용량 증감 원인 분석하고 그 결과를 문서화 하느라 정신 없이 지나갔네요. 월간 보고회를 진행하기 위해 쳇바퀴 처럼 반복되는 매월이지만 최근 꽤나 재미있는 분석을 진행했습니다. 이번에는 분석 모델링을 통해서 Y인자의 변동을 설명하고자 하였고 흥미로운 결과가 나와서 기록하고자 합니다.]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이: Basic Joins(2/2)</title><link href="http://localhost:4000/data/SQL_LeetCode3_Join2/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이: Basic Joins(2/2)" /><published>2023-07-01T00:00:00+09:00</published><updated>2023-06-30T07:07:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode3_Join2</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode3_Join2/"><![CDATA[<p>  안녕하세요. LeetCode50 Basic Join 이어 가겠습니다.</p>

<h1 id="2-basic-joins">2. Basic Joins</h1>
<h2 id="25-average-time-of-process-per-machine">2.5 Average Time of Process per Machine</h2>
<h3 id="251-table-description--question">2.5.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Activity</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>machine_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>process_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>activity_type(PK)</td>
      <td>enum</td>
    </tr>
    <tr>
      <td>timestamp</td>
      <td>float</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>The table shows the user activities for a factory website.<br />
machine_id is the ID of a machine.
process_id is the ID of a process running on the machine with ID machine_id.
activity_type is an ENUM of type (‘start’, ‘end’).
timestamp is a float representing the current time in seconds.
‘start’ means the machine starts the process at the given timestamp and ‘end’ means the machine ends the process at the given timestamp.
The ‘start’ timestamp will always be before the ‘end’ timestamp for every (machine_id, process_id) pair.<br /></p>
</blockquote>

<p><strong>Question</strong><br /></p>
<ul>
  <li>There is a factory website that has several machines each running the same number of processes. Write an SQL query to find the average time each machine takes to complete a process.<br /></li>
  <li>The time to complete a process is the ‘end’ timestamp minus the ‘start’ timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.<br /></li>
  <li>The resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places.</li>
</ul>

<p>Return the result table in any order.</p>

<h3 id="252-solution">2.5.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">machine_id</span><span class="p">,</span>
    <span class="n">Round</span><span class="p">(</span><span class="k">Avg</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="nb">timestamp</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="nb">timestamp</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>      <span class="k">As</span> <span class="n">processing_time</span>
<span class="k">FROM</span> 
    <span class="n">Activity</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span> 
    <span class="n">Activity</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">machine_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">machine_id</span> <span class="k">and</span> <span class="n">a</span><span class="p">.</span><span class="n">process_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">process_id</span>
<span class="k">Where</span>
    <span class="n">a</span><span class="p">.</span><span class="n">activity_type</span> <span class="o">=</span> <span class="s1">'start'</span> <span class="k">and</span>
    <span class="n">b</span><span class="p">.</span><span class="n">activity_type</span> <span class="o">=</span> <span class="s1">'end'</span> 
    <span class="k">and</span> <span class="n">a</span><span class="p">.</span><span class="nb">timestamp</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="nb">timestamp</span> <span class="c1">-- end timestamp가 start timestamp 보다 이후여야 한다는 제약이 필요함</span>
<span class="k">Group</span> <span class="k">by</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">machine_id</span>
</code></pre></div></div>
<p>  Self Table Join이다. 문제에서 processing time = endtime - starttime으로 정의하고 있다. 따라서, machind_id 별로 endtime과 starttime 간 차이를 구할 수 있게 두 컬럼을 붙여주면 된다. JOIN을 수행할 a 테이블은 ‘start’인 timestamp만을 가져오고, b 테이블은 ‘end’인 timestamp만을 가져와서 join을 수행하여 processing time을 구하면 된다.<br />
<br />
  문제에 보면 machine_id, process_id 별 end timestamp가 start timestamp가 이후여야 한다. 문제 풀 때는 까먹어서 SQL 구문에 넣지 않았지만, 실무에서는 매우 중요하다. 실제로는 데이터의 무결성(Data Integrity)가 지켜지지 않는 경우가 많기 때문에, 정확한 데이터를 산출하기 위해서는 위와 같은 조건을 꼭 추가하여야 한다.</p>

<h3 id="253-good-to-know">2.5.3 Good to Know</h3>
<p>Round함수는 지정한 자릿수에 따라 반올림을 수행하는 함수이다. 만약 지정한 자릿수가 ‘3’이라면 소수점 넷째 자리에서 반올림하여 셋째자리까지 표시해준다.</p>

<h2 id="26-employee-bonus">2.6 Employee Bonus</h2>
<h3 id="261-table-description--question">2.6.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Employee</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>empId(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>name</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>supervisor</td>
      <td>int</td>
    </tr>
    <tr>
      <td>salary</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>(sale_id, year) is the primary key of this table.<br />
Each row of this table indicates the name and the ID of an employee in addition to their salary and the id of their manager.<br /></p>
</blockquote>

<p>table: Bonus</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>empId(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>bonus(FK)</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>empId is a foreign key to empId from the Employee table.<br />
Each row of this table contains the id of an employee and their respective bonus.</p>
</blockquote>

<p><strong>Question</strong><br />
Write an SQL query to report the name and bonus amount of each employee with a bonus less than 1000.<br />
Return the result table in any order.</p>

<h3 id="252-solution-1">2.5.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="n">bonus</span>
<span class="k">FROM</span> 
    <span class="n">Employee</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span> 
    <span class="n">Bonus</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">empId</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">empId</span>
<span class="k">Where</span> 
    <span class="n">b</span><span class="p">.</span><span class="n">bonus</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="k">or</span> <span class="k">isnull</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">bonus</span><span class="p">)</span>
</code></pre></div></div>
<p>위 문제와 마찬가지로 간단한 Join이라 부가설명 없이 넘어가도록 한다.</p>

<h2 id="27-students-and-examinations">2.7 Students and Examinations</h2>
<h3 id="271-table-description--question">2.7.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Students</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>student_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>student_name</td>
      <td>varchar</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Each row of this table contains the ID and the name of one student in the school.</p>
</blockquote>

<p>table: Subjects</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>subject_name(PK)</td>
      <td>varchar</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Each row of this table contains the name of one subject in the school.</p>
</blockquote>

<p>table: Examinations</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>student_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>subject_name</td>
      <td>varchar</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>There is no primary key for this table. <u>It may contain duplicates.</u><br />
Each student from the Students table takes every course from the Subjects table.
Each row of this table indicates that a student with ID student_id attended the exam of subject_name.</p>
</blockquote>

<p><strong>Question</strong> <br />
Write an SQL query to find the number of times each student attended each exam.<br />
Return the result table ordered by student_id and subject_name.</p>

<h3 id="272-solution">2.7.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">student_id</span><span class="p">,</span>
    <span class="n">a</span><span class="p">.</span><span class="n">student_name</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="n">subject_name</span><span class="p">,</span>
    <span class="k">Count</span><span class="p">(</span><span class="k">c</span><span class="p">.</span><span class="n">subject_name</span><span class="p">)</span>           <span class="k">As</span> <span class="n">attended_exams</span>
<span class="k">From</span>
    <span class="n">Students</span> <span class="n">a</span>
<span class="k">Cross</span> <span class="k">Join</span> 
    <span class="n">Subjects</span> <span class="n">b</span> 
<span class="k">Left</span> <span class="k">Join</span> 
    <span class="n">Examinations</span> <span class="k">c</span> <span class="k">on</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">student_id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">student_id</span> <span class="k">and</span> <span class="n">b</span><span class="p">.</span><span class="n">subject_name</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">subject_name</span>
<span class="k">Group</span> <span class="k">By</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">student_id</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">subject_name</span>
<span class="k">Order</span> <span class="k">By</span>
     <span class="n">a</span><span class="p">.</span><span class="n">student_id</span> <span class="k">asc</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">subject_name</span> <span class="k">asc</span>
<span class="p">;</span>
</code></pre></div></div>
<p> 문제에서 요구하는 답을 얻기 위해서는 3개의 테이블을 Join해야 한다. 학생별로 수강한 과목명을 붙이고 그 과목에 시험 응시한 과목을 붙여야 한다. students 테이블의 모든 학생들은 subjects에 있는 모든 과목을 수강했다고 한다. 그렇다면 students테이블의 students_id 별로 과목명을 모두 붙여주면 된다. 이럴때 사용하는 JOIN은 <strong>OUTER JOIN</strong>이며, MySQL에선 ‘CROSS JOIN’으로 수행한다. CROSS JOIN은 각 테이블의 키별로 모든 값을 매칭하는 JOIN 방법이다. 수행 결과로 students_id 별로 모든 subjects name이 JOIN된다.<br />
<br />
  다음으로 students id 별로 시험 응시 내역을 붙여주면 된다. 기존 Cross Join을 수행한 테이블에 Examination을 Left Join 해주자. 그러면 시험을 응시했으면 값이 붙고 없으면 Null값이 붙는다. 따라서 c.subject name을 count해주면 시험 응시 횟수를 구할 수 있게 된다.(null값은 count하지 않는다.)</p>

<h3 id="273-good-to-know">2.7.3 Good to Know</h3>
<p>  실무에서 데이터 마트를 구성하다보면 대부분의 트러블은 대부분 테이블 간 JOIN에서 발생한다. 그 이유는 1) Key가 잘못(중복, 데이터 타입 상이 등)됐거나, 2) Join에 종류를 잘못설정 했거나, 3) 기타 모종의 이유… 등으로 발생한다. 특히, Key에 중복이 발생되거나, Outer Join을 잘못 수행할 경우 데이터가 뻥튀기 되면서 컴퓨팅 리소스 한계 이상으로 사용하게 되면서 서버가 맛탱이가는 일이 발생하고 서비스를 내리거나 엔진을 재시작하는 일이 발생한다. 따라서, Join은 항상 신중하게 해야 한다.</p>
<blockquote>
  <p>JOIN 수행 전 KEY가 적절한 지, 데이터 중복 여부 정도는 미리 체크하기!</p>
</blockquote>

<h2 id="28-managers-with-at-least-5-direct-reports">2.8 Managers with at Least 5 Direct Reports</h2>
<h3 id="281-table-descriptoin--question">2.8.1 Table descriptoin &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Employee</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>name</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>department</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>managerId</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Each row of this table indicates the name of an employee, their department, and the id of their manager. If managerId is null, then the employee does not have a manager. No employee will be the manager of themself.</p>
</blockquote>

<p><strong>Question</strong> <br />
Write an SQL query to report the managers with at least five direct reports.<br />
Return the result table in any order.</p>

<h3 id="282-solution">2.8.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span> 
    <span class="n">Employee</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span>
    <span class="p">(</span><span class="k">SELECT</span>
        <span class="n">managerId</span><span class="p">,</span>
        <span class="k">count</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>   <span class="k">as</span> <span class="n">n</span>
    <span class="k">FROM</span>
        <span class="n">Employee</span>
    <span class="k">Group</span> <span class="k">By</span> 
        <span class="n">managerId</span><span class="p">)</span>
    <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">managerId</span>
<span class="k">WHERE</span>
    <span class="n">b</span><span class="p">.</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">5</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  maneger id 별로 id가 몇 명인지 구한다음 값이 5 이상인 manager id를 구하면 되는 문제이다. 처음에 문제를 보고 어떻게 풀어야 할지 감이 안와서 subquery를 활용했다. 개인적으로는 Simple하게 가장 좋다고 생각하기에 굳이 subquery를 써야하는 상황이 아니면 쓰고 싶지 않았다. (현 수준 문제에서 subquery를 요구하는 거 같진 않았다.) 하지만, 다른 아이디어가 없었기에 subquery로 manager id 별로 id 수를 구한 다음 left join하여 값이 5이상인 manager를 추출하였다.<br /><br /></p>

<p><strong>Better Solution</strong><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span> 
    <span class="n">Employee</span> <span class="n">a</span>
<span class="k">INNER</span> <span class="k">JOIN</span> 
    <span class="n">Employee</span> <span class="n">b</span>
    <span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">managerId</span>
<span class="k">GROUP</span> <span class="k">BY</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">name</span>
<span class="k">HAVING</span> 
    <span class="k">COUNT</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div></div>
<p>  문제를 풀고 다른 사람의 solutions 중 개인적으로 가장 깔끔하다고 생각하여 가져왔다. 그리고 Having 절에 대해 처음 알게 됐다.(이전에는 몰랐다 ㅠㅠ)
SQL 코드도 짧아졌고 기존 코드보다 직관적으로 이해도 쉽다.</p>

<h3 id="283-good-to-know-where-vs-having">2.8.3 Good to Know: Where vs. Having</h3>
<p>  Where 절과 Having 절은 둘 다 필터링할 때 사용할 수 있다는 공통적인 기능을 제공하지만 차이가 있다. Having 절은 그룹을 필터링하는 데 쓰이며, 집계 함수를 사용하여 필터링이 가능한 반면, Where 절은 개별 행에 대한 필터링이 가능하며 집계 함수를 활용한 필터링이 불가능하다. 즉, Having은 그룹화 혹은 집계 값에 대한 레코드를 필터링하는데 사용되며, Where 절은 개별값에 대한 레코드를 필터링하는데 사용된다.<br />
<br />
<a href="https://velog.io/@ljs7463/SQL-having-%EA%B3%BC-where-%EC%B0%A8%EC%9D%B4">참조사이트</a>: Having 절에 대한 내용은 해당 블로그에서 참조하였습니다.</p>

<h2 id="29-confirmation-rate">2.9 Confirmation Rate</h2>
<h3 id="291-table-descriptoin--question">2.9.1 Table descriptoin &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Signups</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>user_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>time_stamp</td>
      <td>datetime</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Each row contains information about the signup time for the user with ID user_id.</p>
</blockquote>

<p>table: Confirmations</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>user_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>time_stamp(PK)</td>
      <td>datetime</td>
    </tr>
    <tr>
      <td>action</td>
      <td>ENUM</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>user_id is a foreign key with a reference to the Signups table.
action is an ENUM of the type (‘confirmed’, ‘timeout’)
Each row of this table indicates that the user with ID user_id requested a confirmation message at time_stamp and that confirmation message was either confirmed (‘confirmed’) or expired without confirming (‘timeout’).</p>
</blockquote>

<p><strong>Question</strong> <br />
The confirmation rate of a user is the number of ‘confirmed’ messages divided by the total number of requested confirmation messages. The confirmation rate of a user that did not request any confirmation messages is 0. Round the confirmation rate to two decimal places.<br />
Write an SQL query to find the confirmation rate of each user.<br />
Return the result table in any order.</p>

<h3 id="292-solution">2.9.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
   <span class="n">a</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span>
   <span class="n">round</span><span class="p">(</span><span class="n">Coalesce</span><span class="p">(</span><span class="k">count</span><span class="p">(</span><span class="k">case</span> <span class="k">when</span> <span class="n">b</span><span class="p">.</span><span class="n">action</span><span class="o">=</span><span class="s1">'confirmed'</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">end</span><span class="p">)</span> <span class="o">/</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
       <span class="k">as</span> <span class="n">confirmation_rate</span>
<span class="k">FROM</span>
   <span class="n">Signups</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span>
   <span class="n">Confirmations</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">Group</span> <span class="k">by</span>
   <span class="n">a</span><span class="p">.</span><span class="n">user_id</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  confirmation rate을 구하기 위해서는 confirmed 수와 total 수를 구해야 한다. 그래서 case 절을 사용해서 confirmed 수를 구했고 count(*)를 활용해 total 수를 구했다. 근데 굳이 각각 수를 더해서 나눠줄 필요없이 avg 함수를 활용해서 confirmation rate을 구할 수 있다.<br /></p>

<p><code class="language-plaintext highlighter-rouge">avg(case when c.action = 'confirmed' then 1 else 0 end)</code>, 이 방법도 깔끔하고 좋은 것 같다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[  안녕하세요. LeetCode50 Basic Join 이어 가겠습니다.]]></summary></entry></feed>