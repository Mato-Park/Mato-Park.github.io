<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-06T00:01:42+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">끊임없이 성장하는 데이터 분석가</title><subtitle>조금씩 쌓아가다 보면 큰 산이 되겠지</subtitle><author><name>박마토</name></author><entry><title type="html">[회고록] 23년 7월 2주차: 분석 모델링 수행</title><link href="http://localhost:4000/data/weekly_memoir_7/" rel="alternate" type="text/html" title="[회고록] 23년 7월 2주차: 분석 모델링 수행" /><published>2023-07-05T00:00:00+09:00</published><updated>2023-06-13T05:40:00+09:00</updated><id>http://localhost:4000/data/weekly_memoir_7</id><content type="html" xml:base="http://localhost:4000/data/weekly_memoir_7/"><![CDATA[<p>  지난 2주는 에너지 사용량 증감 원인 분석하고 그 결과를 문서화 하느라 정신 없이 지나갔네요. 월간 보고회를 진행하기 위해 쳇바퀴 처럼 반복되는 매월이지만 최근 꽤나 재미있는 분석을 진행했습니다. 이번에는 분석 모델링을 통해서 Y인자의 변동을 설명하고자 하였고 흥미로운 결과가 나와서 기록하고자 합니다.</p>

<h2 id="1-배경이유">1. 배경/이유</h2>
<p>  저는 현재 공장 에너지 절감 프로젝트를 수행하고 있고, 에너지 별 문제를 진단하고 분석을 통해 절감 요소를 도출하거나 에너지 사용량 증감을 설명하는 인자들을 도출하는 작업을 하고 있습니다. 이전까지는 에너지 별 공정 매커니즘에 기반하여 후보영향인자들을 선정한 다음 인자별로 단변량 분석을 통해 문제를 풀어나갔습니다(믿기 어렵겠지만 상당 부분 단변량 분석을 통해 문제가 해결이 됩니다). 하지만, 이번에 분석한 에너지 사용량은 단변량으로 분석하기에는 한계가 있었습니다. 다양한 변수가 복학접으로 영향을 미치다보니 단변량 분석을 통해서는 명확한 관계가 드러나지 않았기 때문이었습니다. 따라서, 우리는 분석 모델링을 통해 에너지 Y인자의 변동을 잘 설명할 수 있는 X인자의 조합을 찾고 그 효과를 추정하기 위해 분석 모델링을 수행하였습니다.</p>

<h2 id="2-기준">2. 기준</h2>
<p>  다양한 인자들의 조합 중 최적의 조합을 찾기 위해서는 기준이 필요하다. 우리는 주로 <span style="color:red"><strong>설명력(R^2)</strong></span>을 기준으로 판단을 한다(예측 모형이 아니다!). 왜냐하면 우리는 Y인자의 변동을 가장 잘 설명할 수 있는 모형을 찾고자 하기 때문이다. <br />
  그 외에도 중요하게 따져봐야 할 것들이 있다. 선형 회귀식을 사용할 때에는 부호가 매커니즘과 일치하는지를 따져봐야 한다. 매커니즘과 맞지 않는 부호가 나올 경우, 클라이언트를 설득할 수 없다. 이 때에는 누락변수가 있는 것은 아닌지 이유를 살펴보고 보완을 해야 한다. <br />
   또 중요한 점은 클라이언트가 납득할 수 있어야 한다. 흔히 도메인 지식이 약한 분석가 혹은 조직이 하는 실수가 수 많은 변수들을 떄려넣고 설명력 혹은 예측력이 가장 높은 모형을 클라이언트에게 제공하는 것인데, 이러한 결과를 제시할 경우 클라이언트에게 신뢰받기는 힘들 것이다. (이는 산업 분야마다 다르다. 하지만 분야를 막론하더라도 컨설팅을 수행하는 조직이라면 이 점을 반드시 유의해야 한다.)<br />
  따라서 내 기준을 아래와 같이 정했다.</p>
<blockquote>
  <p><strong>최우선 기준은 설명력이다. 다만, 설명력을 조금 손해보더라도 해석이 우월한 조합이 있다면 그 조합을 선택하자</strong></p>
</blockquote>

<p>  어떻게 보면 주관적이고 분석가의 의도가 들어갈 수 밖에 없다. 그렇기에 항상 결과에 대해 의심하고 신중하게 선택하여야 한다. 이런 점에서 분석가 일을 하다보면 테크니컬한 문제들은 별게 아니란 생각이 든다. 항상 이렇게 분석하고 선택하는 과정이 훨씬 더 어렵다.</p>

<h2 id="3-결과">3. 결과</h2>
<p>  설명력과 매커니즘을 기반으로 선형회귀 모형을 활용해 다양한 인자들의 조합을 탐색하였고 3가지 인자의 조합을 최종 선택하였다. 3가지 인자로 선형 회귀 모형을 Fit 했을 때, Y인자 변동의 78%를 설명하는 결과를 얻을 수 있었다. 계수들의 부호도 모두 공정 매커니즘과 일치했고, 해석에도 만족스러웠다.</p>

<h2 id="4-활용">4. 활용</h2>
<p>  우리가 분석한 결과가 어떻게 활용될까? 우리는 분석 결과에 따르면 특정 X인자 (설비효율)가 개선될 경우, 금액적 효과가 대략 xx원이 될 것이라고 클라이언트에게 리포트 했다(물론 정말 그런지는 클라이언트가 정밀하게 따져보고 검증해야 하는 과정이 필요하다). 그 수치는 클라이언트가 예상했던 금액 효과 보다 컸다. 알고보니 클라이언트 사에서는 에너지 사용 절감을 위해 설비 교체 투자 건을 진행하고자 했지만, 투자 대비 절감 효과가 낮을 것으로 예상돼 보류 중인 상황이었다. (현재 경기가 안 좋다보니 투자에 매우 민감한 상황이다.) 하지만, 분석 결과에 따르면 설비 교체로 인한 절감 효과가 매우 클 것으로 예상되기에 클라이언트사에 의사결정 사항에 영향을 줄 수 있게 됐고, 변화가 생길 수도 있을 것이다.<br />
  결국 어떤 조직이 데이터를 기반으로 의사결정 한다는 의미는 데이터 분석을 통해 객관적인 증거를 활용한다는 것이라 생각한다. 거기서 나의 역할은 더 신뢰할 수 있는 근거를 만들기 위해 엄밀한 분석을 수행하는 것이라 생각한다.</p>

<h2 id="5-흥미로운-점">5. 흥미로운 점</h2>
<p>  경제학 석사를 전공하면서 무수히 많은 회귀식을 생성했고 해석했다. 다만, 실무를 하면서 잠깐 멀어졌기에 감각(?)이 떨어졌다고 해야하나 여튼 그런 상황이었다. 단변량 분석에서 Y인자와 X인자 간의 관계가 명확하게 도출되지 않았지만, 다변량 분석 모델링을 통해 명쾌하게 해석되는 결과를 보면서 참 많은 생각이 들었다. 왜 단변량 분석에서는 잘 안보이고 다변량 분석에서는 잘 보였을까? 생각해봤을 때, 여러 인자가 복합적으로 영향을 미치기 때문이라 생각한다. 단변량 분석과 다변량 분석을 비교해보면 다음과 같을 것이다.</p>
<blockquote>
  <ul>
    <li>단변량 분석: 여러 인자들이 중요한 순서(상관성이 높은 순 혹은 매커니즘 기반 순서)대로 Y인자 변동에 영향을 끼치는 경우, 단변량 분석이 용이함<br />
  주로 상관성이 높은 X1인자를 고정한 후, Y인자의 산포를 설명하는 X2인자를 탐색하는 방법으로 분석을 수행함</li>
    <li>다변량 분석: 다양한 인자들이 Y인자에 영향을 끼치는 경우, 다변량 분석이 용이함<br />
  적합한 모델을 선정하고 모델링을 통해 분석을 수행함</li>
  </ul>
</blockquote>

<p>  또 하나 깨달은 것은 <strong>상황에 맞게 적합한 분석 방법을 적용해야 한다는 것</strong>이었다. 너무 당연한 얘기이려나? 그래도 단순히 알고 있는 것과 경험해보는 것은 다르기에 개인적으로도 아주 유익한 2주였다. 간만에 재밌었고 보람찬 분석이었다. 이런거 보면 모델링이 더 적성에 맞을지도..??ㅎㅎ</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="Memoir" /><summary type="html"><![CDATA[  지난 2주는 에너지 사용량 증감 원인 분석하고 그 결과를 문서화 하느라 정신 없이 지나갔네요. 월간 보고회를 진행하기 위해 쳇바퀴 처럼 반복되는 매월이지만 최근 꽤나 재미있는 분석을 진행했습니다. 이번에는 분석 모델링을 통해서 Y인자의 변동을 설명하고자 하였고 흥미로운 결과가 나와서 기록하고자 합니다.]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이: Basic Joins(2/2)</title><link href="http://localhost:4000/data/SQL_LeetCode3_Join2/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이: Basic Joins(2/2)" /><published>2023-07-01T00:00:00+09:00</published><updated>2023-06-30T07:07:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode3_Join2</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode3_Join2/"><![CDATA[<p>  안녕하세요. LeetCode50 Basic Join 이어 가겠습니다.</p>

<h1 id="2-basic-joins">2. Basic Joins</h1>
<h2 id="25-average-time-of-process-per-machine">2.5 Average Time of Process per Machine</h2>
<h3 id="251-table-description--question">2.5.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Activity</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>machine_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>process_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>activity_type(PK)</td>
      <td>enum</td>
    </tr>
    <tr>
      <td>timestamp</td>
      <td>float</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>The table shows the user activities for a factory website.<br />
machine_id is the ID of a machine.
process_id is the ID of a process running on the machine with ID machine_id.
activity_type is an ENUM of type (‘start’, ‘end’).
timestamp is a float representing the current time in seconds.
‘start’ means the machine starts the process at the given timestamp and ‘end’ means the machine ends the process at the given timestamp.
The ‘start’ timestamp will always be before the ‘end’ timestamp for every (machine_id, process_id) pair.<br /></p>
</blockquote>

<p><strong>Question</strong><br /></p>
<ul>
  <li>There is a factory website that has several machines each running the same number of processes. Write an SQL query to find the average time each machine takes to complete a process.<br /></li>
  <li>The time to complete a process is the ‘end’ timestamp minus the ‘start’ timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.<br /></li>
  <li>The resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places.</li>
</ul>

<p>Return the result table in any order.</p>

<h3 id="252-solution">2.5.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">machine_id</span><span class="p">,</span>
    <span class="n">Round</span><span class="p">(</span><span class="k">Avg</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="nb">timestamp</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="nb">timestamp</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>      <span class="k">As</span> <span class="n">processing_time</span>
<span class="k">FROM</span> 
    <span class="n">Activity</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span> 
    <span class="n">Activity</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">machine_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">machine_id</span> <span class="k">and</span> <span class="n">a</span><span class="p">.</span><span class="n">process_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">process_id</span>
<span class="k">Where</span>
    <span class="n">a</span><span class="p">.</span><span class="n">activity_type</span> <span class="o">=</span> <span class="s1">'start'</span> <span class="k">and</span>
    <span class="n">b</span><span class="p">.</span><span class="n">activity_type</span> <span class="o">=</span> <span class="s1">'end'</span> 
    <span class="k">and</span> <span class="n">a</span><span class="p">.</span><span class="nb">timestamp</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="nb">timestamp</span> <span class="c1">-- end timestamp가 start timestamp 보다 이후여야 한다는 제약이 필요함</span>
<span class="k">Group</span> <span class="k">by</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">machine_id</span>
</code></pre></div></div>
<p>  Self Table Join이다. 문제에서 processing time = endtime - starttime으로 정의하고 있다. 따라서, machind_id 별로 endtime과 starttime 간 차이를 구할 수 있게 두 컬럼을 붙여주면 된다. JOIN을 수행할 a 테이블은 ‘start’인 timestamp만을 가져오고, b 테이블은 ‘end’인 timestamp만을 가져와서 join을 수행하여 processing time을 구하면 된다.<br />
<br />
  문제에 보면 machine_id, process_id 별 end timestamp가 start timestamp가 이후여야 한다. 문제 풀 때는 까먹어서 SQL 구문에 넣지 않았지만, 실무에서는 매우 중요하다. 실제로는 데이터의 무결성(Data Integrity)가 지켜지지 않는 경우가 많기 때문에, 정확한 데이터를 산출하기 위해서는 위와 같은 조건을 꼭 추가하여야 한다.</p>

<h3 id="253-good-to-know">2.5.3 Good to Know</h3>
<p>Round함수는 지정한 자릿수에 따라 반올림을 수행하는 함수이다. 만약 지정한 자릿수가 ‘3’이라면 소수점 넷째 자리에서 반올림하여 셋째자리까지 표시해준다.</p>

<h2 id="26-employee-bonus">2.6 Employee Bonus</h2>
<h3 id="261-table-description--question">2.6.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Employee</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>empId(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>name</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>supervisor</td>
      <td>int</td>
    </tr>
    <tr>
      <td>salary</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>(sale_id, year) is the primary key of this table.<br />
Each row of this table indicates the name and the ID of an employee in addition to their salary and the id of their manager.<br /></p>
</blockquote>

<p>table: Bonus</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>empId(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>bonus(FK)</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>empId is a foreign key to empId from the Employee table.<br />
Each row of this table contains the id of an employee and their respective bonus.</p>
</blockquote>

<p><strong>Question</strong><br />
Write an SQL query to report the name and bonus amount of each employee with a bonus less than 1000.<br />
Return the result table in any order.</p>

<h3 id="252-solution-1">2.5.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="n">bonus</span>
<span class="k">FROM</span> 
    <span class="n">Employee</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span> 
    <span class="n">Bonus</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">empId</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">empId</span>
<span class="k">Where</span> 
    <span class="n">b</span><span class="p">.</span><span class="n">bonus</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="k">or</span> <span class="k">isnull</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">bonus</span><span class="p">)</span>
</code></pre></div></div>
<p>위 문제와 마찬가지로 간단한 Join이라 부가설명 없이 넘어가도록 한다.</p>

<h2 id="27-students-and-examinations">2.7 Students and Examinations</h2>
<h3 id="271-table-description--question">2.7.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Students</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>student_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>student_name</td>
      <td>varchar</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Each row of this table contains the ID and the name of one student in the school.</p>
</blockquote>

<p>table: Subjects</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>subject_name(PK)</td>
      <td>varchar</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Each row of this table contains the name of one subject in the school.</p>
</blockquote>

<p>table: Examinations</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>student_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>subject_name</td>
      <td>varchar</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>There is no primary key for this table. <u>It may contain duplicates.</u><br />
Each student from the Students table takes every course from the Subjects table.
Each row of this table indicates that a student with ID student_id attended the exam of subject_name.</p>
</blockquote>

<p><strong>Question</strong> <br />
Write an SQL query to find the number of times each student attended each exam.<br />
Return the result table ordered by student_id and subject_name.</p>

<h3 id="272-solution">2.7.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">student_id</span><span class="p">,</span>
    <span class="n">a</span><span class="p">.</span><span class="n">student_name</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="n">subject_name</span><span class="p">,</span>
    <span class="k">Count</span><span class="p">(</span><span class="k">c</span><span class="p">.</span><span class="n">subject_name</span><span class="p">)</span>           <span class="k">As</span> <span class="n">attended_exams</span>
<span class="k">From</span>
    <span class="n">Students</span> <span class="n">a</span>
<span class="k">Cross</span> <span class="k">Join</span> 
    <span class="n">Subjects</span> <span class="n">b</span> 
<span class="k">Left</span> <span class="k">Join</span> 
    <span class="n">Examinations</span> <span class="k">c</span> <span class="k">on</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">student_id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">student_id</span> <span class="k">and</span> <span class="n">b</span><span class="p">.</span><span class="n">subject_name</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">subject_name</span>
<span class="k">Group</span> <span class="k">By</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">student_id</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">subject_name</span>
<span class="k">Order</span> <span class="k">By</span>
     <span class="n">a</span><span class="p">.</span><span class="n">student_id</span> <span class="k">asc</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">subject_name</span> <span class="k">asc</span>
<span class="p">;</span>
</code></pre></div></div>
<p> 문제에서 요구하는 답을 얻기 위해서는 3개의 테이블을 Join해야 한다. 학생별로 수강한 과목명을 붙이고 그 과목에 시험 응시한 과목을 붙여야 한다. students 테이블의 모든 학생들은 subjects에 있는 모든 과목을 수강했다고 한다. 그렇다면 students테이블의 students_id 별로 과목명을 모두 붙여주면 된다. 이럴때 사용하는 JOIN은 <strong>OUTER JOIN</strong>이며, MySQL에선 ‘CROSS JOIN’으로 수행한다. CROSS JOIN은 각 테이블의 키별로 모든 값을 매칭하는 JOIN 방법이다. 수행 결과로 students_id 별로 모든 subjects name이 JOIN된다.<br />
<br />
  다음으로 students id 별로 시험 응시 내역을 붙여주면 된다. 기존 Cross Join을 수행한 테이블에 Examination을 Left Join 해주자. 그러면 시험을 응시했으면 값이 붙고 없으면 Null값이 붙는다. 따라서 c.subject name을 count해주면 시험 응시 횟수를 구할 수 있게 된다.(null값은 count하지 않는다.)</p>

<h3 id="273-good-to-know">2.7.3 Good to Know</h3>
<p>  실무에서 데이터 마트를 구성하다보면 대부분의 트러블은 대부분 테이블 간 JOIN에서 발생한다. 그 이유는 1) Key가 잘못(중복, 데이터 타입 상이 등)됐거나, 2) Join에 종류를 잘못설정 했거나, 3) 기타 모종의 이유… 등으로 발생한다. 특히, Key에 중복이 발생되거나, Outer Join을 잘못 수행할 경우 데이터가 뻥튀기 되면서 컴퓨팅 리소스 한계 이상으로 사용하게 되면서 서버가 맛탱이가는 일이 발생하고 서비스를 내리거나 엔진을 재시작하는 일이 발생한다. 따라서, Join은 항상 신중하게 해야 한다.</p>
<blockquote>
  <p>JOIN 수행 전 KEY가 적절한 지, 데이터 중복 여부 정도는 미리 체크하기!</p>
</blockquote>

<h2 id="28-managers-with-at-least-5-direct-reports">2.8 Managers with at Least 5 Direct Reports</h2>
<h3 id="281-table-descriptoin--question">2.8.1 Table descriptoin &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Employee</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>name</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>department</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>managerId</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Each row of this table indicates the name of an employee, their department, and the id of their manager. If managerId is null, then the employee does not have a manager. No employee will be the manager of themself.</p>
</blockquote>

<p><strong>Question</strong> <br />
Write an SQL query to report the managers with at least five direct reports.<br />
Return the result table in any order.</p>

<h3 id="282-solution">2.8.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span> 
    <span class="n">Employee</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span>
    <span class="p">(</span><span class="k">SELECT</span>
        <span class="n">managerId</span><span class="p">,</span>
        <span class="k">count</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>   <span class="k">as</span> <span class="n">n</span>
    <span class="k">FROM</span>
        <span class="n">Employee</span>
    <span class="k">Group</span> <span class="k">By</span> 
        <span class="n">managerId</span><span class="p">)</span>
    <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">managerId</span>
<span class="k">WHERE</span>
    <span class="n">b</span><span class="p">.</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">5</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  maneger id 별로 id가 몇 명인지 구한다음 값이 5 이상인 manager id를 구하면 되는 문제이다. 처음에 문제를 보고 어떻게 풀어야 할지 감이 안와서 subquery를 활용했다. 개인적으로는 Simple하게 가장 좋다고 생각하기에 굳이 subquery를 써야하는 상황이 아니면 쓰고 싶지 않았다. (현 수준 문제에서 subquery를 요구하는 거 같진 않았다.) 하지만, 다른 아이디어가 없었기에 subquery로 manager id 별로 id 수를 구한 다음 left join하여 값이 5이상인 manager를 추출하였다.<br /><br /></p>

<p><strong>Better Solution</strong><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span> 
    <span class="n">Employee</span> <span class="n">a</span>
<span class="k">INNER</span> <span class="k">JOIN</span> 
    <span class="n">Employee</span> <span class="n">b</span>
    <span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">managerId</span>
<span class="k">GROUP</span> <span class="k">BY</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">name</span>
<span class="k">HAVING</span> 
    <span class="k">COUNT</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div></div>
<p>  문제를 풀고 다른 사람의 solutions 중 개인적으로 가장 깔끔하다고 생각하여 가져왔다. 그리고 Having 절에 대해 처음 알게 됐다.(이전에는 몰랐다 ㅠㅠ)
SQL 코드도 짧아졌고 기존 코드보다 직관적으로 이해도 쉽다.</p>

<h3 id="283-good-to-know-where-vs-having">2.8.3 Good to Know: Where vs. Having</h3>
<p>  Where 절과 Having 절은 둘 다 필터링할 때 사용할 수 있다는 공통적인 기능을 제공하지만 차이가 있다. Having 절은 그룹을 필터링하는 데 쓰이며, 집계 함수를 사용하여 필터링이 가능한 반면, Where 절은 개별 행에 대한 필터링이 가능하며 집계 함수를 활용한 필터링이 불가능하다. 즉, Having은 그룹화 혹은 집계 값에 대한 레코드를 필터링하는데 사용되며, Where 절은 개별값에 대한 레코드를 필터링하는데 사용된다.<br />
<br />
<a href="https://velog.io/@ljs7463/SQL-having-%EA%B3%BC-where-%EC%B0%A8%EC%9D%B4">참조사이트</a>: Having 절에 대한 내용은 해당 블로그에서 참조하였습니다.</p>

<h2 id="29-confirmation-rate">2.9 Confirmation Rate</h2>
<h3 id="291-table-descriptoin--question">2.9.1 Table descriptoin &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Signups</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>user_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>time_stamp</td>
      <td>datetime</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Each row contains information about the signup time for the user with ID user_id.</p>
</blockquote>

<p>table: Confirmations</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>user_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>time_stamp(PK)</td>
      <td>datetime</td>
    </tr>
    <tr>
      <td>action</td>
      <td>ENUM</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>user_id is a foreign key with a reference to the Signups table.
action is an ENUM of the type (‘confirmed’, ‘timeout’)
Each row of this table indicates that the user with ID user_id requested a confirmation message at time_stamp and that confirmation message was either confirmed (‘confirmed’) or expired without confirming (‘timeout’).</p>
</blockquote>

<p><strong>Question</strong> <br />
The confirmation rate of a user is the number of ‘confirmed’ messages divided by the total number of requested confirmation messages. The confirmation rate of a user that did not request any confirmation messages is 0. Round the confirmation rate to two decimal places.<br />
Write an SQL query to find the confirmation rate of each user.<br />
Return the result table in any order.</p>

<h3 id="292-solution">2.9.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
   <span class="n">a</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span>
   <span class="n">round</span><span class="p">(</span><span class="n">Coalesce</span><span class="p">(</span><span class="k">count</span><span class="p">(</span><span class="k">case</span> <span class="k">when</span> <span class="n">b</span><span class="p">.</span><span class="n">action</span><span class="o">=</span><span class="s1">'confirmed'</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">end</span><span class="p">)</span> <span class="o">/</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
       <span class="k">as</span> <span class="n">confirmation_rate</span>
<span class="k">FROM</span>
   <span class="n">Signups</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span>
   <span class="n">Confirmations</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">Group</span> <span class="k">by</span>
   <span class="n">a</span><span class="p">.</span><span class="n">user_id</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  confirmation rate을 구하기 위해서는 confirmed 수와 total 수를 구해야 한다. 그래서 case 절을 사용해서 confirmed 수를 구했고 count(*)를 활용해 total 수를 구했다. 근데 굳이 각각 수를 더해서 나눠줄 필요없이 avg 함수를 활용해서 confirmation rate을 구할 수 있다.<br /></p>

<p><code class="language-plaintext highlighter-rouge">avg(case when c.action = 'confirmed' then 1 else 0 end)</code>, 이 방법도 깔끔하고 좋은 것 같다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[  안녕하세요. LeetCode50 Basic Join 이어 가겠습니다.]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이: Basic Joins</title><link href="http://localhost:4000/data/SQL_LeetCode2/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이: Basic Joins" /><published>2023-06-29T00:00:00+09:00</published><updated>2023-06-30T07:07:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode2</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode2/"><![CDATA[<p>  안녕하세요. LeetCode SQL50 두번째 파트인 Basic Joins입니다. Join은 2개 이상의 테이블을 Key를 활용해 하나로 합치는 기능입니다. Join의 방법은 left, inner, outer 등이 있으며 굉장히 많이 활용되는 기능입니다.</p>

<h1 id="2-basic-joins">2. Basic Joins</h1>
<h2 id="21-replace-employee-id-with-the-unique-identifier">2.1 Replace Employee ID With The Unique Identifier</h2>
<h3 id="211-table-description--question">2.1.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Employees</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>name</td>
      <td>varchar</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>id is the primary key for this table.<br />
Each row of this table contains the id and the name of an employee in a company.<br /></p>
</blockquote>

<p>table: EmployeeUNI</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>unique_id</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>(id, unique_id) is the primary key for this table.<br />
Each row of this table contains the id and the corresponding unique id of an employee in the company.</p>
</blockquote>

<p><strong>Question</strong><br />
Write an SQL query to show the unique ID of each user, If a user does not have a unique ID replace just show null.<br />
Return the result table in any order.</p>
<h3 id="212-solution">2.1.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">b</span><span class="p">.</span><span class="n">unique_id</span>     <span class="k">as</span> <span class="n">unique_id</span><span class="p">,</span>
    <span class="n">a</span><span class="p">.</span><span class="n">name</span>          <span class="k">as</span> <span class="n">name</span>
<span class="k">FROM</span>
    <span class="n">Employees</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span> 
    <span class="n">EmployeeUNI</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span>
</code></pre></div></div>

<p>user_id를 key로 Empolyee테이블에 EmployeeUNI테이블의 unique_id를 붙이면 되는 아주 간단한 문제이다.</p>

<h3 id="213-good-to-know">2.1.3 Good to Know</h3>
<p>Left Join 할 때, 매칭되는 값이 없는 경우에는 null로 붙는다.</p>

<h2 id="22-product-sales-analysis-i">2.2 Product Sales Analysis I</h2>
<h3 id="221-table-description--question">2.2.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Sales</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>sale_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>product_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>year</td>
      <td>int</td>
    </tr>
    <tr>
      <td>quantity</td>
      <td>int</td>
    </tr>
    <tr>
      <td>price</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>(sale_id, year) is the primary key of this table.<br />
product_id is a foreign key to Product table.<br />
Each row of this table shows a sale on the product product_id in a certain year.<br />
Note that the price is per unit.</p>
</blockquote>

<p>table: Product</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>product_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>product_name</td>
      <td>varchar</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>product_id is the primary key of this table.<br />
Each row of this table indicates the product name of each product.</p>
</blockquote>

<p><strong>Question</strong><br />
Write an SQL query that reports the product_name, year, and price for each sale_id in the Sales table.<br />
Return the result table in any order.</p>

<h3 id="222-solution">2.2.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="nb">year</span>              <span class="k">as</span> <span class="nb">year</span><span class="p">,</span>
    <span class="n">a</span><span class="p">.</span><span class="n">price</span>             <span class="k">as</span> <span class="n">price</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="n">product_name</span>      <span class="k">as</span> <span class="n">product_name</span>
<span class="k">FROM</span> 
    <span class="n">Sales</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span> 
    <span class="n">Product</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">product_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">product_id</span>
</code></pre></div></div>
<p>위 문제와 마찬가지로 간단한 Join이라 부가설명 없이 넘어가도록 한다.</p>

<h2 id="23-customer-who-visited-but-did-not-make-any-transactions">2.3 Customer Who Visited but Did Not Make Any Transactions</h2>
<h3 id="231-table-description--question">2.3.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Visits</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>visit_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>customer_id</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>This table contains information about the customers who visited the mall.</p>
</blockquote>

<p>table: Transactions</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>transaction_id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>visit_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>amount</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>This table contains information about the transactions made during the visit_id.</p>
</blockquote>

<p><strong>Question</strong> <br />
Write a SQL query to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits.</p>

<h3 id="232-solution">2.3.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">customer_id</span>            <span class="k">as</span> <span class="n">customer_id</span><span class="p">,</span>
    <span class="k">Count</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">customer_id</span><span class="p">)</span>     <span class="k">as</span> <span class="n">count_no_trans</span>
<span class="k">FROM</span> 
    <span class="n">Visits</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span> 
    <span class="n">Transactions</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">visit_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">visit_id</span>
<span class="k">WHERE</span>
    <span class="k">isnull</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">visit_id</span><span class="p">)</span>
<span class="k">GROUP</span> <span class="k">By</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">customer_id</span>
</code></pre></div></div>
<p>Join 하는 경우에도 WHERE 절이나 Group By를 통한 집계도 가능하다!</p>

<h2 id="24-rising-temperature">2.4 Rising Temperature</h2>
<h3 id="241-table-descriptoin--question">2.4.1 Table descriptoin &amp; Question</h3>
<p><strong>Table</strong> description</p>

<p>table: Weather</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id(PK)</td>
      <td>int</td>
    </tr>
    <tr>
      <td>recordDate</td>
      <td>date</td>
    </tr>
    <tr>
      <td>temperature</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>This table contains information about the temperature on a certain day.</p>
</blockquote>

<p><strong>Question</strong> <br />
Write an SQL query to find all dates’ Id with higher temperatures compared to its previous dates (yesterday).<br />
Return the result table sorted by id in ascending order.</p>

<h3 id="242-solution">2.4.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">id</span>
<span class="k">FROM</span> 
    <span class="n">Weather</span> <span class="n">a</span>
<span class="k">Left</span> <span class="k">Join</span> 
    <span class="n">Weather</span> <span class="n">b</span> <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">recordDate</span> <span class="o">=</span> <span class="n">DATE_ADD</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">recordDate</span><span class="p">,</span> <span class="n">Interval</span> <span class="mi">1</span> <span class="k">DAY</span><span class="p">)</span>
<span class="k">Where</span>
    <span class="n">a</span><span class="p">.</span><span class="n">temperature</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">temperature</span>
</code></pre></div></div>
<p>동일 테이블에 Join하는 self table join이며, 어제보다 오늘 기온이 높은 날을 찾아야 한다. 그러기 위해선 오늘 온도와 어제 온도를 비교할 수 있어야 한다. 기본 아이디어는 어제 날짜를 마치 오늘인 것처럼 변환해서 Join하는 것이다. 위 SQL 구문에서 Key 부분을 풀어서 설명하자면, b 테이블 날짜에서 하루를 더해준 날짜와 a 테이블 날짜를 Join 하게 되면 a 테이블 입장에서 전날 데이터가 Join 되게 된다. 예를 들어, ‘2023년 6월 28일’에서 하루 더해주면 ‘2023년 6월 29일’이 되고 이를 기존 테이블에 Join 했을 때, ‘2023년 6월 29일’에 28일 데이터가 붙게 된다. 처음 문제를 보고 막막했는데 아이디어만 잘 낸다면 어렵지 않게 풀 수 있다.</p>

<h3 id="143-good-to-know">1.4.3 Good to Know</h3>
<p><code class="language-plaintext highlighter-rouge">DATE_ADD</code> 함수는 기준 날짜에 지정한 값만큼 더해주는 시간 함수이다. 첫번째 인수로는 기준 시간을 입력하고, 두번째 인수로 원하는 단위를 입력하면 된다. ‘Interval 1 DAY’는 하루만큼 더하라는 의미이며, second, month, year 등 다양한 인수를 넣어줄 수 있다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[  안녕하세요. LeetCode SQL50 두번째 파트인 Basic Joins입니다. Join은 2개 이상의 테이블을 Key를 활용해 하나로 합치는 기능입니다. Join의 방법은 left, inner, outer 등이 있으며 굉장히 많이 활용되는 기능입니다.]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이</title><link href="http://localhost:4000/data/SQL_LeetCode1/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이" /><published>2023-06-18T00:00:00+09:00</published><updated>2023-06-19T02:56:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode1</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode1/"><![CDATA[<p>  안녕하세요. 데이터 분석가에게 SQL 활용 능력은 필수적이라 생각됩니다. 웬만한 데이터 분석가 JD 요구사항에 SQL 활용능력이 없는 경우는 없더군요. 저도 데이터 분석가 업무를 하면서 실무에서 유사(?) SQL을 활용해 데이터 마트를 만들지만 내가 SQL을 제대로 다루고 있는지 항상 의문이 따라왔습니다. 게다가 제 SQL 활용 능력이 어느정도인지 궁금하기도 했습니다. 따라서 실무 외에 SQL을 제대로 한 번 공부해보고 싶었고, 그 중 하나로 웹에 SQL 문제를 풀어보기로 했습니다. 구글링을 해보니 SQL 문제를 제공하는 여러 사이트가 나왔고, 그 중에서 LeetCode가 50문제 정도를 무료로 제공하길래 시작으로 괜찮다 싶어서 정했습니다! 리트코드 50문제를 풀어보고 문제별로 Solution을 이 블로그에 정리하고자 합니다.</p>

<h1 id="1-select">1. Select</h1>
<p>  첫 Section은 Select로 아주 기본적인 SQL 문을 활용해 풀 수 있는 문제들이었다.</p>
<h2 id="11-recyclable-and-low-fat-products">1.1 Recyclable and Low Fat Products</h2>
<h3 id="111-table-description--question">1.1.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Product_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>low fats</td>
      <td>enum</td>
    </tr>
    <tr>
      <td>recyclable</td>
      <td>enum</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>table name is “PRODUCTS”<br />
product_id is the primary key for this table. <br />
low_fats is an ENUM of type (‘Y’, ‘N’) where ‘Y’ means this product is low fat and ‘N’ means it is not.<br />
recyclable is an ENUM of types (‘Y’, ‘N’) where ‘Y’ means this product is recyclable and ‘N’ means it is not.</p>
</blockquote>

<p><strong>Question</strong><br />
Write an SQL query to find the ids of products that are both low fat and recyclable.<br />
Return the result table in any order.</p>
<h3 id="112-solution">1.1.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> 
    <span class="n">product_id</span>
<span class="k">FROM</span> 
    <span class="n">PRODUCTS</span>
<span class="k">WHERE</span> 
    <span class="n">low_fats</span> <span class="o">=</span> <span class="s1">'Y'</span> <span class="k">and</span> <span class="n">recyclable</span> <span class="o">=</span> <span class="s1">'Y'</span>
</code></pre></div></div>

<p>문제가 요구하는 것은 low fat이고 재활용 가능한 제품명을 추출해 보여달라는 것이다. low fat &amp; recyclable한 제품만을 추출하기 위해 조건절을 추가해주면 된다. WHERE 조건절도 각각 본인 스타일에 맞게 쓰면 된다. 하나의 정답만 있는 것은 아니다.</p>

<h3 id="113-good-to-know">1.1.3 Good to Know</h3>
<p>Enum 타입 데이터는 Character형 데이터 타입이며, 해당 Column에 할당할 수 있는 값들을 지정해 줄 수 있다. 해당 데이터 칼럼에 값들을 제약할 수 있는 기능을 재공해준다(데이터 정합성 확보에 유리함). Enum 타입 데이터 칼럼은 값과 index 모두 활용하여 값을 불러올 수 있다. <br />
다만, Enum 타입에 새로운 데이터를 추가할 때 번거로움이 있으며 정렬이나 연산 시 불리하다는 의견도 있는 것 같다. 추가로 Enum 타입 데이터를 지원하지 않는 DBMS로의 이식이 어려울 수 있을 것 같다. 따라서 굳이 Enum 타입 데이터를 활용하기 보다는 참조 테이블을 활용하는 것이 좋을 수 있다.</p>

<h2 id="12-find-customer-referee">1.2 Find Customer Referee</h2>
<h3 id="121-table-description--question">1.2.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<table>
  <thead>
    <tr>
      <th>Colum Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>name</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>refree_id</td>
      <td>int</td>
    </tr>
  </tbody>
</table>

<p><strong>Input:</strong><br />
Customer table:<br /></p>

<table>
  <thead>
    <tr>
      <th>id</th>
      <th>name</th>
      <th>referee_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Will</td>
      <td>null</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Jane</td>
      <td>null</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Alex</td>
      <td>2</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Bill</td>
      <td>null</td>
    </tr>
    <tr>
      <td>5</td>
      <td>Zack</td>
      <td>1</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Mark</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>table name is “Customer”<br />
Each row of this table indicates the id of a customer, their name, and the id of the customer who referred them.</p>
</blockquote>

<p><strong>Question</strong><br />
Write an SQL query to report the names of the customer that are not referred by the customer with id = 2.
Return the result table in any order.</p>

<h3 id="122-solution">1.2.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">name</span>
<span class="k">FROM</span>
  <span class="n">Customer</span>
<span class="k">WHERE</span>
  <span class="n">referee_id</span> <span class="o">!=</span> <span class="mi">2</span> <span class="k">or</span> <span class="k">isnull</span><span class="p">(</span><span class="n">referee_id</span><span class="p">)</span>
</code></pre></div></div>

<p>input Table을 보면 refree_id에 null값이 포함되어 있다. 만약 Where 조건절에 refree_id != 2 조건만 있으면 refree_id가 null인 값을 제외시켜 버리기 때문에, refree_id가 null인 record를 불러오기 위해 조건을 추가해야 한다. 따라서 refree_id != 2 or isnull(refree_id)로 조건절을 줘야 refree_id가 2인 record를 제외한 모든 record를 불러오게 된다.</p>

<h3 id="133-good-to-know">1.3.3 Good to Know</h3>
<p>다른 사람이 올린 Solution 중, null값을 처리하는 다양한 방법이 있길래 알아두면 좋을 것 같아 기록하고자 한다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">refree_id</span> <span class="k">IS</span> <span class="k">NULL</span>
<span class="n">Coalesce</span><span class="p">(</span><span class="n">refree_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">(</span><span class="k">or</span> <span class="o">&lt;&gt;</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>
<p>isnull() 등 함수를 활용하여 null값을 처리하는게 익숙하다보니 함수로 처리했는데, 함수를 쓰지 않아도 “IS Null” 구문으로 처리가 가능하다. 직관적으로 이해하기 쉽다. <br />
coalesce 함수는 보통 Null값이 있는 데이터 컬럼을 처리할 때 종종 사용하는 함수이다. 첫 번째 인수로 들어가 있는 컬럼의 값이 Null인 경우 두 번째 인수의 값을 할당하고 두 번째 인수의 값도 Null인 경우 그 다음 인수의 값을 할당해주는 식의 함수이다. 위의 코드를 해석하면 refree_id가 null인 경우에 0을 할당해주고 그 값이 2가 아닌 경우를 판별하는 조건문이다. If 문을 활용하는 것보다 훨씬 깔끔하다 ㅎㅎ</p>

<h2 id="13-big-countries">1.3 Big Countries</h2>
<h3 id="131-table-description--question">1.3.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>name</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>continent</td>
      <td>varchar</td>
    </tr>
    <tr>
      <td>area</td>
      <td>int</td>
    </tr>
    <tr>
      <td>population</td>
      <td>int</td>
    </tr>
    <tr>
      <td>gdp</td>
      <td>bigint</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>name is the primary key column for this table.<br />
Each row of this table gives information about the name of a country, the continent to which it belongs, its area, the population, and its GDP value.</p>
</blockquote>

<p><strong>Input:</strong><br />
Customer table:<br /></p>

<table>
  <thead>
    <tr>
      <th>name</th>
      <th>continent</th>
      <th>area</th>
      <th>population</th>
      <th>gdp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Afghanistan</td>
      <td>Asia</td>
      <td>652230</td>
      <td>25500100</td>
      <td>20343000000</td>
    </tr>
    <tr>
      <td>Albania</td>
      <td>Europe</td>
      <td>28748</td>
      <td>2831741</td>
      <td>12960000000</td>
    </tr>
    <tr>
      <td>Algeria</td>
      <td>Africa</td>
      <td>2381741</td>
      <td>37100000</td>
      <td>188681000000</td>
    </tr>
    <tr>
      <td>Andorra</td>
      <td>Europe</td>
      <td>468</td>
      <td>78115</td>
      <td>3712000000</td>
    </tr>
    <tr>
      <td>Angola</td>
      <td>Africa</td>
      <td>1246700</td>
      <td>20609294</td>
      <td>100990000000</td>
    </tr>
  </tbody>
</table>

<p><strong>Question</strong> <br />
A country is big if:</p>

<ul>
  <li>it has an area of at least three million (i.e., 3000000 km2), or</li>
  <li>it has a population of at least twenty-five million (i.e., 25000000).</li>
</ul>

<p>Write an SQL query to report the name, population, and area of the big countries.<br />
big 조건에 부합하는 국가의 국가명, 인구, 면적을 report하면 된다.</p>

<h3 id="132-solution">1.3.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">name</span><span class="p">,</span>
  <span class="n">population</span><span class="p">,</span>
  <span class="n">area</span>
<span class="k">FROM</span> 
  <span class="n">World</span>
<span class="k">WHERE</span>
  <span class="n">area</span> <span class="o">&gt;=</span> <span class="mi">3000000</span> <span class="k">or</span> <span class="n">population</span> <span class="o">&gt;=</span> <span class="mi">25000000</span>
</code></pre></div></div>
<p>간단한 문제이므로 추가설명은 하지 않도록 하겠다.</p>

<h2 id="14-article-views-i">1.4 Article Views I</h2>
<h3 id="141-table-descriptoin--question">1.4.1 Table descriptoin &amp; Question</h3>
<p><strong>Table</strong> description</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>article_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>author_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>viewer_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>view_date</td>
      <td>date</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>There is no primary key for this table, it may have <strong>duplicate rows.</strong> <br />
Each row of this table indicates that some viewer viewed an article (written by some author) on some date. <br />
Note that <strong>equal author_id and viewer_id indicate the same person.</strong></p>
</blockquote>

<p>주의해야 할 점은 데이터가 중복인 row가 있다는 것과 author_id와 viewer_id가 값이 같다면 동일인물이라는 것이다.</p>

<p><strong>Input:</strong><br />
Customer table:<br /></p>

<table>
  <thead>
    <tr>
      <th>article_id</th>
      <th>author_id</th>
      <th>viewer_id</th>
      <th>view_date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>3</td>
      <td>5</td>
      <td>2019-08-01</td>
    </tr>
    <tr>
      <td>1</td>
      <td>3</td>
      <td>6</td>
      <td>2019-08-02</td>
    </tr>
    <tr>
      <td>2</td>
      <td>7</td>
      <td>7</td>
      <td>2019-08-01</td>
    </tr>
    <tr>
      <td>2</td>
      <td>7</td>
      <td>6</td>
      <td>2019-08-02</td>
    </tr>
    <tr>
      <td>4</td>
      <td>7</td>
      <td>1</td>
      <td>2019-07-22</td>
    </tr>
    <tr>
      <td>3</td>
      <td>4</td>
      <td>4</td>
      <td>2019-07-21</td>
    </tr>
    <tr>
      <td>3</td>
      <td>4</td>
      <td>4</td>
      <td>2019-07-21</td>
    </tr>
  </tbody>
</table>

<p><strong>Question</strong> <br />
Write an SQL query to find all the authors that viewed at least one of their own articles.<br />
Return the result table sorted by id in ascending order.</p>

<h3 id="142-solution">1.4.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">DISTINCT</span>
    <span class="n">author_id</span> <span class="k">as</span> <span class="n">id</span>
<span class="k">FROM</span>
    <span class="n">Views</span>
<span class="k">WHERE</span>
    <span class="n">author_id</span> <span class="o">=</span> <span class="n">viewer_id</span>
<span class="k">ORDER</span> <span class="k">BY</span>
    <span class="n">id</span> <span class="k">asc</span>
</code></pre></div></div>
<p>중복값을 처리하기 위해 SELECT 문 뒤에 DISTINCT를 추가했다. 실무에서도 Table을 로드할 때, 습관적으로 Distinct를 붙여주곤 한다. 특히, 여러 테이블을 Join할 때, 중복값이 있는 경우 결과값이 뻥튀기 되어 컴퓨팅 리소스를 한계 이상으로 활용하여 다운될 수 있는 위험이 있기 때문이다. 물론 중복이 애초에 안생기게 하는 것이 최선이지만 혹시 모를 사고를 미연에 방지하기 위한 습관이다.</p>

<h3 id="143-good-to-know">1.4.3 Good to Know</h3>
<p>SQL린이 시절, 오름차순 내림차순이 항상 헷갈렸다. 이제는 헷갈릴 일이 없긴 하지만, 오름차순은 낮은 값부터 높은 값 순으로 정렬하는 거고 영어로 보통 <code class="language-plaintext highlighter-rouge">asc or ascending</code>로 표기한다. 내림차순은 반대이며 보통 <code class="language-plaintext highlighter-rouge">desc or descending</code>으로 표기한다.</p>

<h2 id="15-invalid-tweets">1.5 Invalid Tweets</h2>
<h3 id="151-table-description--question">1.5.1 Table Description &amp; Question</h3>
<p><strong>Table</strong> description</p>

<table>
  <thead>
    <tr>
      <th>Column Name</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>tweet_id</td>
      <td>int</td>
    </tr>
    <tr>
      <td>content</td>
      <td>varchar</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>tweet_id is the primary key for this table.<br />
This table contains all the tweets in a social media app.</p>
</blockquote>

<p><strong>Input:</strong><br />
Customer table:<br /></p>

<table>
  <thead>
    <tr>
      <th>tweet_id</th>
      <th>content</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Vote for Biden</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Let us make America great again!</td>
    </tr>
  </tbody>
</table>

<p><strong>Question</strong> <br />
Write an SQL query to find the IDs of the invalid tweets. The tweet is invalid if the number of characters used in the content of the tweet is <strong>strictly greater than 15.</strong></p>

<h3 id="152-solution">1.5.2 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">tweet_id</span>
<span class="k">FROM</span>
    <span class="n">Tweets</span>
<span class="k">WHERE</span>
    <span class="k">length</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">15</span>
</code></pre></div></div>

<p>문제에서 요구한 글자수가 15보다 많은 tweet_id를 추출하기 위해서 content 데이터의 글자수를 알아야한다. character형태의 데이터의 글자수를 알기 위해서는 <code class="language-plaintext highlighter-rouge">length()</code> 함수를 활용하면 된다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[  안녕하세요. 데이터 분석가에게 SQL 활용 능력은 필수적이라 생각됩니다. 웬만한 데이터 분석가 JD 요구사항에 SQL 활용능력이 없는 경우는 없더군요. 저도 데이터 분석가 업무를 하면서 실무에서 유사(?) SQL을 활용해 데이터 마트를 만들지만 내가 SQL을 제대로 다루고 있는지 항상 의문이 따라왔습니다. 게다가 제 SQL 활용 능력이 어느정도인지 궁금하기도 했습니다. 따라서 실무 외에 SQL을 제대로 한 번 공부해보고 싶었고, 그 중 하나로 웹에 SQL 문제를 풀어보기로 했습니다. 구글링을 해보니 SQL 문제를 제공하는 여러 사이트가 나왔고, 그 중에서 LeetCode가 50문제 정도를 무료로 제공하길래 시작으로 괜찮다 싶어서 정했습니다! 리트코드 50문제를 풀어보고 문제별로 Solution을 이 블로그에 정리하고자 합니다.]]></summary></entry><entry><title type="html">[하루일기] 23년 6월 13일: 감정적인 대응</title><link href="http://localhost:4000/data/daily_memo/" rel="alternate" type="text/html" title="[하루일기] 23년 6월 13일: 감정적인 대응" /><published>2023-06-13T00:00:00+09:00</published><updated>2023-06-14T06:55:00+09:00</updated><id>http://localhost:4000/data/daily_memo</id><content type="html" xml:base="http://localhost:4000/data/daily_memo/"><![CDATA[<p>  오늘 클라이언트와 아주 약간 언짢은 상황이 발생했다. 좀처럼 적극적으로 액션을 취하지 않는 클라이언트에게 나도 팀장님도 답답함이 계속 쌓여가는 상황이었는데, 클라이언트와 커뮤니케이션 과정에서 감정적인 대응이 나와버렸다. 화를 내거나 공격적인 언사를 한 것은 아니었지만, 스스로 조금 더 냉정하게 대응했으면 어떘을까 하는 아쉬움이 많이 남습니다. <br /><br /></p>

<p>  상황은 이러했다. 팀장님은 답답한 마음에 타 사업부에 분석 사례를 클라이언트가 참고할 수 있도록 공유하라 지시했고, 짧은 메시지와 함꼐 자료를 첨부하여 메일을 보냈다. 문제는 클라이언트가 굉장히 불편하게 받아들이면서 발생했다. 클라이언트가 마치 자기보고 배우라는 듯이 자료를 보낸거냐부터 시작해서 엔지니어 입장에서 택도 없는 분석이라면서 말도 안되는 거라면서 따졌다. (물론, 숨은 의도는 그게 맞다. 게다가 자료는 공장 엔지니어가 직접 작성한 자료라 아예 틀린 말은 아닐 것이다.) 여기서 나의 올바른 대응은 나도 팀장님의 지시사항을 수행한 것이며, 도움이 될 수 있도록 자료를 공유하고자 한 것이라고 어필을 해야 했다. 하지만 그 동안 답답한 마음이 쌓였던 탓인지 자그마한 설전이 오고가게 됐다. 도메인 영역 지식으로 논리를 펼치니 난 더 할 말이 없었고, 알겠다고 수긍하며 일단락 지었다. <br /><br /></p>

<p>  오늘 일련의 해프닝을 겪으며 스스로에게 아쉬었던 점은 다음과 같다</p>
<blockquote>
  <ol>
    <li>감정적으로 대응한 점
      <ul>
        <li>내 뜻대로 안된다고 답답해하거나 조급해 하지 말기</li>
        <li>감정적인 반응에 감정적으로 맞대응 하지 말기</li>
      </ul>
    </li>
    <li>나의 역할은 중간 커뮤니케이선
      <ul>
        <li>클라이언트와 팀장 사이에 중간 커뮤니케이션 분배 잘하기</li>
        <li>책임과 역할 소재 분명히 하기</li>
      </ul>
    </li>
    <li>어설픈 논리와 근거로 커뮤니케이션 하지 않기
      <ul>
        <li>상대방은 한 분야의 전문가이므로 어설픈 얘기는 통하지 않음</li>
        <li>적어도 최소한의 논리로 무장하기</li>
      </ul>
    </li>
  </ol>
</blockquote>

<p>  일을 하다보면 클라이언트와 의견 충돌이 발생하고 언쟁이 발생할 수 있다고 생각하고 실제로 벌어졌습니다. 갈등 상황을 피하는 것이 능사는 아니라 생각합니다. 서로의 의견을 논리정연하게 피력하고 건설적으로 대화하는 것이 중요하겠죠. 다만, 감정적으로 대응하는 것은 프로답지 못한 행동이라 생각되고 반성하게 되네요. 앞으로는 오늘같은 일이 일어나더라도 차분하고 이성적으로 대응할 수 있는 사람이 되도록 노력하겠습니다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="Memoir" /><summary type="html"><![CDATA[  오늘 클라이언트와 아주 약간 언짢은 상황이 발생했다. 좀처럼 적극적으로 액션을 취하지 않는 클라이언트에게 나도 팀장님도 답답함이 계속 쌓여가는 상황이었는데, 클라이언트와 커뮤니케이션 과정에서 감정적인 대응이 나와버렸다. 화를 내거나 공격적인 언사를 한 것은 아니었지만, 스스로 조금 더 냉정하게 대응했으면 어떘을까 하는 아쉬움이 많이 남습니다.]]></summary></entry><entry><title type="html">[회고록] 23년 6월 2주차: 분석 능력이란 뭘까?</title><link href="http://localhost:4000/data/weekly_memoir_6/" rel="alternate" type="text/html" title="[회고록] 23년 6월 2주차: 분석 능력이란 뭘까?" /><published>2023-06-12T00:00:00+09:00</published><updated>2023-06-13T05:40:00+09:00</updated><id>http://localhost:4000/data/weekly_memoir_6</id><content type="html" xml:base="http://localhost:4000/data/weekly_memoir_6/"><![CDATA[<p>  최근 SNS 중 하나인 링크드인을 자주 봅니다. 따로 글을 쓰거나 하진 않지만, 제가 몸담고 있는 업계에 다른 동료분들이 어떤 생각을 가지고 일하는 지 알 수 있어서 꽤 재밌게 보고 있습니다. 링크드인 속에는 수많은 데이터 분석가(+데이터 전문가) 분들이 있고, 저마다의 업무 역량, 분석 역량을 뽐내고 계십니다. 피드들을 열심히 눈팅하다보니 문득 그런 생각이 들더군요. <strong>그렇다면 과연 분석 능력이란 뭘까요?</strong> 나의 분석 능력은 뛰어나다고 할 수 있는 건가? 나는 좋은 분석가인가? 라는 고민이 이어지게 됩니다.<br /><br /></p>

<p>  생각하면 할수록 정말 답하기 어려운 질문인 것 같습니다. 업무 분야도 다 다르고 각자 생각하는 기준이 다 다르기 떄문이기에 딱 하나의 정답은 없는 것 같습니다. 별다른 구분 없이 생각나는대로 나열해보겠습니다.</p>

<blockquote>
  <ol>
    <li><span style="color:red">데이터 분석을 통해 프로덕트에 유의미한 성장을 이끌어 냄</span></li>
    <li><span style="color:red">데이터 분석을 통해 클라이언트의 문제를 해결해 냄</span></li>
    <li>최신 예측 모형에 대하여 꾸준히 학습하고 예측력이 좋은 ML 모형을 개발할 줄 암</li>
    <li>데이터 분석을 수행할 다양한 Tool을 다룰줄 암</li>
    <li>데이터 핸들링을 기가막히게 함</li>
    <li>BI를 활용해 대쉬보드/리포트/분석화면을 설계하고 개발함</li>
    <li>도메인 지식에 대한 깊이있는 이해가 있음</li>
    <li>데이터 분석 결과를 타인에게 설득할 수 있는 커뮤니케이션 스킬 혹은 문서 작성 스킬</li>
    <li>업무를 대하는 태도, 책임감, 성실함 등</li>
  </ol>
</blockquote>

<p>  데이터 분석가의 가장 궁극적인 목표는 결국 1 &amp; 2번은 잘 할 수 있는 분석가가 되는 것이겠죠. 다만, 이는 온전히 개인의 역량으로 뭔가를 이루어내기 어렵다는 점에서 분석가의 개인적인 분석 능력이라 평하기는 매우 어렵습니다. 그리고 따지고 보면 1 &amp; 2번 외에 나머지 항목들은 결국 1 &amp; 2번을 잘하기 위한 것들입니다. 데이터 분석을 잘 하기 위한 도구인거죠. 칼을 잘 다룬다고 무조건 맛있는 음식을 만들어 내는 것은 아닌 것처럼 다양한 도구를 잘 다룬다고 데이터 분석을 잘한다고 하기는 어렵습니다. 실제로 IT 기반 &amp; 코딩 능력 하나 없이 셀프서비스 소프트웨어를 활용해 데이터 분석을 기가막히게 본업에 활용해 유의미한 가치를 만들어내는 분들도 봤습니다. 물론, 도구를 잘 다루면 분석을 잘하고 분석 능력이 좋을 확률은 그렇지 않은 사람보다 훨씬 더 높다고 생각합니다. 하지만 중요한 것은 본질을 놓쳐서는 안된다는 것입니다. 너무 기술적인 부분에 집중하다보면 정작 분석에 있어서는 아쉬운 부분이 있을 수도 있다고 생각합니다. <br /><br /></p>

<p>  그렇다보니 시중에 쏟아지는 최신 기술, 동향에 압도되기 보다는 현재 본인 업무에 있어서 필요한 것을 채워가는게 중요하다고 생각합니다. 저도 가끔은 쏟아지는 최신 기술, 트렌드에 압도되는 것 같을 때도 있고 조급해질 떄도 있습니다. 그럴때면 괜히 조바심을 내기보다는 천천히 내가 부족한 것을 채우기 위해, 그리고 내 분석 업무에 도움될 만한 것들을 갖추기 위해 노력하고 있습니다. 그러다 보면 더 나은, 더 뛰어난 분석가가 될 수 있다고 생각하며 계속 채워나가는 중입니다. 개인적으로 요즘 가장 중요하게 생각하는 것은 분석함에 있어서 얼마나 논리적으로 사고하는가 입니다. 우리가 마주한 문제에 있어서 논리적으로 가설을 세우고 정리하여 접근해야지 헤매지 않고 답을 발견해 나갈 수 있다 생각합니다. 논리가 빈약한 채로 분석을 하면 장담컨대 답을 도출해 내기 어려울 뿐만 아니라 클라이언트를 설득하기는 더 어려울 것입니다. 그래서 전 의식적으로라도 더 논리적으로 사고하고 문제에 접근하고자 노력하고 있습니다. 가장 좋은 방법은 훌룡한 선배, 동료들의 방식을 보고 배우는 것입니다. 그렇기에 좋은 동료가 있는 집단으로 가야하는 것이구요. <br /><br /></p>

<p>  앞서 말했듯이 뛰어난 분석 능력은 무엇인가에 대한 하나의 답은 없는 것 같습니다. 하지만 분석가에 존재의의에 대해 고민하다보면 뛰어난 분석가가 되기 위해 무엇을 잘 해야 하는지는 명확한 것 같습니다. 훌룡한 분석가가 되기 위해 꾸준하게 나아가고자 합니다. 우리 모두 화이팅입니다!</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="Memoir" /><summary type="html"><![CDATA[  최근 SNS 중 하나인 링크드인을 자주 봅니다. 따로 글을 쓰거나 하진 않지만, 제가 몸담고 있는 업계에 다른 동료분들이 어떤 생각을 가지고 일하는 지 알 수 있어서 꽤 재밌게 보고 있습니다. 링크드인 속에는 수많은 데이터 분석가(+데이터 전문가) 분들이 있고, 저마다의 업무 역량, 분석 역량을 뽐내고 계십니다. 피드들을 열심히 눈팅하다보니 문득 그런 생각이 들더군요. 그렇다면 과연 분석 능력이란 뭘까요? 나의 분석 능력은 뛰어나다고 할 수 있는 건가? 나는 좋은 분석가인가? 라는 고민이 이어지게 됩니다.]]></summary></entry><entry><title type="html">[회고록] 23년 5월 3주차: 에너지 절감</title><link href="http://localhost:4000/data/weekly_memoir_5/" rel="alternate" type="text/html" title="[회고록] 23년 5월 3주차: 에너지 절감" /><published>2023-05-21T00:00:00+09:00</published><updated>2023-05-21T20:08:00+09:00</updated><id>http://localhost:4000/data/weekly_memoir_5</id><content type="html" xml:base="http://localhost:4000/data/weekly_memoir_5/"><![CDATA[<p>  안녕하세요. 요즘엔 <strong>데이터 분석을 통해 공장에서 사용하는 에너지 절감 프로젝트</strong>를 수행중에 있습니다. 최근 에너지 원가 상승으로 인하여 에너지 비용이 증가하여 공장 입장에서는 부담이 되고 있는 상황입니다. 따라서 공장에서는 에너지 절감을 위해 다양한 활동을 수행하고 있고, 그 노력의 일환으로 데이터 분석을 통한 에너지 사용 절감안을 도출하고자 합니다. ‘23년 1년 프로젝트로 기획됐고 2월부터 시작해 현재 진행중에 있습니다. 보안 상 디테일한 부분을 얘기하긴 어렵지만 어떻게 데이터 분석 프로젝트를 진행하고 있는지 간략하게만 기록하겠습니다.
<br /><br />
  에너지 절감을 위하여 다양한 접근 방법이 있겠지만 우리는 다음과 같은 방식으로 단계로 데이터 분석 프로젝트를 진행했습니다.</p>

<h2 id="1-에너지-파악">1. 에너지 파악</h2>
<p>  우선, 공장에서 사용하고 있는 에너지 종류와 에너지 별 사용 목적에 대해 파악이 필요합니다. 어떤 에너지를 사용하고 있고, 공장에서 사용하고 있는 다양한 에너지 중 가장 중요도가 큰 에너지는 무엇인지, 어느 공정에 어떤 목적으로 사용되고 있는지 등에 대한 공정 파악이 필요합니다. 에너지 사용 공정 메커니즘에 대한 이해없는 데이터 분석을 통해 유효한 인사이트를 도출하기는 어렵기 때문입니다.</p>
<blockquote>
  <ul>
    <li>사용 에너지 종류, 중요도(우선순위), 사용 목적 파악</li>
    <li>에너지 사용 공정에 대한 공정 메커니즘 파악</li>
  </ul>
</blockquote>

<h2 id="2-데이터-수집">2. 데이터 수집</h2>
<p>  프로젝트 대상 공장에서 사용하고 있는 에너지에 대한 파악이 되면, 본격적인 데이터 분석을 위한 데이터 수집이 필요합니다. 중요한 것은 에너지 사용량을 데이터로 관리하고 있는지부터 알아야 합니다(데이터가 없다면 애초에 분석 프로젝트 진행이 불가합니다). 데이터가 있다면 어디에 어떻게 관리하고 있는지, 어떻게 데이터를 가져와서 분석할 것인지에 대한 논의가 필요합니다.</p>
<blockquote>
  <ul>
    <li>데이터 존재 여부 파악(에너지 사용량, 관련 공정 센싱, 품질 데이터 등)</li>
    <li>데이터 저장 위치, 형태 등 파악</li>
    <li>데이터 전처리 및 분석 데이터 마트 생성</li>
    <li>BI 분석 화면 개발</li>
  </ul>
</blockquote>

<h3 id="21-데이터-이슈">2.1 데이터 이슈</h3>
<p>  현재 프로젝트 대상 공장에서는 공정/설비별로 사용하고 있는 에너지 사용량을 일/월 별로 기입하여 관리하고 있었고, 분석 데이터 마트를 생성하기 위해서는 엑셀로부터 데이터를 추출하는 프로그램을 짜야했습니다. 문제는 작업자가 일일이 수기로 입력한 데이터 이기에 오기입된 데이터도 많고 예외처리를 해야할 것이 정말 많았습니다. 이 오류를 처리하는데 애 많이 먹었습니다😭. 이에 더하여 외기온도 데이터가 필요한데 공장에서 수집하는 데이터가 없었기에, 공공기관데이터포털에서 제공하는 지역별 온도 데이터를 수집해서 대용으로 사용했습니다. rest api 호출하는 방식을 활용해 가져오는 데이터 추출 코드를 짜봤는데 재밌었습니다😄.</p>

<h3 id="22-주의할-점">2.2 주의할 점</h3>
<p>  데이터의 단위를 정확하게 확인해야 합니다. 특히, 공학, 자연과학 계열 전공자가 아니라 사회계열, 수리계열, 컴공계열 전공자라면 에너지(물질) 단위가 굉장히 헷갈릴 수 있습니다. 예를 들어, 유량 단위인지, 질량 단위인지 그리고 일별 사용량인지, 시간당 사용량인지 등 정확하게 파악이 필요합니다. 만약 단위를 제대로 감안하지 않은 채로 데이터 전처리하고 분석을 진행한다면 후에 계산이 잘못될 수 있으니 유의해야 합니다.</p>

<h2 id="3-에너지-사용-현황-파악-문제점-도출">3. 에너지 사용 현황 파악, 문제점 도출</h2>
<p>  앞의 과정은 데이터 분석을 위한 준비과정이었다면 여기서부턴 본격적인 데이터 분석 과정에 들어갑니다. 이번 프로젝트에서는 다음 절차로 진행했습니다.</p>

<h3 id="31-분석-대상-순서-선정">3.1 분석 대상, 순서 선정</h3>
<p>  공장에서는 다양한 에너지를 사용해 제품을 생산하기 때문에 우선순위를 선정하여 진행합니다. (물론 인력이 충분하고 여유가 있다면 모든 에너지에 대하여 한 번에 진행해도 됩니다. 다만, 현실적으로 매우 어렵죠) 데이터 현황분석을 통해 사용량이 가장 많고 산포가 큰 에너지 순으로 우선순의를 정하거나 혹은 클라이언트의 요청으로 우선순위를 정하게 됩니다. 에너지 사용 산포가 작거나, 중요도가 낮은 에너지의 경우 분석 대상에서 제외되는 경우도 있습니다. 분석 대상이 선정된다면 관련 공정 메커니즘에 대한 이해는 필수입니다! 대상 공정에서 에너지가 사용되는 목적과 공정/품질 관리 인자와 기준 존재 여부 등 에너지 관련 공정 메커니즘 파악이 필요합니다.</p>
<blockquote>
  <ul>
    <li>분석 대상 및 우선순위 선정</li>
    <li>분석 대상 공정 메커니즘(에너지 관련) 파악</li>
  </ul>
</blockquote>

<h3 id="32-문제점-진단">3.2 문제점 진단</h3>
<p>  분석 대상이 선정되면 문제점을 진단해야 합니다. 현재 에너지 사용량이 적정 수준을 벗어나 과다한 것은 아닌 지, 절감 요소는 존재하는지 판단해야 합니다. <br /><br />
  그렇다면 <strong>판단 기준</strong>은 무엇일까요?<br />
  가장 기본은 <span style="color:red"><strong>외생 변수</strong></span> 기준으로 체크하는 것입니다. 보통 가정집에서도 전기 요금을 비교할 때, 동월 간 비교를 합니다. 왜일까요? 보통 여름에 에어컨을 틀면서 전기 요금이 많이 청구되고 따라서 환절기와 하절기 간 전기 요금 비교는 무의미하기 때문입니다. 공장도 마찬가지입니다. 동일 기온, 동일 생산조건, 동일 생산량(투입량)을 기준으로 에너지 사용량을 비교해야 합니다. 예를 들어, 계절별로 에너지 사용량에 차이가 발생하는 경우 외기온도를 고정시킨 다음에 에너지 사용량의 산포를 확인해야 합니다. 따라서 특정 공정별 사용 에너지에 따라 외생변수를 잘 정의해야 할 필요가 있습니다. <br />
  다음으로는 <span style="color:red"><strong>공정 변경 혹은 운전 패턴 변경</strong></span> 이력에 따른 에너지 사용량 변동을 파악하는 것입니다. 과거 공정 운전 패턴의 변경에 따라 에너지 사용량의 변화가 있는지 비교하여 현재 에너지 사용량에 대한 수준을 파악할 수 있습니다. 공정 운전 패턴 변경이 에너지 관점에서 낭비가 발생한다면 재검토해 볼 필요가 있을 수 있고 혹은 추가 개선 포인트를 도출해 낼 수 도 있을 겁니다. <br /><br />
  판단 기준에 따라 현재 에너지 사용이 적절한 지 혹은 과거 대비 낭비요소가 있는 지 등 다양한 측면에서 문제점을 진단합니다. 만약 낭비요소가 존재한다면 다음 스텝으로 넘어가 산포 발생 원인을 도출하는 작업을 하게 됩니다. 낭비요소 없이 현 수준이 최적 에너지 사용 상태라면 더 이상 분석을 진행하지 않습니다.</p>
<blockquote>
  <ul>
    <li>에너지 별 외생변수 파악</li>
    <li>공정 운전 패턴 변경이력 파악</li>
    <li>문제점 진단</li>
  </ul>
</blockquote>

<h4 id="321-주의사항">3.2.1 주의사항</h4>
<p>  에너지 사용 문제점을 진단할 때 반드시 고려해야 할 부분이 바로 <strong>공정 품질</strong>입니다. 에너지 사용량을 절감했지만 공정 품질을 만족하지 못한다면 이는 에너지 사용 과소 상태로 적절한 수준의 에너지 사용량이 아닙니다. 이 상태에서는 오히려 에너지를 더 투입하여 품질을 만족시켜야만 합니다. 반대로 현재 에너지 사용 수준에서 품질 관리 수준 대비 마진이 커 여유가 있다면, 에너지 과다 상태로 에너지 절감안 도출을 검토해 볼 수 있습니다.</p>

<h2 id="4-다음-회고록을-기약하며">4. 다음 회고록을 기약하며…</h2>
<p>  회고록을 작성하다보니 처음 생각한 것 보다 내용이 너무 길어졌습니다. 현재 진행중인 프로젝트이기도 하고 남은 내용은 다음 회고록에 적을 수 있도록 하겠습니다. 그럼 이번 회고록은 여기서 마치도록 하겠습니다. 감사합니다!</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="Memoir" /><summary type="html"><![CDATA[  안녕하세요. 요즘엔 데이터 분석을 통해 공장에서 사용하는 에너지 절감 프로젝트를 수행중에 있습니다. 최근 에너지 원가 상승으로 인하여 에너지 비용이 증가하여 공장 입장에서는 부담이 되고 있는 상황입니다. 따라서 공장에서는 에너지 절감을 위해 다양한 활동을 수행하고 있고, 그 노력의 일환으로 데이터 분석을 통한 에너지 사용 절감안을 도출하고자 합니다. ‘23년 1년 프로젝트로 기획됐고 2월부터 시작해 현재 진행중에 있습니다. 보안 상 디테일한 부분을 얘기하긴 어렵지만 어떻게 데이터 분석 프로젝트를 진행하고 있는지 간략하게만 기록하겠습니다.   에너지 절감을 위하여 다양한 접근 방법이 있겠지만 우리는 다음과 같은 방식으로 단계로 데이터 분석 프로젝트를 진행했습니다.]]></summary></entry><entry><title type="html">[회고록] 23년 5월 1주차 회고록</title><link href="http://localhost:4000/data/weekly_memoir_4/" rel="alternate" type="text/html" title="[회고록] 23년 5월 1주차 회고록" /><published>2023-05-07T00:00:00+09:00</published><updated>2023-05-08T01:24:00+09:00</updated><id>http://localhost:4000/data/weekly_memoir_4</id><content type="html" xml:base="http://localhost:4000/data/weekly_memoir_4/"><![CDATA[<p>  이번 회고록은 조금은 다른 내용에 대해서 적어보고자 합니다. 일과 관련된 얘기지만 업무나 기술, 테크와 관련된 얘기가 아닌 마음가짐?에 대한 얘기를 적어보고자 합니다.
<br /><br />
  4월 초부터 최근 1달간은 개인적인 사정으로 멘탈이 굉장히 좋지 않았습니다. 무던한 성격이라 웬만한 일에는 감정적으로 동요가 되지 않는 편인데도 불구하고 최근에는 감정적으로 좋지 않았습니다.
멘탈도 많이 흔들리고, 아무래도 잡생각과 고민이 많아지다보니 업무 중에도 집중하기가 쉽지 않았습니다. 업무 중에 다른 생각이 들때마다 “이러면 안돼, 집중해야 해, 프로다운 모습을 보여야 해”하며
마음을 다잡아봤지만, 생각처럼 쉽지 않았습니다. 심적으로 편하지 않은 상태다보니 육체적인 면에도 안좋은 영향을 끼쳤습니다. 육체적으로 피로해지니 심적으로도 더 안 좋아지구요. 악순환에 빠진 상태였습니다. 
차라리, 아예 다른 생각을 못하도록 일이 미친듯이 많았으면 집중할 수 있지 않을까란 생각도 해봤습니다. 이렇게 업무에 온전히 집중하지 못한 상태로 시간을 보냈습니다. 그러다가 외부적으로 상황이 해결되고 나니 
차츰 좋아졌고 다시 정상궤도로 올라올 수 있었습니다. 
<br /><br />
  이러한 시간을 겪다보니 개인적으로 느낀 점이 많았습니다.</p>
<blockquote>
  <ol>
    <li>내가 컨트롤 할 수 없는 외부 상황에 의해서 영향을 받을 수 있다는 점</li>
    <li>멘탈적으로 혼란스러운 시기에 어떻게 하면 안정적으로 업무에 집중할 수 있는지에 대한 고민</li>
  </ol>
</blockquote>

<p>  정리하자면, 어떻게 하면 <strong>마인드 컨트롤</strong>을 잘 할 수 있을까에 대한 고민인 것 같습니다. 이 고민은 앞으로도 쭉 해야할 고민일 거라 생각합니다. 특히 내 스스로의 의지로 이 상황을 해결한 것이 아니라
외부적으로 해결되고 나서 안정된 점을 보았을 때 더욱 고민이 깊어졌습니다. 왜냐하면 앞으로 긴 인생을 살면서 스스로 어찌할 수 없는 상황이 분명히 생길 것이고 심지어 더 큰 문제를 맞닦뜨리게 될 수도 있다고 생각했습니다.
<br /><br />
  하나 긍정적인 점이 있다면, 그것은 이렇게 멘탈적으로 흔들릴 수 있는 스스로를 알게 됐고 인정하게 됐다는 점입니다. 이전까지만 해도 진심으로 저는 제가 강철 멘탈을 지닌 줄 알았지만, 전혀 그렇지 않을 수 있다는 것을 
알았습니다. 그렇지 않을 수 있다는 점을 받아들이고 나니 앞으로 이러한 문제가 발생할 것을 대비해야 겠다는 마음이 들었습니다.
<br /><br />
  개인적으로 도움이 많이 된 방법은 <strong>1. 운동하기</strong>와 <strong>2. 가깝고 의지할 수 있는 사람들과 시간 보내기</strong>가 있었습니다. 운동같은 경우에는 러닝이 참 도움이 많이 됐습니다. 언제나 지치고 우울감이 들때면, 억지로라도 
러닝을 하러 나갑니다. 한강변을 따라 야경을 보면서 러닝을 하다보면 숨이 차기 시작하면서 잡생각이 없어지고 몸이 풀리면서 기분도 한결 나아집니다. 다음으로는 제가 사랑하는 사람들을 만나 대화하고 시간을 보내는 것 입니다.
특히, 부모님을 찾아뵈어 만나면 그냥 그대로 위안이 되고 의지가 되더군요. 그렇게 주말을 보내면 재충전이 되고 더 나은 한주를 보낼 수 있었습니다.
<br /><br />
  반대로 지양해야 될 것은 지나친 음주였습니다. 멘탈이 안좋다보니 지인들과 술자리가 잦아졌습니다. 초반에는 기분도 풀리고 즐겁고 좋았습니다. 다만, 무의미한 술자리가 잦아지게 되면서 점점 숙취로 인한 피로는 쌓여가고 
반동으로 오는 우울감까지 더해지면서 상황이 나아지진 않더군요. 뭐든지 적당히가 좋은 것 같습니다.
<br /><br />
  마지막으로 다음에도 이런 일이 발생한다면 어떻게 하면 좋을까 생각했던 것이 있습니다. 바로, <strong>문제가 되는 상황을 최대한 빠르게 해결하는게 답</strong>일 수도 있겠다 생각이 들었습니다. 나를 힘들게 하는 문제가 있다면 
더 적극적으로 해결해서 문제를 치울 수 있다면 그렇게 하는게 최선이란 생각이 들었습니다. 보통 업무를 함에도 우선순위를 정하듯이, 조금 더 큰 범위에서 우선순위를 정해보는 것이라 생각합니다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="Memoir" /><summary type="html"><![CDATA[  이번 회고록은 조금은 다른 내용에 대해서 적어보고자 합니다. 일과 관련된 얘기지만 업무나 기술, 테크와 관련된 얘기가 아닌 마음가짐?에 대한 얘기를 적어보고자 합니다.   4월 초부터 최근 1달간은 개인적인 사정으로 멘탈이 굉장히 좋지 않았습니다. 무던한 성격이라 웬만한 일에는 감정적으로 동요가 되지 않는 편인데도 불구하고 최근에는 감정적으로 좋지 않았습니다. 멘탈도 많이 흔들리고, 아무래도 잡생각과 고민이 많아지다보니 업무 중에도 집중하기가 쉽지 않았습니다. 업무 중에 다른 생각이 들때마다 “이러면 안돼, 집중해야 해, 프로다운 모습을 보여야 해”하며 마음을 다잡아봤지만, 생각처럼 쉽지 않았습니다. 심적으로 편하지 않은 상태다보니 육체적인 면에도 안좋은 영향을 끼쳤습니다. 육체적으로 피로해지니 심적으로도 더 안 좋아지구요. 악순환에 빠진 상태였습니다. 차라리, 아예 다른 생각을 못하도록 일이 미친듯이 많았으면 집중할 수 있지 않을까란 생각도 해봤습니다. 이렇게 업무에 온전히 집중하지 못한 상태로 시간을 보냈습니다. 그러다가 외부적으로 상황이 해결되고 나니 차츰 좋아졌고 다시 정상궤도로 올라올 수 있었습니다.   이러한 시간을 겪다보니 개인적으로 느낀 점이 많았습니다. 내가 컨트롤 할 수 없는 외부 상황에 의해서 영향을 받을 수 있다는 점 멘탈적으로 혼란스러운 시기에 어떻게 하면 안정적으로 업무에 집중할 수 있는지에 대한 고민]]></summary></entry><entry><title type="html">[회고록] 23년 4월 3주차 회고록</title><link href="http://localhost:4000/data/weekly_memoir_3/" rel="alternate" type="text/html" title="[회고록] 23년 4월 3주차 회고록" /><published>2023-04-23T00:00:00+09:00</published><updated>2023-04-24T04:49:00+09:00</updated><id>http://localhost:4000/data/weekly_memoir_3</id><content type="html" xml:base="http://localhost:4000/data/weekly_memoir_3/"><![CDATA[<p>  회고록을 매주 작성하겠다고 다짐했으나 이러저러한 이유로 미루고 미루다 이제야 짬을 내서 작성하네요. 한 주를 글을 쓰며 마무리하는 루틴이 습관이 될 수 있도록 다시 열심히 써보겠습니다! <br /><br />
  최근, 제가 예전 프로젝트에서 R을 활용해 개발하고 운영중인 알고리즘에 몇 가지 이슈가 생겨 해결하고 있습니다.</p>

<blockquote>
  <ol>
    <li><strong>알고리즘 운영 서버 이관</strong>
      <ul>
        <li>운영 서버에서 개발 서버로</li>
      </ul>
    </li>
    <li><strong>데이터베이스 계정정책 변경</strong>
      <ul>
        <li>1개의 root 계정 공유(모든 권한) -&gt; 인원별 계정 생성 및 권한 축소</li>
      </ul>
    </li>
  </ol>
</blockquote>

<h2 id="1-서버-이관">1. 서버 이관</h2>
<p>  이전에는 저희가 운영하고 있는 서버에서 알고리즘이나 ML 모형을 개발하고 운영했다면, 개발 서버에서 운영하도록 팀 내 정책이 변경됐습니다. 따라서 기존에 운영서버에 있던 알고리즘을 개발 서버로 이관해야 해서 준비중에 있습니다. 현재 가장 이슈가 될 것으로 예상되는 문제는 R과 패키지에 버전 관리입니다. 기존에는 각각 다른 서버에서 개발하고 운영하다보니 알고리즘과 ML모형의 R과 패키지 버전이 모두 제각각인 상황입니다. 이러한 상황에서 한 서버에 모든 알고리즘과 ML모형을 이관하려다보니 버전 관리에 어려움이 있을거라 예상됩니다. 서버 이관은 차후 실제로 적용해보고 생겨난 일들은 다음 회고록에 작성할 수 있도록 하겠습니다.<br /><br /></p>

<p>  문득 든 생각인데, 개발 서버에서 알고리즘이나 ML모형을 운영하는게 맞는걸까요? 현재 서비스 중인 운영서버에 자원을 매우 타이트하게 사용하다보니 부하를 줄이기 위해서 개발서버로 이관하려고 하는건데, 아무래도 개발서버다보니 안정성 면에서 취약하지 않을까 하는 걱정이 문득 듭니다. 개발하다가 뻑나서 서버를 재부팅하게 되면, 하필 그 타이밍이 알고리즘/ML모형 스케쥴링 시간이라면?? 이래저래 걱정이 됩니다.</p>

<h2 id="2-데이터베이스-계정정책-변경">2. 데이터베이스 계정정책 변경</h2>
<p>  기존 데이터베이스의 계정을 루트 계정 하나를 팀원들이 모두 공유해서 활용하는 방식에서 각자 계정을 발급하여 사용하도록 정책이 변경됐습니다. 개인별로 발급된 계정은 기존 루트 계정에 비해 권한이 많이 축소되어 기존 방식으로는 알고리즘 운영이 불가능하고 수정이 불가피했습니다. db를 관리하고 있는 담당자분께서 rest api 호출하는 방식을 권유했고, 그에 맞게 코드를 수정하고자 했습니다.<br /><br /></p>

<p>  처음에는 csv 형태로 불러와 구분자로 나누어 데이터 프레임으로 변형하고자 했습니다. 하지만 데이터가 이쁜(?) 형태로 오지 않아 한줄한줄 for문을 사용해 처리하다보니 너무 시간이 많이 걸리는 문제가 생겼습니다. 그래서 쿼리를 날릴 때 전체 테이블 중 사용하고자 하는 fields만 불러와 데이터 사이즈를 줄이는 방식으로 변경했습니다. <br /><br /></p>

<p>  문제는 예상치 못한 곳에서 터졌는데 바로 쿼리에 포함된 <strong>“한글”</strong> 때문이었습니다. 아마 인코딩 문제로 추측은 되지만 정확하게 밝혀내진 못했습니다. 다만, 쿼리에 한글이 포함되어 있으니 다 깨진 상태로 날아갔고 데이터가 들어오지 않는 문제가 발생했습니다. 한글을 URL 인코딩하여 시도해봤는데도 해결되지 않았습니다. 이 문제를 데이터 엔지니어 분께 알렸고, 우린 곧 어떻게 문제를 해결할까 논의했습니다.</p>
<blockquote>
  <ol>
    <li><strong>raw data table의 컬럼명을 영문으로 변경</strong>
      <ul>
        <li>컬럼명을 변경하면 해당 데이터를 활용하는 모든 프로그램에서 변경해야 하기에 불가</li>
      </ul>
    </li>
    <li><strong>csv 대신 html, xml 형식으로 가져오기</strong>
      <ul>
        <li>크롬 브라우저에서 rest api를 호출했을 때, 데이터가 정상적으로 표시되는 것을 확인함</li>
      </ul>
    </li>
  </ol>
</blockquote>

<p>  오! 2번에서 데이터가 정상적으로 표시되는 것을 확인했을 때, R로 바로 적용해봐야겠다 생각했고 html 형식으로 불러왔습니다. 하지만, 이상하게 R에서 실행했을 때는 정상적으로 데이터를 가져오지 못했습니다. 인코딩도 바꿔보고 이것저것 다 해봤는데 안되더군요. 그렇게 머리 쥐어뜯으며 코드를 짜다가 옆에서 그런 제 모습을 지켜보던 동료분이 한마디 했습니다.</p>
<blockquote>
  <p><strong>“그냥 다 불러와서 하면 되지 않아요? 보니깐 데이터 사이즈가 크지 않은데 문제 없을 것 같아요~”</strong></p>
</blockquote>

<p>  그 순간 머리가 띵했습니다. 실제로 해보니 생각보다 빠르게 잘 처리됐습니다. 당장 발생한 문제를 해결해야 겠다는 생각에 매몰되어 원래 목적을 잊어버렸던 겁니다. 데이터를 잘 불러오기만 하면 되는 것을! 물론 한글 문제를 해결했다면 더 좋았겠지만, 지금은 제 주 프로젝트에 더 큰 시간과 에너지를 쏟아야 할 상황이라 이것만 물고 늘어질 수는 없는 상황이었습니다. 한글이 깨지는 것은 긴 시간을 갖고 고민해봐야겠습니다! <br /><br /></p>

<p>  너무 경직된 생각과 태도로 질질 끌기 보다는 문제가 안 풀릴 때는 한 발자국 물러서서 보는 것도 좋을 것 같다는 생각을 해봅니다. 문제를 해결하는 방식에는 여러가지가 있을 겁니다. 주변 분들에게 도움을 요청하는 것도 훌룡한 방법일테고, 돌아가는 방법도 좋은 방법일 겁니다. 앞으로는 너무 한 문제에 매몰되지 말고 큰 목적을 먼저 생각해 봐야겠습니다. 생각보다 시간을 많이 쏟았거든요 ㅎㅎ 마지막으로 데이터 엔지니어분과 제가 코드 스크립트를 보면서 고민할 때, 뒤로 지나가시던 부장님의 말씀을 전하며 글을 마치겠습니다.</p>
<blockquote>
  <p>야, 코드 짤 때 한글 적지마~ 다 빼!</p>
</blockquote>

<p>ㅎㅎ</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="Memoir" /><summary type="html"><![CDATA[  회고록을 매주 작성하겠다고 다짐했으나 이러저러한 이유로 미루고 미루다 이제야 짬을 내서 작성하네요. 한 주를 글을 쓰며 마무리하는 루틴이 습관이 될 수 있도록 다시 열심히 써보겠습니다!   최근, 제가 예전 프로젝트에서 R을 활용해 개발하고 운영중인 알고리즘에 몇 가지 이슈가 생겨 해결하고 있습니다.]]></summary></entry><entry><title type="html">[회고록] 23년 3월 3주차 회고록</title><link href="http://localhost:4000/data/weekly_memoir_2/" rel="alternate" type="text/html" title="[회고록] 23년 3월 3주차 회고록" /><published>2023-03-17T00:00:00+09:00</published><updated>2023-03-18T01:01:00+09:00</updated><id>http://localhost:4000/data/weekly_memoir_2</id><content type="html" xml:base="http://localhost:4000/data/weekly_memoir_2/"><![CDATA[<p>  출장 업무를 마치고 KTX를 타고 서울로 올라가며 한 주를 마무리하고 있습니다. 출장길은 언제나 고되지만, 좋은 결과를 얻어갈 수 있다면 나름 다닐만?하다고 생각됩니다. 이번 회고록에서는 다음 2가지 얘기를 해보고자 합니다.</p>
<blockquote>
  <ol>
    <li>커뮤니케이션: 데이터 분석가와 클라이언트 간 회의에 대하여</li>
    <li>데이터 리터러시</li>
  </ol>
</blockquote>

<p>회고록이다 보니 위 2가지 에 대해 개념을 적는 글이 아니고 업무를 하면서 느낀 점에 대해서 짧게 회고하겠습니다!</p>

<h2 id="1-커뮤니케이션">1. 커뮤니케이션</h2>
<p>  분석 컨설팅 업무의 특성상 분석 결과 공유를 위해 고객과의 정기적인 미팅이 이루어집니다. 사담이지만, 오늘 출장길도 고객과의 미팅을 위해서 다녀오는 길이네요. 오늘 오전 1건, 오후 1건 총 2건의 회의를 진행했는데 각각 양상이 사뭇 달랐습니다. 각 회의에서 개인적으로 재밌게 느꼈던 점들을 짚어보겠습니다.</p>
<h3 id="11-자료시각적-표현의-중요성">1.1 자료(시각적 표현)의 중요성</h3>
<p>  오전 회의에서는 분석 결과를 토대로 분석가와 클라이언트 간의 진지한 토론과 논의가 오갔습니다. 여기서 관건은 우리가 분석한 결과를 고객이 제대로 이해할 수 있게 얼마나 명료하게 잘 전달하는 가 였습니다. 현재 클라이언트 데이터 분석 프로젝트는 처음이기에 아직 분석 이해도가 상대적으로 낮기에, 원활한 미팅을 위해서는 오해없이 우리의 분석 내용을 이해할 수 있도록 잘 전달해야했습니다. 말을 잘하면 클라이언트가 잘 받아들일까요? 아닙니다. 여기서 중요한 것은 데이터 분석에 대한 이해가 없는 클라이언트도 쉽게 이해할 수 있도록 분석 내용을 논리적으로 정리하고 <strong>시각적으로 표현</strong>하는 것입니다. 말로 30분 얘기하는 것보다 중요한 포인트를 제대로 짚어낸 차트 하나가 더 이해하기 쉽습니다. <br /><br />
  그렇다면 좋은 자료는 어떤 자료일까요? 저도 아직 잘 모릅니다. 다만, 제 상사와 선배님들, 주변 동료에게 배운 것들은</p>
<blockquote>
  <ol>
    <li>누가 봐도 이해하기 쉬워야 한다.</li>
    <li>논리적으로 치밀해야 한다.</li>
    <li>꼼꼼해야 한다.</li>
    <li>애매하거나 쓸데없는 내용은 과감히 지워야 한다.</li>
  </ol>
</blockquote>

<p>정도가 기본인 것 같습니다. 제 팀장님은 1번을 특히 강조합니다. 제가 분석한 내용을 자료로 작성하여 검토를 요청드리면 내용이 어려우니 조금 더 쉽게 풀어쓰라는 피드백을 종종 받습니다. 사실 초반에는 속으로는 “아무리 그래도 이 정도 내용도 이해 못할까?”란 생각을 했는데, 정말 오만한 생각이었다는 것을 깨달았고 많이 반성하고 있습니다. 클라이언트는 데이터 분석에 대한 이해도가 높지 않습니다. 분석가가 도메인 지식이 얕은 것처럼 당연한 것입니다. 그렇기에 쉽게 써야 합니다. 그리고 자료가 어렵다는 말은 돌려 말하면 이 자료를 봤을 때, <strong>무엇을 말하려고 하는 지 모르겠다</strong>일 것 같습니다. 또 해보면 어려운 내용을 쉽게 풀어 쓴다는 게 보통 쉬운 일이 아닙니다. 그렇기에 자료를 잘 작성하는 분들을 보면 정말 대단하다 생각하며, 글쓴이 본인도 잘 하고자 열심히 고민하고 개선하려 하고 있습니다.</p>
<h3 id="12-컨센서스-합의">1.2 컨센서스 합의</h3>
<p>  오후 회의는 분석 내용보다는 프로젝트 방향성에 대한 컨센서스 합의에 대한 논의가 대부분이었습니다. 프로젝트를 하다보면 당연하게도 데이터 분석이 잘 안 풀릴 때가 있습니다. 그럴때면 클라이언트는 방어적으로 나오게 되며, 출구전략을 모색하고 앞으로 어떻게 이 프로젝트를 풀어갈지 궁금해합니다. 왜냐하면 클라이언트도 비용을 투자했기에 의미있는 성과를 만들어내야 하기 때문입니다. 이러한 상황에서 답을 못 찾았다하고 끝낼 순 없습니다. 이럴때 분석가의 역할은 다른 길을 제시하여 프로젝트가 나아갈 수 있도록 제시할 수 있어야 합니다. 이 과정에서 클라이언트와 컨센서스 합의가 필요합니다. 만약, 커다란 주제가 A라면, 그 아래 A-a, A-b, A-c라는 소주제가 있을 것입니다. 현재 A-a라는 과제가 지지부진하고 풀지 못했으니, A-b와 A-c로 접근해보자라고 제시할 수 있어야 합니다.<br /><br />
  중요한 것은 A-b, A-c에 대해서 서로 이해하는 바가 명확해야 합니다. 오늘도 그 부분에 대해서 양측이 합의하기 까지 많은 오해와 설전이 오갔습니다. 하지만 이런 과정이 없다면 프로젝트가 산으로 빠지고 분석가와 클라이언트 간 불신의 골이 깊어질 확률이 매우매우 높습니다. 아직 주니어인 저는 회의 시에 분석 결과에 대해서만 포커스를 맞춰 내용을 제대로 전달하고 검토하는 것에만 급급한 경향이 있습니다. 다만, 시니어 분들은 여기서 그치지 않고 이 프로젝트를 어떻게 풀어갈까 다음을 고민하더군요. 확실히 이러한 부분에서 시니어와 주니어의 경험과 역량의 차이가 느껴집니다. <br /><br /></p>

<h2 id="2-데이터-리터러시">2. 데이터 리터러시</h2>
<p>  가트너 리포트에서도 언급되었던 데이터 리터러시는 쉽게 얘기하면 <strong>데이터를 읽고 해석하고 이해하는 능력</strong>이라고 볼 수 있습니다. 저는 주로 팀장님과 같이  데이터 분석을 진행하는데 팀장님께선 제가 생각하지 못한 것들을 짚어주는 경우가 있습니다. 그렇게 다른 관점으로 보면, 새로운 아이디어가 나오고 새로운 분석 스토리가 생깁니다. 이렇듯이 같은 데이터를 봐도 다양한 방면으로 접근이 가능하며 인사이트를 뽑아내는 능력은 천차만별이며, 이 역량은 단순히 데이터 분석가에게 필요한 기술적인 역량과는 다르다 생각합니다. 코딩을 잘하고 모델링을 잘 한다고 데이터 리터러시 역량이 좋다고 볼 수 있을까요? 전 아니라고 봅니다. 이 부분에서 데이터 분석가와 ML모델 엔지니어와는 명확한 차이가 있다고 생각합니다. 데이터 분석가에게는 수 많은 데이터 속에서 필요한 데이터만 뽑아내어 조합할 수 있는 역량이 필요하며, 제대로 해석할 줄 알아야 합니다. 흔히 하는 실수로 데이터로 확인되는 것 이상으로 해석을 시도하는 경우가 있습니다. 데이터 분석가는 명확하게 데이터 기반으로 논리를 펼쳐야 하고, 그 이상을 시도했다가는 대부분 소설이 되는 경우가 많습니다.<br /><br />
  도메인 지식에 대한 이해가 깊다면 데이터로부터 의미있는 인사이트를 도출할 확률이 높습니다. 따라서 도메인 지식에 대한 공부가 필수적입니다. 대부분의 데이터는 도메인 영역에 메커니즘을 통해 해석되기 때문입니다. 하지만 제가 생각하는 궁극적인 데이터 분석가의 모습은 도메인 전문가가 닿지 못한 것을 풀 수 있는 것입니다. 우리의 역할은 클라이언트가 여태 풀지 못했던 문제를 데이터를 통해 풀어내는 것이기에 그 이상의 것을 제시할 줄 알아야 한다고 개인적으로는 생각합니다.</p>

<h2 id="3-맺음말">3. 맺음말</h2>
<p>이번 한 주는 정말 몰입해서 일했고 미팅도 긍정적으로 진행됐기에 개인적으로 참 뿌듯했던 한 주입니다. 회고록을 적고나니 참 데이터 분석가에게 필요한 것들이 많다 생각됩니다. 갓 입사했을 때에는 제게 요구하는 것이 많다는 생각도 했습니다. 데이터 핸들링, BI 개발, 운영, 데이터 분석, 자료 작성과 리포트, 컨설팅까지… 지금은 어느정도 적응이 됐지만 쉽지 않은 것은 사실입니다. 그래도 긍정적인 결과가 나와 클라이언트가 만족했을 때 저 개인적으로도 큰 보람을 느낍니다. 데이터 분석가 참 매력적인 직업이라 생각하며 이번 회고록도 마치도록 하겠습니다. 긴 글 읽어주셔서 감사합니다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="Memoir" /><summary type="html"><![CDATA[  출장 업무를 마치고 KTX를 타고 서울로 올라가며 한 주를 마무리하고 있습니다. 출장길은 언제나 고되지만, 좋은 결과를 얻어갈 수 있다면 나름 다닐만?하다고 생각됩니다. 이번 회고록에서는 다음 2가지 얘기를 해보고자 합니다. 커뮤니케이션: 데이터 분석가와 클라이언트 간 회의에 대하여 데이터 리터러시]]></summary></entry></feed>