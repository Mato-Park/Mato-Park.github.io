<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>끊임없이 성장하는 데이터 분석가</title>
    <description>조금씩 쌓아가다 보면 큰 산이 되겠지</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 08 Feb 2024 19:03:27 +0900</pubDate>
    <lastBuildDate>Thu, 08 Feb 2024 19:03:27 +0900</lastBuildDate>
    <generator>Jekyll v4.3.1</generator>
    
      <item>
        <title>[파이썬] 빠지기 쉬운 함정들. 이것만은 피하자!</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;이번 포스트는 파이썬을 사용하면서 빠지기 쉬운 함정들을 알아보고 어떻게 하면 이 함정들을 피할 수 있는지 정리해봤습니다. &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;이 포스트의 내용은 저자 Al Sweigart의 “클린 코드, 이제는 파이썬이다” 8장 내용임을 사전에 미리 밝힙니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  파이썬은 제가 가장 많이 사용하는 데이터 분석 도구 중 하나입니다. 사용하다 보면 종종 알 수 없는 warnings가 발생하곤 했지만 잘 모르기에 넘어가곤 했습니다. 아무래도 파이썬의 모든 작동원리를 알지 못하기 때문입니다. 이 책을 읽으면서 그동안 발생했던 warnings의 의미, 모르고 지나쳤던 것들을 알 수 있었기에 정리해보고자 합니다!&lt;/p&gt;

&lt;h1 id=&quot;1-루프문-진행-중에는-리스트에-아이템을-추가삭제하지-말자&quot;&gt;1. 루프문 진행 중에는 리스트에 아이템을 추가/삭제하지 말자&lt;/h1&gt;
&lt;p&gt;  리스트를 반복하는 루프문 내에서 리스트에 아이템을 추가/삭제하는 경우에는 버그가 발생할 수 있습니다. 책에 실린 예제와 함께 보겠습니다. &lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;clothes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;pants&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;red sock&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clothing&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clothes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 리스트 반복
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;sock&apos;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clothing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# &apos;sock&apos; 문자열 찾기
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;clothes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clothing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 일치하는 clothing 리스트에 추가
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Added a sock:&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clothing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실제로 위 코드를 파이썬에서 실행하게되면 프로그램이 무한정 돌게 됩니다. 왜 그렇게 되는 걸까? 루프문이 처음 동작할 때는 clothing이 pants이므로 리스트에 추가되지 않고 리스트에 다음 아이템으로 넘어가게 됩니다. 두 번째 반복할 때, 리스트에 red sock이 추가되고 clothes 리스트는 [‘pants’, ‘red sock’, ‘red sock’]으로 새 아이템이 추가됩니다. 하지만 for 문이 시작할 때 리스트에는 2개의 아이템이 있어서 for 반복문이 2번만 수행될 것 같지만 리스트에 새로운 아이템이 추가되면서 for 반복문은 다음 아이템에 대해 수행되게 됩니다. 이런식으로 리스트에 아이템이 무한하게 추가되고 for 반복문 또한 무한으로 돌게되는 것입니다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  그렇다면 어떻게 하면 될까? 다음과 같이 코드를 수정하게 되면 더 이상 위와 같은 에러는 발생하지 않게 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;clothes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;skirt&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;red sock&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;blue sock&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;newClothes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clothing&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clothes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;sock&apos;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clothing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newClothes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clothing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# clothes 리스트가 아닌 newClothes 리스트에 아이템을 추가
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clothes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newClothes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# newClothes에 있는 아이템들을 기존 clothes리스트에 추가하기
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  조금 번거롭긴 하지만 새로운 리스트 객체를 생성한 다음 아이템을 추가해줍니다. 그 다음 기존 리스트에 생성된 리스트에 아이템을 추가해주면 원하는 결과를 얻을 수 있게 됩니다.
&lt;br /&gt;
  또한 앞서 말한 것처럼 리스트를 반복할 떄 아이템을 삭제하는 것도 지양해야합니다. 역시 예를 보고 설명하겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;lion&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# dog가 아닌 동물들을 리스트에서 제거
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;del&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  animals의 최종 결과물을 보면 [‘dog’, ‘dog’, ‘lion’, ‘dog’]가 남게 됩니다. ‘lion’ 아이템이 제거됮 않고 살아있네요. 왜 그런걸까요? for 반복문에 세번째 실행될 때, 리스트에서 ‘cat’이 제거되고 [‘dog’, ‘dog’, ‘lion’, ‘dog’]가 남게 됩니다. 다음번 4번째 실행될 때, 반복자는 3이되므로 리스트에서 ‘lion’을 가져오는 것이 아니라 건너띄고 ‘dog’를 가져오게 되는 겁니다. 따라서 ‘lion’이 제거되지 않고 남아있게 됩니다. 위와 같은 에러를 피하기 위해서는 아래와 같이 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;lion&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dogs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dogs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dogs&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 기존 리스트를 교체함
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 혹은 리스트 컴프리헨션을 사용할 수 있다.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-가변-값을-복사할-때는-항상-copycopy를&quot;&gt;2. 가변 값을 복사할 때는 항상 copy.copy()를!&lt;/h1&gt;
&lt;p&gt;  파린이 시절 가장 이해 안됐던 warning중에 하나가 dataframe객체를 다루다가 발생하는 SettingWithCopyWarning이었습니다. 데이터 전처리 작업을 하다보면 dataframe 새로운 변수에 할당해서 수정을 하게되는 경우가 있는데 그때마다 warning이 발생했습니다. 왜 이런 warning이 발생하게 될까요? 파이썬의 할당문은 절대 객체를 복사하지 않습니다. 그저 기존 객체에 대한 &lt;strong&gt;참조&lt;/strong&gt;를 복사하기에 발생하게 됩니다. (여기에 파이썬은 chained 연산을 허용하기에 발생하게 되는데 여기서 다루진 않겠습니다.) 아래 예를 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;lion&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;tiger&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;LION&apos;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# animal 리스트 아이템을 수정했습니다. name 리스트에도 영향을 미칠까요?
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  animal 리스트에 대해서만 수정을 했지만 실제로 확인해보면 name 리스트의 아이템도 수정된 것을 확인할 수 있습니다. 앞서 말헀듯이 할당문은 객체에 대한 참조를 복제하는 것이기에 animals와 name모두 컴퓨터의 메모리에 동일한 리스트 객체를 참조하고 있기 때문입니다. (함수 호출에 전달된 가변 객체도 동일한 원리가 적용됩니다.)&lt;br /&gt;&lt;br /&gt;
  따라서 위와 같은 에러를 피하기 위해서는 반드시 &lt;strong&gt;copy.copy() 메소드를 활용해 객체의 복사본&lt;/strong&gt;을 만들어야 합니다! copy.deepcopy() 메소드는 가변 객체 내에 있는 모든 가변 객체를 복사할 수 있습니다. deepcopy()는 약간 느리지만 모든 가변 객체에 대해 복사하기 때문에 더 안전하다는 장점이 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;3-기본-인수에-가변-객체는-사용-x&quot;&gt;3. 기본 인수에 가변 객체는 사용 X&lt;/h1&gt;
&lt;p&gt;  파이썬 프로그래밍에서 함수를 정의할 때, 파라미터에 대해 기본 인수(default argument)를 설정할 수 있습니다. 기본 인수가 설정되어 있으면 함수를 실행할 때 인수를 입력하지 않으면 기본 인수를 사용해 함수가 실행되게 됩니다. 중요한 것은 함수를 정의할 때, 리스트나 딕셔너리 같은 가변 객체를 기본 인수로 설정해서는 안 된다는 것입니다. 가변 객체를 기본 인수로 사용하면 미묘한 버그가 발생할 수 있는데 예를 들어 설명해보겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addAnimals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;animal_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal_list&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;myAnimal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addAnimals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;bird&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myAnimal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addAnumals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;pig&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# myAnimal 리스트는 [&apos;cat&apos;, &apos;dog&apos;, &apos;bird&apos;, &apos;pig&apos;]가 됩니다. 
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  위 예제에서, 기본 인수로 설정된 리스트([‘cat’, ‘dog’])는 언제 생성되는 것일까요? 함수를 호출할 떄마다 새로운 리스트 객체가 생성되는 것이 아니라 맨 처음 함수를 정의할 때 리스트 객체가 생성되게 됩니다. 따라서 이 addAnimals 함수를 호출할 때마다 리스트 객체를 재사용하게 됩니다. 따라서 가변 객체를 기본 인수로 사용하는 것은 지양해야 합니다. 하지만 만약 기본 인수로 설정해야 할 때 어떻게 하면 될까요? 바로 None으로 설정하는 것입니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addAnimals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal_list&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;animal_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;animal_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal_list&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  위와 같이 함수를 정의하면 함수를 호출할 때마다 리스트를 새롭게 생성하게 됩니다.&lt;/p&gt;

&lt;h1 id=&quot;4-문자열-연결-적절하게-하기&quot;&gt;4. 문자열 연결 적절하게 하기!&lt;/h1&gt;
&lt;p&gt;  파이썬에서 문자열은 불변 객체로 문자열을 수정하는 것처럼 보이는 코드도 실은 새로운 문자열을 생성합니다. f-문자열 역시 새로운 문자열 객체를 생성하게 됩니다. 문제는 수 많은 문자열을 연결하게 되면 프로그램이 매우 느려질 수 있습니다. 다음과 같은 예를 봅시다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;finalString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&apos;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;finalString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;mato &apos;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  위 루프문은 10만 번을 반복하면서 새로운 문자열 객체를 생성하고 버리는 것을 반복하면서 엄청난 메모리 낭비가 발생하게 됩니다. 따라서 문자열을 만드는 파이썬다운 방법은 아래와 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;finalString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;finalString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;mato&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;finalString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos; &apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;finalString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  리스트 객체에 값을 반복하여 추가한 다음 문자열의 join 메소드를 활용하여 문자열 객체를 생성해줍니다. 실제로 프로그램을 실행해 런타임을 비교하면 굉장히 큰 시간 차이가 발생하게 되는 것을 알 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;5-sort가-알파벳-순으로-정렬할까&quot;&gt;5. sort()가 알파벳 순으로 정렬할까?&lt;/h1&gt;
&lt;p&gt;  파이썬에서 sort() 방식은 알파벳 정렬이 아닌 아스키 정렬을 따릅니다. 따라서 영어 알파벳의 대문자의 코드포인트(정수)가 소문자의 코드포인트 보다 작습니다. 그래서 알파벳을 정렬하면 대문자 Z가 소문자 a보다 앞에 오게 됩니다. 만약, 알파벳 정렬을 하려면 str.lower 메소드를 key 파라미터에 전달해주면 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;letters&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;z&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;a&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;Z&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;letters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lower&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# [&apos;A&apos;, &apos;a&apos;, &apos;z&apos;, &apos;Z&apos;]로 정렬됨
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;6-부동소스는-완벽하게-정확할까&quot;&gt;6. 부동소스는 완벽하게 정확할까?&lt;/h1&gt;
&lt;p&gt;  컴퓨터는 1과 0의 이진수 시스템 자릿수만 저장할 수 있습니다. 따라서 우리가 자주 사용하는 십진수의 수를 표시하기 위해서는 수의 대응하는 이진수로 변환해야 합니다. 보통 이 과정은 우리들에게 보여지지 않습니다. 재밌는 것은 부동소수의 표현이 항상 정환한 것은 아니라는 것입니다. 아래 유명한 예를 보시죠.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mf&quot;&gt;0.3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  놀랍게도 False가 반환됩니다. 실제로 0.1 + 0.1 + 0.1은 0.300000000004를 반환합니다. 이 요상한 덧셈 결과는 컴퓨터가 부동소수를 표현하고 다루는 방식에 의해 야기되는 반올림 에러(rounding error)의 결과입니다. 이는 비단 파이썬만의 문제는 아닙니다(CPU에서 실행되는 모든 언어에서 동일합니다!). 또 하나 신기한 예는, 기술적인 이유로 2^53보다 큰 모든 숫자를 나타낼 수 없습니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;53&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;53&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  앞서 얘기했듯이 2^53보다 큰 숫자를 표현할 수 없기에 True가 반환됩니다. 만약, 과학이나 혹은 재무 계산을 위해 정확한 정밀도가 필요하다면 decimal 모듈을 사용하면 됩니다. 비록 속도는 조금 느릴 수 있더라도 decimal 객체는 부동소수 값을 정확하게 대체합니다. decimal.Decimal(‘0.1’)은 정확한 숫자 0.1을 나타내는 객체를 생성합니다.&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;7--는-연달아-쓰지-말기&quot;&gt;7. != 는 연달아 쓰지 말기!&lt;/h1&gt;
&lt;p&gt;  논리 연산을 할 때, 논리 연산자를 연달아 쓰곤 하지만 부등 연산자(!=)는 연달아 쓰면 안 됩니다. 아래 예를 들어보겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  위 논리 연산의 값은 어떻게 될까요? 놀랍게도 False가 아닌 True가 반환됩니다. 눈치채신 분도 계시겠지만 a != b != c는 (a != b) and (b != c) and (a != c)가 아니라 (a != b) and (b != c)입니다. 직관적으로는 세 값이 같아야지만 True일 것 같지만 그렇지 않습니다.&lt;/p&gt;

&lt;h1 id=&quot;8-단일-아이템-튜플에는-쉼표를&quot;&gt;8. 단일 아이템 튜플에는 쉼표를!&lt;/h1&gt;
&lt;p&gt;  코드에 튜플 값을 쓸 때는 단일 아이템만 포함돼도 쉼표(,)가 꼭 필요합니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# c가 반환됨
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# cat이 반환됨
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  쉼표 하나 차이로 달라지게 되는데, 쉼표가 없으면 (‘cat’)은 문자열 값으로 평가되기 때문입니다.&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;9-마치며&quot;&gt;9. 마치며…&lt;/h1&gt;
&lt;p&gt;  이 장에서 다룬 내용들은 어찌보면 사소할 수 있는 내용들입니다. 하지만 만에 하나라도 프로그램을 작성하다가 이런 문제와 마주친다면 쉽게 버그를 찾아내기 어려울 수 있겠죠. 사소하더라도 이런 사항들을 알아둔다면 디버깅하는 데 매우 큰 도움이 될 수 있을 거라 생각합니다.&lt;/p&gt;
</description>
        <pubDate>Tue, 06 Feb 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/python/clean_code8/</link>
        <guid isPermaLink="true">http://localhost:4000/python/clean_code8/</guid>
        
        <category>Python</category>
        
        <category>Coding</category>
        
        <category>Review</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>[파이썬] 파이썬 프로그래밍 용어</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;이번 포스트는 파이썬을 사용하면서 알아두면 좋은 용어들을 정리한 포스트입니다. 아래 키워드를 사용해 검색해 보시면 됩니다. &lt;br /&gt;
프로그래밍 언어, 인터프리터, 리터럴, 키워드, 객체, 값, 인스턴스, 아이디, 아이템, 가변, 불변, 인덱스, 키, 해시, 컨테이너, 시퀀스, 매칭, 집합, 이중 밑줄 메소드, 모듈, 패키지, 호출 가능 객체, 문, 표현식, 블록, 절, 바디, 변수, 속성, 함수, 메소드, 반복 가능 객체, 반복자, 구문, 런타임, 의미 에러, 파라미터, 인수, 타입 강제변환, 캐스팅&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;이 포스트의 내용은 저자 Al Sweigart의 “클린 코드, 이제는 파이썬이다” 7장 내용임을 사전에 미리 밝힙니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  일하다 보면 용어를 정확하게 모르지만 대충 눈치껏 소통하는 경우가 꽤 많습니다. 알아들은 척 하고 나중에 몰래 찾아보기도 많이 했습니다. 사람, 조직마다 사용하는 용어가 조금씩 차이가 있겠지만 책을 읽으면서 중요하다 생각되는 용어들을
정리하고자 합니다.&lt;/p&gt;

&lt;h1 id=&quot;1-각종-용어-정의&quot;&gt;1. 각종 용어 정의&lt;/h1&gt;
&lt;p&gt;  이 장은 각 용어들의 정의와 용어 간의 차이점을 살펴보는 장입니다. &lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;파이썬 - 프로그래밍 언어 vs 인터프리터?&lt;/strong&gt;&lt;br /&gt;
  저는 보통 파이썬을 지칭할 떄, 프로그래밍 언어로서 파이썬을 의미합니다. 예를 들면, “나 요즘 파이썬 배우고 있어” 혹은 “파이썬으로 데이터 전처리 하고 모델링을 해”와 같이 말할 때 프로그래밍 언어로서 파이썬을 나타냅니다. 그렇다면 
인터프리터로써 파이썬은 무슨 의미일까요? 인터프리터로서 파이썬은 .py 파일의 스크립트 코드를 읽고 수행하는 실제 파이썬 소프트웨어를 가리킵니다. 이렇게 하면 구분이 더 명확합니다. 컴퓨터 공학 베이스가 깊은 분석가가 아닌 이상에야
이렇게까지 구분하여 사용하는 분들은 많이 없을거라 생각합니다. 다만, 알아두면 다른 눈치껏 알맞은 의미로 소통할 수 있지 않을까요?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;리터럴(literal)&lt;/strong&gt;&lt;br /&gt;
  리터럴은 사람이 직접 작성한 소스 코드 상에서 고정된 값을 나타내는 텍스트를 의미합니다. 예를 보면 이해가 더 쉽습니다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Zophie&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;  여기서 42라는 숫자와 ‘Zophie’라는 문자가 각각 정수와 문자열 리터럴입니다. age 변수는 리터럴이 아닌데 파이썬 소스 코드에 내장 데이터 형식이 아니기 때문입니다.&lt;br /&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;리터럴 예시&lt;/th&gt;
          &lt;th&gt;데이터 타입&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;42&lt;/td&gt;
          &lt;td&gt;정수(integer)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;3.14&lt;/td&gt;
          &lt;td&gt;부동소수(Float)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;“Hello”&lt;/td&gt;
          &lt;td&gt;문자열(String)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;[]&lt;/td&gt;
          &lt;td&gt;리스트(List)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;{‘name’: ‘Mato’}&lt;/td&gt;
          &lt;td&gt;딕셔너리(Dictionary)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;b’\x41’&lt;/td&gt;
          &lt;td&gt;바이트(Byte)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;True&lt;/td&gt;
          &lt;td&gt;부울(Boolean)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;None&lt;/td&gt;
          &lt;td&gt;넌타입(NoneType)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;키워드&lt;/strong&gt;&lt;br /&gt;
  모든 프로그래밍 언어는 고유의 키워드가 있으며, 미리 특정된 목적으로 사양하기로 약속된 이름의 집합을 나타냅니다. 키워드는 항상 영문으로 표기하며 다른 언어로는 쓰이지 않습니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;and&lt;/td&gt;
          &lt;td&gt;continue&lt;/td&gt;
          &lt;td&gt;finally&lt;/td&gt;
          &lt;td&gt;is&lt;/td&gt;
          &lt;td&gt;raise&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;as&lt;/td&gt;
          &lt;td&gt;def&lt;/td&gt;
          &lt;td&gt;for&lt;/td&gt;
          &lt;td&gt;lambda&lt;/td&gt;
          &lt;td&gt;return&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;assert&lt;/td&gt;
          &lt;td&gt;del&lt;/td&gt;
          &lt;td&gt;from&lt;/td&gt;
          &lt;td&gt;None&lt;/td&gt;
          &lt;td&gt;True&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;async&lt;/td&gt;
          &lt;td&gt;elif&lt;/td&gt;
          &lt;td&gt;global&lt;/td&gt;
          &lt;td&gt;nonlocal&lt;/td&gt;
          &lt;td&gt;try&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;await&lt;/td&gt;
          &lt;td&gt;else&lt;/td&gt;
          &lt;td&gt;if&lt;/td&gt;
          &lt;td&gt;not&lt;/td&gt;
          &lt;td&gt;while&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;break&lt;/td&gt;
          &lt;td&gt;except&lt;/td&gt;
          &lt;td&gt;import&lt;/td&gt;
          &lt;td&gt;or&lt;/td&gt;
          &lt;td&gt;with&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;class&lt;/td&gt;
          &lt;td&gt;False&lt;/td&gt;
          &lt;td&gt;In&lt;/td&gt;
          &lt;td&gt;pass&lt;/td&gt;
          &lt;td&gt;yield&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;  이렇게 쓰고보니 익숙한 키워드가 많지만 아직 한 번도 사용하지 않은 키워도드 있네요. 뭐 쓰다보면 언젠가는 다 쓰겠죠 ㅎㅎ&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;객채, 값, 인스턴스, 아이디&lt;/strong&gt;&lt;br /&gt;
  파이썬 프로그래밍에서 객체(object)의 개념은 상당히 중요하고 반드시 이해해야 합니다. 파이썬에서 &lt;strong&gt;객체는 데이터를 표현하는 것이라고 보면 됩니다.&lt;/strong&gt; 조금 더 자세하게 객체에 대해서 살펴봅시다.&lt;br /&gt;&lt;br /&gt;
  모든 객체는 값(value), 아이디(identity), 데이터 타입(data type)이 있습니다. 예를 들어, 값이 42인 정수 객체가 있다고 생각해봅시다. 이 정수 객체의 값은 42로 객체가 나타내는 데이터가 됩니다. 중요한 것은 객체와 값은 동의어가 아닙니다. 다른 예를 들어보겠습니다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;moose&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;  여기서 변수 spam에는 리스크 데이터 타입의 객체가 저장된 것입니다. 그렇다면 이 변수의 값은 무엇일까요? 바로 [‘cat’, ‘dog’, ‘moose’] 리스트입니다. 그렇다면 여기서 이 리스트 데이터 타입의 객체가 저장된 spam에 아이디는 무엇일까요?
아이디는 유일한 정수로 아이디가 생성되면 id() 함수를 호출해서 변수의 아이디를 확인할 수 있습니다.&lt;/p&gt;
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 33805656 과 같이 정수로 된 아이디가 반환됩니다.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;이제 객체가 무엇이고 객체의 값, 아이디와 데이터 타입이 어떤지 구분이 가시나요?ㅎㅎ&lt;br /&gt;
  그리고 파이썬의 객체에는 &lt;strong&gt;중요한 특징&lt;/strong&gt;이 몇 가지 있습니다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;객체의 아이디가 만들어지면 프로그램이 실행되는 동안 변하지 않음&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;여러 식별자가 동일한 객체를 참조할 수 있음&lt;/strong&gt;&lt;br /&gt;
  동일한 객체를 참조하는 경우, 한 변수의 값을 수정하게되면 동일한 객체를 참조하는 변수의 값에도 영향이 미칩니다!&lt;br /&gt;
예를 보면서 더 구체적으로 살펴보겠습니다.
        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;Mato&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;Park&apos;&lt;/span&gt;
 &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
 spam 딕셔너리에 name 키에 해당하는 데이터를 수정했습니다.
 이때 eggs를 확인해보면 어떻게 될까요? eggs도 &apos;Park&apos;로 변하게 됩니다. 왜 이렇게 되는 걸까요??
 이유는 두 변수 다 동일한 객체를 참조하기 때문입니다.
 &quot;&quot;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;여기서 중요한 사실을 하나 알 수 있습니다. 바로 파이썬의 =(할당 연산자: assignment operator)는 항상 객체가 아닌 참조를 복사한다는 사실입니다. 이를 무시한다면 버그나 에러가 발생할 수 있으니 꼭 알아두시길 바랍니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;아이템&lt;/strong&gt;&lt;br /&gt;
  리스트나 딕셔너리처럼 컨테이너 객체 안에 있는 객체를 아이템(item) 또는 원소(element)라고 부릅니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;가변/불변 데이터 타입&lt;/strong&gt;&lt;br /&gt;
  파이썬 프로그래밍을 하다보면 mutable/immutable 이란 표현을 종종 마주하게 됩니다. 파이썬의 모든 객체는 값을 갖는데, 값의 변경 여부에 따라 가변 타입인지 불변 타입인지로 구분합니다. 아래 표는 몇 가지 객체를 가변/불변 데이터 타입으로 나눈 표입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;가변 데이터 타입&lt;/th&gt;
          &lt;th&gt;불변 데이터 타입&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;리스트(List)&lt;/td&gt;
          &lt;td&gt;정수(integer)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;딕셔너리(Dictionary)&lt;/td&gt;
          &lt;td&gt;부동소수(Float)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;집합(Set)&lt;/td&gt;
          &lt;td&gt;문자열(String)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;바이트배열(ByteArray)&lt;/td&gt;
          &lt;td&gt;부울(Boolean)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;배열(Array)&lt;/td&gt;
          &lt;td&gt;튜플(Tuple)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;바이트(Byte)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;  우선 불변 데이터 타입부터 살펴보겠습니다.&lt;/p&gt;
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;hello&apos;&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;goodbye&apos;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;  위에 예시를 보면 마치 문자열 객체의 값을 바꾼것 처럼 보입니다. 정말 그럴까요? id()함수를 호출해서 각각 id를 확인해보면 id가 다른 것을 확인할 수 있습니다. 앞서 할당 연산자 ‘=’는 단지 객체를 참조한다고 했습니다. 즉, spam이라는 변수가 ‘hello’라는 문자열 객체와 ‘goodbye’라는 문자열 객체를 참조할 뿐입니다. 즉, 문자열 객체의 값이 변한게 아니라 새로운 아이디를 가진 새로운 문자열 객체로 덮어쓴 것입니다. 다른 데이터 타입도 마찬가집니다. &lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;  이번에는 가변 데이터 타입을 살펴보겠습니다.&lt;/p&gt;
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;moose&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;snake&apos;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;  spam 변수의 리스트 객체를 만들어 할당하고, append() 메소드와 인덱싱에 의한 아이템 할당을 통해 리스트 값을 수정해줍니다. 과연 spam 변수의 id는 어떻게 됐을까요? 직접 해보면 알겠지만, 객체의 아이디는 동일합니다. 이와 같이 가변 객체는 변수 안의 값은 &lt;strong&gt;제저라에서 바꿔치기 방식&lt;/strong&gt;으로 수정이 가능합니다. 반면, ‘+’ 연산자를 활용해 리스트를 연결하게 되면 새로운 객체를 생선하게 됩니다. &lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;  반면, 불변 데이터 타입 객체 중 하나인 튜플은 조금 특이한 케이스 입니다. &lt;strong&gt;튜플&lt;/strong&gt;은 값들을 괄호로 묶는 연속된 불변 객체이며, 튜플의 아이템의 값은 수정이 불가능합니다. 하지만 특이한 점은 튜플 내부의 가변 객체는 수정이 가능합니다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인덱스, 키, 해시&lt;/strong&gt;&lt;br /&gt;
  리스트, 딕셔너리와 데이터프레임 같은 객체에 특정 값의 접근하도록 지정하는 정수값을 인덱스라 합니다. 파이썬에서 인덱스 연산자(index operator)는 대괄호 한 쌍 ‘[]’으로 구성되어 있고, 0 기반 인덱스를 사용하고 있습니다. 인덱스는 리스트와 같은 컨테이너 외에도 문자열 객체에서도 사용이 가능합니다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;moose&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# cat
&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# dog
&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;Hello, World!&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# H
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;  해시(Hash)는 값에 대해 일종의 지문 역할을 하는 정수입니다. 딕셔너리는 인덱스 연산자가 키이므로 해시 가능한 객체가 될 수 있습니다. 해시는 객체가 생성되고 난 후 절대 변하지 않으며, 객체의 값이 같다면 해시도 반드시 같습니다. 이 말인즉슨, 불변 데이터 타입 객체는 해시가능하지만, 리스트와 같은 가변 데이터 타입은 해시가 불가능합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;컨테이너, 시퀀스, 매칭, 집합 타입&lt;/strong&gt;&lt;br /&gt;
  &lt;strong&gt;컨테이너&lt;/strong&gt;란 여러 종류의 객체를 포함할수 있는 객체를 뜻한다. 예를 들면, 리스트와 딕셔너리와 같은 객체가 해당됩니다.&lt;br /&gt;
  &lt;strong&gt;시퀀스&lt;/strong&gt;는 정수 인덱스를 통해 접근 가능하며, 순서가 있는 값을 가진 컨테이너 타입의 객체를 뜻합니다. 문자열, 리스트, 튜플 등의 객체가 해당됩니다. 순서가 있어야지 정수 인덱스로 접근이 가능하겠죠?&lt;br /&gt;
  &lt;strong&gt;매핑&lt;/strong&gt;은 정수 인덱스 대신 키를 사용하는 컨테이너 타입의 객체입니다. 딕셔너리와 같은 객체가 해당됩니다. 키가 있기 때문에 순서가 지정되지 않습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이중 밑줄 메소드, 매직 메소드&lt;/strong&gt;&lt;br /&gt;
  개인적으로 파이썬 프로그래밍 중 가장 어려운 부분 중에 하나가 이중 밑줄 메소드 입니다. 오픈소스로 작성된 코드를 보거나 구글링 해서 본 코드에 이름 앞뒤에 2개의 밑줄이 붙는 특수한 메소드입니다. 주로 연산자 오버로드에 사용되며, 줄여서 던더(dunder - double underscore)라고 부릅니다. 가장 흔히 사용되는 이중 밑줄 메소드는 ‘&lt;strong&gt;__init()&lt;/strong&gt;__’ 메소드이며, 객체를 초기화하는 데 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;모듈, 패키지&lt;/strong&gt;&lt;br /&gt;
  &lt;strong&gt;모듈(module)&lt;/strong&gt;은 특정 함수들을 모아놓은 라이브러리라고 보면 됩니다. 보통 처음 설치되는 표준 라이브러리가 있지만 각자 본인이 원하는 모듈을 개발해 사용할 수 있습니다.
  &lt;strong&gt;패키지(package)&lt;/strong&gt;는 ‘&lt;strong&gt;init&lt;/strong&gt;.py’라는 이름의 파일을 폴더 안에 넣어서 생성하는 모듈들의 집합입니다. 패키지에는 여러 개의 모듈이나 패키지가 포함될 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;호출 가능 객체, 일급 객체&lt;/strong&gt;&lt;br /&gt;
  호출 가능 연산자(2개의 괄호())를 구현하는 모든 객체는 호출 가능 객체입니다. &lt;br /&gt;
  클래스(class)는 일종의 호출 가능 객체입니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;datetime.date(2020, 1, 1)&lt;/code&gt;는 datetime 모듈에 속한 date 클래스는 호출 가능 연산자를 사용해 호출할 수 있습니다. 클래스 객체를 호출하면 클래스의 __init()__메소느 내부의 코드를 실행합니다.
  일급 객체(first-class object)는 변수에 저장되고, 함수 호출에서 인수로 전달되고 결과로 반환되는 등, 객체로 할 수 있는 모든 기능을 할 수 있습니다. 
  별칭(alias)는 기존 함수 객체를 다른 변수에 할당했을 때, 기존 함수에 대한 다른 이름을 뜻합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;2-헷갈리는-용어&quot;&gt;2. 헷갈리는 용어&lt;/h1&gt;
&lt;p&gt;  흔히 관련이 있어서 묶여서 사용되거나 의미가 유사해 혼동되어 사용되는 용어가 있습니다. 하지만, 용어를 혼동해 사용하다보면 의미가 잘 못 전달될 수 있습니다. 따라서 정확한 의미를 알고 사용하는 것이 중요합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;문 vs 표헌식&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;표현식(Expression)&lt;/strong&gt;&lt;br /&gt;
  표현식은 단일 값으로 평가되는 값들과 연산자들로 구성된 명령어를 뜻합니다. 코드를 작성할 때, 특정 값을 도출하기 위해 연산을 하거나, 함수를 호출하는 코드 라인은 모두 표현식이라고 보면 됩니다. &lt;br /&gt;
&lt;strong&gt;문(Statement)&lt;/strong&gt;&lt;br /&gt;
  표현식과는 반대로 문은 값으로 도출되지 않는 모든 명령을 뜻합니다. 할당문, if 문, for 문, def 문, return 문등이 문에 포함됩니다. 
&lt;br /&gt;
  예를 들어 설명해보겠습니다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;위 코드는 spam 이라는 변수에 2 + 2라는 단일값을 나타내는 표현식이 할당되는 할당문을 나타내고 있습니다. 이렇게 보니 표현식과 문이 구분되시나요?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;블록 vs 절 vs 바디&lt;/strong&gt;&lt;br /&gt;
  블록(block), 절(clause), 바디(body) 용어 모두 파이썬에서 명령어 그룹을 가리키는데 사용되는 말이며 자주 혼용됩니다.&lt;br /&gt;
  &lt;strong&gt;블록&lt;/strong&gt;은 들여쓰기로 시작하여 해당 들여쓰기 수준이 이전 들여쓰기 수준으로 돌아오면 종료되는 그룹을 나타냅니다. 예를 들어, if, for 문에 따라나오는 코드 라인 그룹을 해당 문의 블록이라 표현합니다. 파이썬 공식 문서에서는 블록 대신 &lt;strong&gt;절&lt;/strong&gt;이라는 용어를 선호합니다. 무슨 용어를 사용하든 상관 없을 것 같습니다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 아래는 if 문으로 한 블럭입니다. 블럭 내 구조는 다음과 같습니다.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;Mato&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 절 헤더(clause header)
&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Hello, Mato!&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 절 스위트(clause suite) 또는 바디(body)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;변수 vs 속성&lt;/strong&gt;&lt;br /&gt;
  &lt;strong&gt;변수&lt;/strong&gt;는 객체를 가리키는 이름을 뜻하고, &lt;strong&gt;속성(Attribute)&lt;/strong&gt;는 점 다음에 나오는 모든 이름을 말한다. 예를 들어 보겠습니다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;datetime&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;today&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;today&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;year&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;today&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;month&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;  위 예시에서 datetime 객체가 할당된 변수입니다. year와 month는 datetime객체에 포함된 속성입니다. &lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;함수 vs 메소드&lt;/strong&gt;&lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;함수(function)&lt;/strong&gt;: 자신이 호출될 때 실행되는 코드의 모음&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;메소드(method)&lt;/strong&gt;: 클래스와 연관된 일종의 함수&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;  예를 들어보겠습니다.&lt;/p&gt;
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# len 함수
&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;upper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 문자열 객체의 메소드 upper
&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;math&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# sqrt 함수 - 점이 있다고 모두 메소드가 아님! 
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;반복가능 객체 vs 반복자&lt;/strong&gt;&lt;br /&gt;
  &lt;strong&gt;반복가능 객체&lt;/strong&gt;를 나타내는 가장 쉬운 예는 for 문에 포함될 수 있는지 여부이다. 리스트, 튜플, 문자열, range와 같이 모든 시퀀스 유형이 반복가능 객체에 포함되며 딕셔너리, 집합, 파일 객체 같은 일부 컨테이너 객체도 포함됩니다. &lt;br /&gt;
  우리가 for 루프문을 사용하면 파이썬 내부에서는 iter(), next() 함수를 호출하여 작동됩니다. for 루프문 내에서는 반복가능 객체는 iter() 함수에 전달되며 반복자(iterator)객체를 반환합니다. 그 다음 이 반복자 객체는 next() 함수로 전달되여 루프문이 작동됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;구문 vs 런타임 vs 의미 에러&lt;/strong&gt;&lt;br /&gt;
  파이썬 프로그래밍 에러는 다양한 에러가 존재하지만 크게 아래 3가지 유형으로 나눌 수 있습니다.
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;구문(syntax) 에러&lt;/strong&gt;&lt;br /&gt;
   흔히 오타를 낼 경우 발생하는 에러를 의미합니다. 구문이란 프로그래밍 언어 별로 지정된 언어의 유효한 명령어에 대한 규칙 집합을 의미하는데 이를 어길시에 발생하게 되는 에러를 구문 에러라 합니다. 파이썬이 SyntaxError를 생성했을 때에는 오타가 없는지, 쉼표나 마침표가 잘못된 것은 없는지 살펴봐야 합니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;런타임(runtime) 에러&lt;/strong&gt;&lt;br /&gt;
   파이썬이 특정한 작업을 수행하지 못할 때 발생하는 에러입니다. 예를 들어, 숫자를 0으로 나누거나 존재하지 않는 파일에 접근하는 경우에 발생합니다. 즉, 불가능한 지시를 내릴 때 발생하는데, 에러가 해결되지 않으면 추적정보(traceback)가 표시됩니다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;의미, 논리 에러(semantic, logical error)&lt;/strong&gt;&lt;br /&gt;
   컴퓨터가 발생시키는 에러는 아니지만, 프로그래머가 의도하지 않는 방식으로 코드가 수행되는 에러입니다. 즉, 프로그램적으로 잘못된 것은 없지만 우리가 의도한 바대로 수행되지 않는 경우입니다. 의도적으로 에러가 발생되지 않기에 어떻게 보면 처리하기 가장 어려운 에러 중 하나입니다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;파라미터 vs 인수&lt;/strong&gt;&lt;br /&gt;
  사실 데이터 분석가나 과학자들에게 파라미터는 보통 모델에 들어가는 파라미터를 의미하는 경우가 많습니다. 다만 프로그래밍에선 이 용어가 어떻게 구분되는지 짚고 넘어가겠습니다. &lt;strong&gt;파라미터(parameter)&lt;/strong&gt;란 def 문에서 괄호 사이에 들어가는 변수 이름을 말하며, &lt;strong&gt;인수(arguments)&lt;/strong&gt;는 함수 호출할 때 전달되는 값입니다. 즉 호출할 때 인수는 파라미터로 전달되어 지정됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;타입 강제변환 vs 캐스팅&lt;/strong&gt;&lt;br /&gt;
  둘다 어떤 객체의 타입을 바꿀때 쓰입니다. 다만, 객체의 변현와 명시적으로 혹은 묵시적으로 바뀌는지에 따라 나뉩니다. 예를 들어 ‘42’라는 문자열을 정수 42로 변환하기 위해서 int() 함수를 사용해 타입을 바꿔줍니다. 이때는 데이터 타입을 캐스팅한다고 말합니다. 반대로 2 + 3.0은 정수와 실수 간 연산이기에 공통 데이터 타입으로 강제되는데 이때 이뤄지는 변환을 타입 강제변환입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;3-마치며&quot;&gt;3. 마치며…&lt;/h1&gt;
&lt;p&gt;  위에서 정리한 용어를 모르더라도 파이썬을 활용해 데이터를 분석하고 모델을 개발하거나 전처리 파이프라인을 개발하는데에는 문제가 없을 ‘수’ 있다. 하지만 개발자, 분석가 동료와 소통할 때 소통이 잘못되거나 의미 전달이 제대로 이루어지지 않을 확률이 높다. 또한 본인이 개발한 소스코드를 오픈하거나 다른 사람에게 인계해야 할 상황인데 용어 정의가 명확하지 않다면? 당연히 많은 문제에 부딪힐거라 생각합니다.&lt;/p&gt;
</description>
        <pubDate>Wed, 24 Jan 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/python/clean_code7/</link>
        <guid isPermaLink="true">http://localhost:4000/python/clean_code7/</guid>
        
        <category>Python</category>
        
        <category>Coding</category>
        
        <category>Review</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>[회고록] 23년 회고</title>
        <description>&lt;p&gt;  안녕하세요. 올해 연말에는 눈이 참 많이 왔네요. 아직까진 함박눈이 펑펑 쏟아지는 것을 보면 참 기분이 좋습니다. 뭔가 죽어있던 동심이 깨어나는 느낌이랄까요? 잡설은 이만하고 2023년 마지막 날 올해를 돌아보고 24년을 맞이하는 회고록을 작성하고자 합니다. 고민하던 것들을 키워드 중심으로 정리하고 내년에 해보고 싶은 것들을 적어보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;1-회고록-작성&quot;&gt;1. 회고록 작성&lt;/h2&gt;
&lt;p&gt;  일하다보니 뭔가 기록을 하지 않으면 결국에는 까먹게 되고, 이 휘발된 내용들이 너무나 아까웠습니다. 그래서 회고록을 작성하기로 결심하고 올해부터 작성해봤습니다. 거창한 계획을 세웠다기 보다는 일정 기간동안에 기록해야될 만한 것들을 선정해서 적고자 했습니다. 올 한해 작성한 것들을 보니 계획적으로 작성했기 보단
시간 될 때, 쓰고 싶을 때에 충동적으로 썼네요. 심지어 후반기에는 바쁘고 귀찮다는 핑계로 거의 작성하질 않았네요. 24년부터는 더 체계적으로 회고록을 작성하도록 스스로와의 약속을 해야할 것 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;월간 회고룩 필수 작성&lt;/strong&gt;&lt;br /&gt;
 매월 회고록은 무조건 작성하여 1년에 최소 12개의 회고록은 작성해야겠습니다. 회고록만 작성하려고 블로그를 개설한 것은 아니기에 매주 강제적으로 하고 싶진 않습니다. 다만, 중간중간 필요하다면 일간, 주간 회고록도 작성하겠습니다. 월간 회고록 &lt;strong&gt;작성 기한은 매월 말일&lt;/strong&gt;로 하겠습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모하는 습관 들이기&lt;/strong&gt;&lt;br /&gt;
 기록해야할 것들은 매 순간 스쳐지나가기에 기록하는 습관을 들여야겠습니다. 개인 다이어리 혹은 아이폰 일기 App을 활용해보겠습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-커리어에-대한-고민&quot;&gt;2. 커리어에 대한 고민&lt;/h2&gt;
&lt;p&gt;  24년에는 커리어적으로 큰 변곡점에 다다를 것이라 예상됩니다. 현재 제 상태는 변화가 필요하다고 느끼는 시점입니다. 아무래도 현재 직장에서의 일이 어느정도 익숙해지면서 조금 풀어지는 것 같습니다. 아직 심하진 않지만 잘못하면 매너리즘에 빠질 수 있겠다는 생각도 듭니다. 현재 회사 내에서 직무 전환이 쉽지 않기에 이제는 이직에 대해서 진지하게 생각하고 실행해야 할 시점이라 생각합니다. 혹은 현재 회사 내에서 뭔가 커리어적으로 점프할 수 있는 것이 필요합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;이직 동기&lt;/strong&gt;&lt;br /&gt;
 스스로 동기부여를 위해서라도 이직 동기가 어느정도 구체적이여야 할 필요가 있다고 느낍니다. 현재 팀은 팀원, 팀장님도 다 좋고 분석 업무도 좋습니다. 다만, 변화가 적고 현재 하고 있는 업무에 대해서 100% 만족하지 못하고 있습니다. 그냥 하던거 계속 반복하는 느낌입니다. 점점 보람도 떨어지고 몰입도도 떨어지고 있습니다. 가진 모든 역량을 100% 발휘하여 몰입할 수 있는 곳에서 다시 한 번 도전하고자 하는 동기가 가장 큰 것 같습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;도메인&lt;/strong&gt;&lt;br /&gt;
 과연 이 도메인에 계속 있는 것이 맞을까 하는 고민도 끊이질 않습니다. 제조업에서 데이터가 가진 가치는 결코 작진 않다는 것은 이미 일하면서 피부로 느꼈습니다. 사실 개인적인 공정/설비/제조에 대한 분석 보다는 사람들의 개인적인 선택에 대한 분석에 흥미가 더 큽니다. 석사 과정에서도 개인의 선택에 흥미를 느껴 응용미시계량을 전공했구요. 아직 생각이 완전히 정리된 것은 아니지만 제 이런 니즈를 더 살릴 수 있는 방향을 찾아봐야겠습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;  회고록을 작성하면서 다시 한 번 느끼는 점인데 24년에는 더 적극적으로 행동해야 겠습니다. 더 늦기 전에 도전해보고 의미있는 결과를 도출해야 겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;프로페셔널&lt;/strong&gt;&lt;br /&gt;
 점점 프로페셔널함이 무엇인가, 전문가라면 어떻게 해야하는 것인가에 대한 고민도 하곤 합니다. 실력은 당연한 것이니 따로 기술하진 않겠습니다. 다만, 요즘은 일을 대하는 태도에 대해서 많이 생각합니다. 가장 후회되는 것 중 하나가 불규칙적인 수면 패턴, 음주로 인해 사무실에서 피곤한 모습을 보이는 것입니다. 앞으로는 이런 모습을 배제하고 최소한 사무실에서, 내 자리에서 만큼은 철저하게 프로다운 모습을 보여야겠습니다. 이제 더 이상 핑계가 먹히는 저연차 주니어가 아니니까요. 단정하고 깔끔한 모습에 맡은 일에 항상 최선을 다하는 모습을 보이도록 하겠습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-건강-챙기기&quot;&gt;3. 건강 챙기기&lt;/h2&gt;
&lt;p&gt;  시간적인 여유가 있던 학생 시절에는 운동을 꽤 규칙적으로 꾸준히 했습니다만, 년차가 쌓일수록 운동과는 점점 멀어지는 본인의 모습을 보고 씁쓸해지곤 합니다. 건강이 조금씩 무너지다보니 정신적인 부분에도 안 좋은 영향을 미치고 있다는 것을 요즘 많이 느낍니다. 따라서 24년에는 건강을 더 챙기기 위해 몇 가지 목표를 세웠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;마라톤 완주하기&lt;/strong&gt;&lt;br /&gt;
 기안84가 나혼자산다 프로그램에서 풀 마라톤을 완주하는 모습을 보고 자극 받아 24년 목표로 세운 것입니다. 동마는 접수 기간이 지났고, 서울하프마라톤은 전산 오류로 인해 하프 접수를 못하고 10k를 접수했습니다. 몸이 많이 무너져서 긴 호흡을 갖고 꾸준히 준비해야겠습니다. 혼자 준비해야 하다보니 막막하긴 한데 차근차근 해봐야겠습니다. 우선 1달 50k를 채우는 것을 목표로 해야겠습니다. 주중 2회, 주말 장거리 1회 정도로 목표를 잡고 운동해야겠습니다. 50k를 채우면 차근차근 늘려가야겠습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;근력 운동하기&lt;/strong&gt;&lt;br /&gt;
 유산소는 짬짬히 조깅을 했지만 근력 운동은 손 놓은지 정말 오래된 것 같습니다. 그러다 보니 자세가 조금씩 무너지는 것이 느껴지네요. 근력 운동은 개인 건강에도 이롭지만 아무래도 외적인 자신감을 높여주기에 상당히 중요하다 생각됩니다. 오래 쉰 만큼 완전 초보자 입장에서 시작하다보니 재미는 있을 것 같습니다. 근력 운동에는 따로 목표를 두지 않고 주 2~3회 정도 큰 운동 위주로 할 수 있도록 해야겠습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-자기개발&quot;&gt;4. &lt;strong&gt;자기개발&lt;/strong&gt;&lt;br /&gt;&lt;/h2&gt;
&lt;p&gt;  업무적인 자기 개발과 그 외적으로 자기개발을 나누어서 올해도 꾸준히 성장할 수 있도록 자기개발을 진행하고자 합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;데이터분석&lt;/strong&gt;&lt;br /&gt;
 23년에는 프로그래밍, 프로그래밍 스타일, db, 데이터 모델링 쪽에 관심이 많아 해당 분야에 책들을 몇 권 읽었습니다. 24년에는 데이터 분석 컨텐츠를 풍부하게 하기 위해 다양한 사례를 접하고 읽어보고자 합니다. 할 수 있는 가장 쉬운 방법 중 하나는 책으로 읽어보는 것이겠죠? 추가로 기계학습 분야에 대해서도 제대로 공부해보고, 통계에 대해서는 다시 복습하고자 합니다. 실무에서 쓰는 것만 알고 많은 부분을 까먹었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;독서&lt;/strong&gt;&lt;br /&gt;
 24년에는 &lt;strong&gt;매월 2권&lt;/strong&gt;의 책을 읽을 것입니다. 소설, 교양 등 형태나 장르, 주제 상관없이 손 가는대로 책을 읽고자 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;네트워킹&lt;/strong&gt;&lt;br /&gt;
 일하면서 가장 부족하다고 생각한 것 중 하나가 바로 네트워킹입니다. 다양한 도메인에서 종사하고 있는 분석가들과 교류를 하면서 서로의 인사이트를 공유할 수 있는 네트워크를 하고자 합니다. 일단 해보고 의미가 있는지 없는지 판단해보려구요. 현재 업계가 어떻게 돌아가고 있는지, 나와 다른 도메인에서는 어떻게 일하는지 등등 궁금한 것들을 간접적으로 느껴보고 알아보고자 합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-마치며&quot;&gt;5. 마치며…&lt;/h2&gt;
&lt;p&gt;  생각나는 것만 적었는데 꽤 많네요. 24년에는 적어도 위에 적은 것들을 이루고 더 성장할 수 있는 한해가 되길 빕니다.&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Dec 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/yearly_memior/</link>
        <guid isPermaLink="true">http://localhost:4000/data/yearly_memior/</guid>
        
        <category>Data</category>
        
        <category>Memoir</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[회고록] 23년 4분기 회고</title>
        <description>&lt;p&gt;  안녕하세요. 정말 오랜만에 회고록을 작성합니다. 마지막으로 회고를 작성했던 9월 이후로 많은 일들이 있었지만, 그 중 2가지에 대하여 기록하고자 합니다. 첫 번 째는 데이터 분석 프로젝트에 관한 내용이고 두 번째는 신규 입사자 교육입니다.&lt;/p&gt;

&lt;h2 id=&quot;1-제조-현장에서-데이터-분석가의-역할과-한계&quot;&gt;1. 제조 현장에서 데이터 분석가의 역할과 한계&lt;/h2&gt;
&lt;p&gt;  올해 2 ~ 9월 까지 국내 공장에 대하여 에너지 절감 프로젝트를 진행했고, 결과가 좋아 해외 공장으로 확산하기로 했습니다. 그 첫 번째로 1개 공장을 선정하여 진행하여 에너지 사용 현황을 진단하고 에너지 절감 포인트를 도출하는 프로젝트를 진행했습니다. 국내 공장을 대상으로 에너지 절감 프로젝트를 진행한 경험이 직전에 있었기에 이번 해외 공장 대상으로는 상대적으로 빠르게 진행할 수 있었습니다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  우리 팀은 공장에 최근 3년동안 에너지 별, 에너지 사용처 별 에너지 사용 현황 분석을 통해 문제점을 진단하고 그 중 4가지 분석 포인트를 선정했습니다. 그 중 2개 포인트에 대해선 에너지 사용 증가에 대한 원인을 밝혀냈고, 1개 포인트는 데이터 계측 오류(센서 고장), 1개 포인트는 분석 미진행으로 결론 지을 수 있었습니다. 특히, 원인을 밝혀낸 2개 포인트 중 1개 포인트는 현장 엔지니어도 놓치고 있었던 부분을 순전히 데이터로 밝혀낸 것으로 개인적으로도 매우 뿌듯했습니다.😊
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  다만, 프로젝트를 하면서 다시 한 번 느낀 것 중에 하나는 클라이언트와 데이터 분석가 간 데이터를 보는 간극이 꽤 크다는 것입니다. 저는 데이터 전문가로서 현재 우리에게 주어진 데이터의 한계를 분명하게 인지하고 어떻게든 그 안에서 최대한 많은 인사이트를 도출하고자 노력합니다. 클라이언트의 요구사항에 따라 데이터의 한계를 넘어서서 새로운 포인트를 도출하고 싶지만, 잘 되지 않고 좌절할 때가 많습니다. 따라서 어떻게 하면 고객이 원하는 방향으로 분석을 진행할 수 있을까에 대한 고민이 점점 많아지게 됩니다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  이런 고민은 제조현장에서 데이터 분석가의 역할과 한계에 대한 고민으로 이어지게 됩니다. 우리 팀은 데이터 분석가가 도메인 지식이 약하다는 약점을 보완하기 위해 엔지니어와 한 팀으로 분석 프로젝트를 수행하게 하는 모델을 도입했고 성과를 보고 있는게 사실입니다. 따라서 엔지니어가 분석에 대한 적극적인 관심과 개입이 필요하지만 본업에 바쁘고 데이터 분석에 대한 이해도가 낮은 경우에는 소극적으로 임하는 경우가 있습니다. 이럴 경우에 힘 빠질때가 많습니다. 분석가로 분석을 열심히 해도 분석가는 제조 현장에서 의사결정권자가 아니기에 실제 액션으로 이어지기가 어렵기 때문입니다. 심하면 분석 결과에 대해 무시받을 수도 있습니다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  그렇다고 데이터 분석가가 도메인 전문가가 되야 할까요? 물론 도메인 전문가가 되면 가장 좋습니다. 하지만 현실적으로 데이터 분석가가 도메인 전문가가 되기에는 어려운 부분이 있습니다. 한 사이트만 전담하는 분석가라면 가능할 수 있다고 생각하지만, 대부분의 분석가는 여러 사이트에서 다양한 주제로 분석을 진행해야 하기에 모든 영역에서 전문가가 된다는 것은 어렵습니다. 개인적인 생각으론 데이터 분석 스페셜리스트에 더하여 도메인 영역에 대한 제너럴리스트가 되는 것이 베스트라고 생각합니다. 사실 이것만 해내도 굉장한 것이겠죠.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  분석에 대해 소극적이고 회의적인 클라이언트를 어떻게 하면 설득하고 이끌어 갈 수 있을까란 부분에 대해서도 항상 고민하게 됩니다. 사실 이 부분은 개인적인 역량에 기대기 보다는 조직 문화가 선행되어야 하는 부분이라고 생각을 합니다. 데이터 활용을 장려하고, 교육하고, 업무 분장을 조절하고, 성과에 대한 보상을 제공하는 등 분석을 하게끔 만드는 동기와 유인이 있어야 가능하다고 생각합니다. 일을 하면 할수록 고민만 많아지네요 정말.&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-신규-입사자-교육----코드-리뷰-공유의-힘&quot;&gt;2. 신규 입사자 교육 -  코드 리뷰, 공유의 힘&lt;/h2&gt;
&lt;p&gt;  최근 우리 팀에 3분에 신규 입사자 분이 입사하여 교육을 진행했습니다. 제가 맡은 파트는 우리 팀에서 사용하는 BI Tool을 잘 다룰 수 있도록 교육하는 것이었습니다. 따라서 저는 신규 입사자 분이 잘 적응할 수 있게 나름 머리를 써서 교육을 진행했고, 생각보다 제 스스로 배운 것도 많았습니다. 커리큘럼은 다음과 같이 짰습니다.&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;기존에 개발된 App 그대로 따라 개발하기 - Reference 제공&lt;/li&gt;
    &lt;li&gt;1차 과제 제공 - Reference 미제공&lt;/li&gt;
    &lt;li&gt;2차 심화 과제 제공 - Reference 미제공&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;  1번의 경우, 우리 팀에서 가장 기본적으로 활용하는 분석 화면 App을 스스로 개발할 수 있도록 기존 개발된 App을 그대로 따라 작성하면서 개발해보도록 했습니다. 마치 프로그래밍 언어를 처음 배울 때, 기존 소스를 따라 작성해가며 공부하는 방식을 차용한 것입니다. 데이터 마트와 차트를 만들어 보면서 어떤 함수와 기능들이 있는지 익히도록 하는게 주 목적이었습니다. 여기까지는 과제 수행을 위한 준비 과정의 개념으로 진행했습니다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  1번을 수행하고 난 후에 1차 과제를 제공했습니다. 기존에 개발한 App에 추가 기능을 구현하도록 과제를 내줬고, Reference는 제공하지 않았고 스스로 고민해보고 토론해가며 개발해보도록 했습니다. 2차 과제도 동일한 방식으로 진행했구요. 그러고 매일 진행상황을 같이 체크하고 코드를 공유하며 리뷰하는 시간을 가졌습니다. 리뷰를 진행하면서 잘못된 것 혹은 비효율적인 부분은 집어가며 가이드를 제공했고, 개인적으로 경험했던 꿀팁들을 아낌없이 방출했습니다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  이런 방식은 처음 적용해 본 것인데, 생각보다 엄청난 효과가 있었습니다. 저도 많이 배운 것 또한 사실이구요. 동일한 Output이지만 정말 소스 코드는 개인에 따라 다양했습니다. 그 중에서는 제가 해보지 않았던 방법들을 신규 입사자 분들께서 굉장히 창의적인 생각으로 만들어 본 것도 있었습니다. 저는 3년 이상 일을 하면서 어느정도 개발 스타일이 굳어졌는데, 신규 입사자 분들은 그런 것이 없다보니 더 창의적으로 생각할 수 있었던 것 같습니다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  또 다양한 코드를 서로 공유하다보니, 서로 비교해보고 스스로 개선할 수 있는 기회가 마련됐습니다. 저는 이번 신규 입사자 교육을 진행하면서 코드 리뷰의 힘을 제대로 알 수 있었습니다. 사실, BI Tool 개발은 어느정도 익숙하고 알만한 것은 안다고 생각했는데 전혀 아니었습니다. 제가 생각하지 못한 새로운 방식도 많았고, 잘못 활용하고 있던 것도 있었습니다. 코드를 리뷰하면 이런 부분을 놓치지 않고 공유할 수 있다는 것이 굉장히 큰 메리트로 다가왔습니다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  사실 우리팀은 코드 리뷰가 따로 없습니다. 협업 체계가 없고 각자 알아서 개발하다보니 개발 역량이 개인적인 역량에 크게 의존하게 되는 것 같습니다. 코드 리뷰라는 것은 개인적인 역량에 의존하기 보다는 한 팀이 다 같이 나아갈 수 있도록 할 수 있는 강력한 도구라 생각합니다. 따라서 만약 미래에 내 팀을 빌딩하게 될 때가 온다면 팀 내에서 반드시 코드 리뷰를 하도록 하고자 합니다. 자꾸 오픈하고 까발려야 문제점을 발견하고 수정하고 발전할 수 있겠죠. 문제점이 없다면 좋은 사례로 팀 내 공유된다면 그 또한 더 좋을 일이구요. 이렇게 해야 더 좋은 방향으로 발전해 나갈 수 있다고 생각합니다.&lt;/p&gt;

&lt;h2 id=&quot;3-마치며&quot;&gt;3. 마치며…&lt;/h2&gt;
&lt;p&gt;  오랜만에 회고록을 작성하다보니 까먹은 부분이 많네요ㅠ. 이건 회고록에 적어야지 하고 생각했던 것들이 많은데… 앞으로는 귀찮고 바쁘더라도 회고록은 웬만하면 빼놓지 않고 작성할 수 있도록 하겠습니다! 그럼 이만!&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Dec 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/Monthly_memoir/</link>
        <guid isPermaLink="true">http://localhost:4000/data/Monthly_memoir/</guid>
        
        <category>Data</category>
        
        <category>Memoir</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[파이썬] 파이썬다운 코드란?</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;이 포스트의 내용은 저자 Al Sweigart의 “클린 코드, 이제는 파이썬이다” 6장 내용임을 사전에 미리 밝힙니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  저는 데이터 분석을 하기 위한 프로그래밍 용어를 대부분 독학으로 익혔습니다. 그러다보니 제 코딩스타일은 독학하기 위해 선택했던 학습서, 구글링 해서 따온 코드들의 짜집기가 됐습니다. 그렇기에 파이썬 특성에 맞는 코드를 쓰기보단 그냥 아는대로 막 썼습니다. 코드를 작성하는 방식에는 정답이 없겠지만, 저자는 경험 많은 파이썬 전문가들이 일반적으로 사용하는 기법들을 소개하고 충분히 파이썬 다운 코드를 작성하는데 도움이 된다 생각하기에 기록하고 소개하고자 합니다.&lt;/p&gt;

&lt;h1 id=&quot;1-파이썬의-선zen-of-python&quot;&gt;1. 파이썬의 선(Zen of Python)&lt;/h1&gt;
&lt;p&gt;  파이썬의 선이란 팀 피터스가 작성한 파이썬 프로그램을 위한 20가지 지침 모음입니다. 지침이기에 반드시 따라야 할 필요는 없습니다. 하지만 참고해 볼 만한 내용이라 생각합니다. 굵은 문자는 팀 피터스가 제시한 지침이고, 아래 내용은 저자가 해석한 내용과 제가 덧붙인 내용입니다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;아름다운 것이 보기 흉한 것보다 낫다.&lt;/strong&gt;&lt;br /&gt;
  아름다운 코드란 보고 읽기 쉬운 가독성 좋은 코드를 뜻합니다. 저자는 프로그램 구동에 문제는 없지만 읽기 어려운 코드를 가독성을 전혀 고려하지 않은 흉하다고 느낍니다. 저자는 이런 흉한 코드보다는 유지 보수, 관리에 쉽도록 깔끔하게 다듬어진 가독성 좋은 코드를 더 아름다운 것이라 해석하고 있습니다. 물론, 저도 이에 전적으로 동의합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;명시적인 것이 암시적인 것보다 낫다.&lt;/strong&gt;&lt;br /&gt;
  비유적이고 암시적인 표현보다는 최대한 상세하고 명시적인 표현이 더 명확한 메시지를 전달할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;단순한 것이 복잡한 것보다 낫다. 복잡한 것은 뒤얽힌 것보다 낫다.&lt;/strong&gt;&lt;br /&gt;
  오컴의 면도날과도 같은 맥락이라 생각합니다. 같은 작업을 수행하는 코드라면 더 단순한 것이 좋습니다. 굳이 어렵고 복잡한 코드를 사용할 필요가 없습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;펼쳐놓은 수평 구조가 중첩된 계층 구조보다 낫다.&lt;/strong&gt;&lt;br /&gt;
  사실 이 부분은 제가 전문 프로그래머가 아니라 무슨 의미인지 잘 와닿지는 않습니다. 저자는 코드를 범주별로 하위 범주들을 겹겹이 중첩시킨 구조는 때로 번잡함과 난해함만 증가시킨다고 지적합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;드문드문 여유로운 것이 조밀한 것보다 낫다.&lt;/strong&gt;&lt;br /&gt;
  한 줄에 너무 많은 코드를 쑤셔넣기보다는 여러 줄에 분산해 작성하는 코드가 훨씬 읽기 쉽습니다. 저도 이 책을 읽기 전에는 한 줄에 최대한 많은 코드를 작성하는 것이 더 좋은 작성법인 줄 알았습니다. 하지만 제가 쓰고도 너무 복잡해서 읽기가 어렵더군요. 저 개인적으로도 적당히(?) 나누는 게 훨씬 좋다고 생각합니다. 이는 앞서 3번 내용과도 유사한 맥락입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;가독성은 중요하다.&lt;/strong&gt;&lt;br /&gt;
  맞습니다. 가독성은 언제나 중요합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;규칙을 어길 만큼 특별한 경우는 없다. 비록 실용성이 순수성에 우선한다 할지라도&lt;/strong&gt;&lt;br /&gt;
  사실 이 부분은 잘 모르겠습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;에러를 마주치고 넘어가면 안된다.&lt;/strong&gt;&lt;br /&gt;
  솔직히 고백하자면, 에러나 워닝을 가끔씩 시간없고 모르고 귀찮다는 이유로 무시하곤 했습니다. 이제는 무시하지 않고 항상 체크하는 습관을 만들었습니다. 무시한 것은 결국은 문제가 발생하더군요. 언제 터질지 모르는 시한폭탄을 안고 프로그램을 구동하는 것보다는 시간을 들이더라도 수정하는 것이 좋습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;모호함을 직면하고도 이를 어림짐작하려는 유혹에 빠져서는 안된다.&lt;/strong&gt;&lt;br /&gt;
  앞서 8번 내용과도 이어집니다. 잘 모르고 코드를 짜도 돌아가는 경우가 종종 있습니다. 하지만 이도 결국은 언제 터질지 모르는 시한폭탄입니다. 혹은 코드가 작동하지 않는다면 반드시 명확한 원인이 존재합니다. 대충 때려 맞추지 말고 정확하게 문제를 파악해서 수정하는 것이 좋습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;문제를 해결한 명확한 방법이 존재할 것이다.&lt;/strong&gt;&lt;br /&gt;
  말 그대로 입니다. 문제를 해결할 방법은 항상 존재합니다. 다만, 너무 다양한 방법을 고민하면서 신경쓰기보단 단 하나의 방법을 찾아도 충분합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;영원히 안 하는 것보단 지금 하는 것이 낫다. 비록 떄로는 지금 당장 하는 것보단 영원히 안 하는 것이 나을 수도 있지만.&lt;/strong&gt;&lt;br /&gt;
  저자는 이 문구를 다음과 같이 해석합니다. 빠르게 실행되는 코드보다 느리게 실행되는 코드 쪽이 확실이 나쁘다. 그리고 너무 일찍 종료되지만 잘못된 결과를 내놓는 프로그램도 나쁘다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구현 결과를 설명하기 쉽다면 좋은 아이디어일 확률이 높다.&lt;/strong&gt;&lt;br /&gt;
  본인이 작성한 프로그램의 구현 결과를 설명하기 어렵다면 대게 좋은 아이디어일 확률이 매우 낮습니다. 왜냐하면 말로 설명하기 어려운 것은 제대로 이해하지 못한 것이고 제대로 이해하지 못한 것이 좋은 아이디어이기는 어려울 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;네임스페이스는 정말 좋은 아이디어다.&lt;/strong&gt;&lt;br /&gt;
  네임스페이스는 명명 출돌을 방지하고자 식별자를 위해 만든 별도의 컨테이너입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;  중요한 것은 위에 내용을 그대로 따라하고 맹목적으로 적용하란 것이 아닙니다. 읽어보고 좋다고 생각하는 것은 취하고 별로인 것은 버리면 됩니다. 절대적인 것이 아니니까요. 저도 필요하다 생각한 것만 차용해서 신경쓰며 작성하곤 합니다.&lt;/p&gt;

&lt;h1 id=&quot;2-의미있는-들여쓰기&quot;&gt;2. 의미있는 들여쓰기&lt;/h1&gt;
&lt;p&gt;  파이썬의 들여쓰기는 큰 의미를 가지고 있습니다. 코드 행 시작 부분의 들여쓰기 개수는 어떤 코드 행이 어느 코드 블록에 포함되는지 판정하기 때문입니다. 따라서 파이썬은 들여쓰기를 강제하게 됩니다. 그러나 파이썬 코드 내의 공백(띄어쓰기 등)은 의미를 갖지 않습니다.&lt;/p&gt;

&lt;h1 id=&quot;3-흔히-잘못-사용되는-구문&quot;&gt;3. 흔히 잘못 사용되는 구문&lt;/h1&gt;
&lt;p&gt;  저자는 이 절에서 초보 파이썬 프로그래머가 흔히 저지르는 실수와 해결 방법을 소개합니다.&lt;/p&gt;

&lt;h2 id=&quot;31-range보다는-enumerate를-사용하자&quot;&gt;3.1 range()보다는 enumerate()를 사용하자&lt;/h2&gt;
&lt;p&gt;  보통 반복문을 작성할 때, range()를 사용해서 반복 인덱스 정수를 생성하곤 합니다(저도 그랬습니다😭). range() 함수 말고도 enumerate() 함수를 사용하는 방법이 있는데, 간단한 예시로 비교해보고자 합니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# range() 사용
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;moose&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# enumerate() 사용
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;moose&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  여러분이 보시기엔 어떤 코드가 더 좋게 느껴지시나요? 저는 enumerate() 사용법을 알게된 후로는 range() 보다는 enumerate() 함수를 즐겨 사용합니다. enumerate()는 정수 인덱스와 대응하는 항목을 모두 반환되기 때문에 편의성이 더 좋다는 장점이 있었습니다. 그리고 코드도 더 깔끔해지는 장점도 있었구요.&lt;/p&gt;

&lt;h2 id=&quot;32-open과-close보다는-with문을-사용하자&quot;&gt;3.2 open()과 close()보다는 with문을 사용하자&lt;/h2&gt;
&lt;p&gt;  open() 함수는 파일을 읽거나 쓰는 메소드가 포함된 파일 객체를 반환하고 작업이 끝난 후, close() 메소드로 파일을 닫아 줍니다. with문을 활용해서 open() 함수를 사용할 수 있는데 예시를 먼저 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 예시 1
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileObj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;spam.txt&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;w&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fileObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Hello, World1&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fileObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 예시 2
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fileObj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;spam.txt&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;w&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 0으로 나누기 에러 발생
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;fileObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 윗 행의 에러발생으로 실행되지 않음
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;except&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Some error occurred.&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 예시 3
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;spam.txt&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;w&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fileObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fileObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Hello, world!&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  예시 3은 with문을 활용해 작성한 코드이며 저자는 파이썬다운 예라고 소개합니다. with문을 사용하면 자동으로 close()를 호출하기 때문에 예시 1처럼 close()함수를 작성하거나 예시 2처럼 close()가 실행되지 않는 상황을 미연에 방지할 수 있습니다. 가독성도 좋고, with문 블럭을 벗어나면 자동으로 close()를 호출하므로 저 개인적으로도 with문을 더 선호합니다.&lt;/p&gt;

&lt;h2 id=&quot;33--대신-is를-활용해-none과-비교하자&quot;&gt;3.3 == 대신 is를 활용해 None과 비교하자&lt;/h2&gt;
&lt;p&gt;  ==는 동등 연산자(equailty operator)로 두 객체의 값을 비교하고 is는 동일 연산자(identity operator)는 두 객체의 아이디(identity)를 비교합니다. 파이썬에서 None은 None Type 데이터의 유일한 값이고, None 객체는 하나밖에 없습니다. 따라서, 변수가 None으로 설정된 경우 is None 비교는 항상 참으로 평가됩니다.&lt;br /&gt;
  게다가, True와 False 값에는 항상 ==를 사용해 값을 비교해야 합니다.&lt;/p&gt;

&lt;h1 id=&quot;4-문자열-포매팅&quot;&gt;4. 문자열 포매팅&lt;/h1&gt;
&lt;p&gt;  문자열 포매팅은 굉장히 자주 사용되는 방법이면 저자는 몇 가지 모범사례를 소개합니다. &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;41-백슬래시가-많은-경우-원시-문자열을-사용하자&quot;&gt;4.1 백슬래시가 많은 경우 원시 문자열을 사용하자.&lt;/h2&gt;
&lt;p&gt;  원시 문지열(raw string)은 r 접두사가 붙은 문자열 리터럴이며, 백슬래시 문자를 이스케이프 문자로 취급하지 않습니다. 특히, 백슬래시 문자가 많은 윈도우 파일 경로를 잡을 때 유용합니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 예시 1
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_directory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;C:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;AI&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Desktop&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Archive&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Spam&apos;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 예시 2
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_directory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;C:\Users\AI\Desktop\Info\Archive\Spam
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;훤씬 간단하죠?&lt;/p&gt;

&lt;h2 id=&quot;42-f-문자열을-사용한-문자열-포매팅&quot;&gt;4.2 f-문자열을 사용한 문자열 포매팅&lt;/h2&gt;
&lt;p&gt;  여러 개의 문자열과 변수를 조합하여 문자열을 생성할 때 문자열 포매팅을 활용합니다. 여러가지 방법이 있지만 저는 f-문자열을 가장 선호합니다. f문자열을 사용하기 위해서는 문자열 앞에 f접두사를 붙여주고, 중괄호 안에 원하는 변수들을 넣어주면 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# f문자열 사용 예시
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;day&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weather&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;AI&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;Sunday&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;sunny&apos;&lt;/span&gt;
&lt;span class=&quot;sa&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Hello, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;. Today is &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;day&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; and it is &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weather&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;.&apos;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  ‘+’ 연산자 혹은 ‘%s’ 변환 지정자 혹은 format() 과 같은 방법이 있지만 깔끔하지 않고, 정확히 어느 자리에 매칭되기까지 직관적으로 잘 보이지 않습니다. 따라서 저는 f문자열만 사용하고 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;5-사본-만들기&quot;&gt;5. 사본 만들기&lt;/h1&gt;
&lt;p&gt;  기존 데이터프레임이나 리스트를 참조하여 새로운 변수에 할당하는 경우, 새 변수에서 작업하는 것들이 참조하는 원 데이터에 영향을 미치게 됩니다. 왜냐하면 파이썬에 특성상 기존 데이터를 복사하는게 아닌 객체에 대한 참조를 가져오기 때문입니다. 따라서 copy() 함수를 사용하여 새로운 변수에 할당하는 것이 안전합니다.&lt;/p&gt;

&lt;h1 id=&quot;6-딕셔너리-사용법&quot;&gt;6. 딕셔너리 사용법&lt;/h1&gt;
&lt;p&gt;  딕셔너리는 키-값 쌍을 매칭하여 제공하기에 파이썬 프로그래밍에서 아주 유용하게 사용됩니다. 이 절에서는 일반적으로 사용되는 딕셔너리 관용구를 소개합니다.&lt;/p&gt;

&lt;h2 id=&quot;61-get과-setdefault를-사용하자&quot;&gt;6.1 get()과 setdefault()를 사용하자&lt;/h2&gt;
&lt;p&gt;  만약, 딕셔너리에 존재하지 않는 키에 접근하려면 KeyError가 반환됩니다. 이런 상황에 대응하기 위해 키가 존재하지 않을 경우 반환할 기본값을 지정할 수 있는 get() 메소드가 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 파이썬답지 않은 예
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfPets&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;dogs&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;cats&apos;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberOfPets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;I have&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberOfPets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cats&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;cats&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;I have 0 cats&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# get() 활용 예시
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfPets&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;dogs&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;I Have&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberOfPets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cats&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;cats&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  get() 메소드를 활용하면 key가 없는 경우를 피해가기 위해 번거로운 구문을 추가적으로 작성할 필요가 없어집니다. &lt;br /&gt;
  또한, Key가 없으면 기본값을 설정하는 setdefault() 메소드도 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 파이썬답지 않은 예
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfPets&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;dogs&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;cats&apos;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numberOfPets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;numberOfPets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cats&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;numberOfPets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cats&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# setdefault() 메소드 활용 예시
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfPets&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;dogs&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;numberOfPets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setdefault&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cats&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# cats가 존재할 경우 아무것도 하지 않는다
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfPets&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;62-기본값을-위해-collectionsdefaultdict를-사용하자&quot;&gt;6.2 기본값을 위해 collections.defaultdict를 사용하자&lt;/h2&gt;
&lt;p&gt;  가능한 모든 키에 대한 기본값이 필요하다면, 매번 setdefault()를 호출하는 것보다 collections.defaultdict()를 사용하는 것이 훨씬 쉽다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;collections&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scores&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defaultdict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;AI&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# AI키를 처음부터 설정할 필요가 없다.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Zophie&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 마찬가지로 Zophie키를 처음부터 설정할 필요가 없다.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Zophie&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;7-변수값-작업&quot;&gt;7. 변수값 작업&lt;/h1&gt;
&lt;h2 id=&quot;71-체이닝-할당과-비교-연산자&quot;&gt;7.1 체이닝 할당과 비교 연산자&lt;/h2&gt;
&lt;p&gt;  파이썬에서는 체이닝 연산자가 있으므로 and를 사용할 필요가 없습니다. 추가로 =, == 연산자도 체이닝이 가능합니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 파이썬답지 않은 예
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 파이썬다운 예
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bacon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;string&apos;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 모두 &apos;string&apos; 할당
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bacon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;string&apos;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# True 반환
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;72-in-연산자-활용하기&quot;&gt;7.2 in 연산자 활용하기&lt;/h2&gt;
&lt;p&gt;  단일 변수가 여러 가능한 값중 하나인지 확인하기 위해 in을 사용하면 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;cat&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;dog&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;moose&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  위 예시처럼 여러 값을 튜플에 넣고 해당 튜플에 값이 존재하는 지 확인할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;8-마치며&quot;&gt;8. 마치며&lt;/h1&gt;
&lt;p&gt;  저는 이 장을 읽으면서 이런 경우에는 일반적으로 이렇게 코딩을 하는구나 하고 알 수 있었습니다. 읽어보고 개인적으로 괜찮다 싶은 것들은 제 코딩스타일에 녹여 활용하고 있습니다. 여러분도 읽어보시고 괜찮은 아이디어가 있다면 가져가셔서 본인의 코딩스타일을 더 업그레이드 할 수 있길 바랍니다!&lt;/p&gt;
</description>
        <pubDate>Wed, 08 Nov 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/python/clean_code6/</link>
        <guid isPermaLink="true">http://localhost:4000/python/clean_code6/</guid>
        
        <category>Python</category>
        
        <category>Coding</category>
        
        <category>Review</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>[파이썬] 코드 악취 감지하기</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;이 포스트의 내용은 저자 Al Sweigart의 “클린 코드, 이제는 파이썬이다” 5장 내용임을 사전에 미리 밝힙니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  이 책을 읽고나서 &lt;strong&gt;코드 악취&lt;/strong&gt;라는 개념에 대해서 처음 알게 됐습니다. 코드 악취(code smell)란 충돌(crash)을 발생시키는 코드는 아니지만, &lt;strong&gt;&lt;em&gt;잠재적인 버그를 암시하는 소스 코드 패턴&lt;/em&gt;&lt;/strong&gt;을 의미합니다. 코드 악취가 반드시 문제를 야기시키는 것은 아닙니다만, 언제 터질지 모르는 시한폭탄을 들고 있는 것보단 해결하는 것이 낫겠죠? 이번 포스트에서는 어떤 종류의 코드 악취가 있고 어떻게 대응하는 것이 좋은지 알아보고자 합니다.&lt;/p&gt;

&lt;h1 id=&quot;1-중복된-코드&quot;&gt;1. 중복된 코드&lt;/h1&gt;
&lt;p&gt;  저자는 가장 혼한 코드 악취로 중복된 코드(Duplicated code)를 말합니다. 중복된 코드가 문제가 되는 것은 유지 보수가 어렵기 때문입니다. 예를 들어, 코드 수정이 필요하다면 중복 사용된 모든 부분을 찾아 일일이 수정해줘야 합니다. 어렵고 쉽고를 떠나서 물리적으로 굉장히 많은 시간이 필요하고 무의미한 단순 노가다 작업에 시간을 허비해야 합니다. 만약 하나를 놓치게 된다면 버그가 발생하게 됩니다. 따라서 중복된 코드를 사용하는 것은 좋은 방법은 아닙니다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  중복을 없애기 위해서는 코드를 함수나 반복문 안에 배치하면 됩니다. 저는 중복된 코드가 필요한 경우에는 무조건 함수를 만들어 사용합니다. 만약 중복된 코드의 일부분이 다르더라면 파라미터화하여 함수를 만들면 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;askFeeling&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeOfDay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Good &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeOfDay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;와 함수는 timeOfDay파라미터를 활용하여 때에 따라 다른 작업을 수행하는 함수입니다. 위와 같이 파라미터를 활용한다면 중복된 코드들을 효과적으로 하나의 함수로 줄일 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;2-매직-넘버&quot;&gt;2. 매직 넘버&lt;/h1&gt;
&lt;p&gt;  프로그래밍에 숫자를 쓰는 일은 흔하지만 몇몇 Case의 경우, 오해를 불러일으키거나 의미를 알기 어려운 숫자가 있습니다. 예를 들면, 다음 코드에서 604800의 숫자가 뭔가 시간과 관련되어 있는 것 같지만 정확히 의미하는 바가 무엇인지 바로 알기 어렵습니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;expiration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;604800&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;주석을 달거나 혹은 이 매직 넘버를 상수로 대체하는 것입니다. &lt;strong&gt;상수&lt;/strong&gt;는 처음 할당한 뒤에 값이 변하지 않는 변수고, 일반적으로 대문자로 표기하며 소스 코드 파일 상단에 전역 변수로 정의합니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;expiration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;604800&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 1주 뒤에 만료
# 혹은
# 여러 시간 값에 대한 상수 설정
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SECONDS_PER_MINUTE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SECONDS_PER_HOUR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SECONDS_PER_MINUTE&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SECONDS_PER_DAY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SECONDS_PER_HOUR&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SECONDS_PER_WEEK&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SECONDS_PER_DAY&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;expiration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;SECONDS_PER_WEEK&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 1주 뒤에 만료
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;기존에 애매모호한 의미를 알 수 없는 코드에서 더 명확한 코드로 바뀐 것을 알 수 있습니다.&lt;br /&gt;
  값이 동일하더라도 의미가 다르고 용도가 다르다면 별도의 상수를 사용해야 합니다. 그래야 나중에 독립적으로 상수를 각각 유지 보수가 가능해집니다.&lt;br /&gt;
또한 매직 넘버라는 용어는 반드시 숫자에만 적용되는 것은 아닙니다. 예를 들어, 사용자에게 방향을 입력하게 요청하고, 방향이 북쪽이라면 경고를 출력하는 프로그램을 봅시다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Set solar panel direction:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lower&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;north&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;south&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;east&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;west&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Solar panel heading set to:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;nrth&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Warning: Facing north is inefficient for this panel.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  위에 “nrth”는 오타이지만 프로그래밍적으론 문제가 없기 때문에 북쪽을 입력하더라도 프로그램이 충돌을 일으키거나 경고 메시지를 출력하지 않게 됩니다. 따라서 프로그램을 짠 의도와는 반대로 결과가 반환될 것입니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 각 방향에 대한 상수 설정
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NORTH&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;north&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SOUTH&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;south&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;EAST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;east&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;WEST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;west&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Set solar panel direction:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lower&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NORTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOUTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WEST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Solar panel heading set to:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NRTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Warning: Facing north is inefficient for this panel.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 문자를 상수로 변환해서 사용한다면 오타로 인한 예외가 발생되어 버그가 명확하게 보이게 됩니다.&lt;/p&gt;

&lt;h1 id=&quot;3-주석-처리된-코드와-죽은-코드&quot;&gt;3. 주석 처리된 코드와 죽은 코드&lt;/h1&gt;
&lt;p&gt;  코드를 짜다보면 테스트 과정에서 종종 코드를 주석처리해 비활성화하곤 합니다. 혹은 과거의 코드는 주석 처리 시키고 새로운 코드를 작성하기도 하죠. 그렇게 주석 처리된 코드가 쌓이다보면, 왜 제거 됐는지, 혹시 필요한 건지 헷갈리게 됩니다. 저도 좋은 습관은 아니지만 과거의 코드를 주석 처리하여 남겨 놓는 일이 왕왕 있었습니다. 혹시나 현재 버전보다 과거 버전이 좋은 것이 아닐까 하는 노파심에 남겨놓습니다. 하지만 코드 스크립트만 지저분해지고 다시 사용햘 일은 없더군요. 혹은 필요하더라도 이제는 주석으로 남겨놓기 보다는 형상관리 툴을 활용하거나 백업파일로 복사해놓고 관리하지 주석으로 남겨놓는 것은 지양하고 있습니다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  죽은 코드(dead code)란 도달할 수 없거나 논리적으로 결코 실행할 수 없는 코드를 의미합니다. 예를 들면, 함수 내의 코드가 return 문 뒤에 있거나, 항상 false 조건인 if문 블럭이나, 절대 호출되지 않는 함수 코드 등이 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;random&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;coinFlip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Heads!&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Tails!&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;The coin landed on its edge!&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coinFlip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;coinFlip() 코드 문 내에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return &quot;the coin landed on its edge!&quot;&lt;/code&gt; 행은 죽은 코드입니다. 그 전에 반환되기 때문입니다. 죽은 코드는 과감하게 삭제해줍시다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  &lt;strong&gt;스텁(stub)&lt;/strong&gt;은 코드 악취 판단 규칙에서 예외입니다. 스텁은 아직 구현되지 않은 함수나 클래스의 코드가 작성될 위치를 나타내는 플레이스홀더로서 기능합니다. 실제 스텁에서는 아무 작업도 수행하지 않는 pass 문이 포함되어 있습니다. 혹은 미구현 함수를 호출하는 상황을 방지하기 위해 ```raise NotImplementedError” 문으로 스텁을 걸 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;exampleFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# stub
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;exampleFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NotImplementedError&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# stub
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;4-숫자-접미사가-붙은-변수&quot;&gt;4. 숫자 접미사가 붙은 변수&lt;/h1&gt;
&lt;p&gt;  앞선 포스트에도 포함되어 있던 내용인데, 숫자 접미사가 붙은 변수는 좋은 활용법은 아닙니다. 동일한 종류의 여러 데이터를 저장하는 변수가 필요할 때 숫자 접미사로 구분하는 경우가 있습니다. 다만 이 숫자 접미사는 우리에게 아무런 정보도 제공해주지 않습니다. 어떤 의미인지, 어떤 차이점이 있는 지 등 아무것도 알 수가 없습니다. 따라서 단순히 숫자 접미사를 사용하는 것보다 조금 더 명확한 의미를 부여하거나 리스트(list) 혹은 집합(set) 데이터 구조를 활용하는 방법이 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;5-그냥-함수나-모듈이어야-하는-클래스&quot;&gt;5. 그냥 함수나 모듈이어야 하는 클래스&lt;/h1&gt;
&lt;p&gt;  예를 들어, roll() 메소드를 가진 Dice 클래스를 봅시다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sides&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sides&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sides&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;roll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sides&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;You rolled a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  언뜻 보면 깔끔한 코드입니다. 하지만 곰곰이 생각해보면 낭비라는 걸 알아차릴 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;You rolled a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그냥 한줄이면 끝나는 코드이기 때문입니다. 굳이 클래스로 만들어서 중복을 처리할 필요도 없습니다. 굳이 복잡하게 만들 필요가 없습니다.&lt;/p&gt;

&lt;h1 id=&quot;6-중첩된-리스트-컴프리헨션&quot;&gt;6. 중첩된 리스트 컴프리헨션&lt;/h1&gt;
&lt;p&gt;  리스트 컴프리헨션(list comprehension)은 데이터 전처리 할때 굉장히 유용하게 쓰고 있습니다. 여러 줄의 코드를 한 줄로 압축해서 쓸 수 있고 직관적으로 읽을 수 있다는 점에서 매우 좋은 방법입니다. 다만, 중첩된 리스트 컴프리헨션은 적은 양의 코드에 너무 많은 복잡성을 쑤셔넣어 코드를 읽기 어렵게 만듭니다. 그럴 때는 for 루프문과 리스트 컴프리헨션을 같이 활용하는 방법도 좋은 방법입니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;nestedIntList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;nestedStrList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sublist&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nestedIntList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nestedStrList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sublist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# code smell
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nestedList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;flatlist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sublist&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nestedList&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sublist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# using for loop statement
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatlist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sublist&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nestedList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sublist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;flatList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위에 두 코드를 비교해보면 아래 코드가 훨씬 읽기 편한 것을 알 수 있습니다. 이렇듯이 한 줄의 리스트 컴프리헨션에 너무 많은 내용이 들어가게되면 필요 이상으로 복잡해지게 됩니다.&lt;/p&gt;

&lt;h1 id=&quot;7-빈-예외-처리-블록과-부실한-에러-메시지&quot;&gt;7. 빈 예외 처리 블록과 부실한 에러 메시지&lt;/h1&gt;
&lt;p&gt;  프로그램을 작성하다 보면 예외 발생에 대응하기 위해 예외 처리 구문인 except 구문을 활용합니다. 다만, 예외 처리 구문에 pass만 달랑 써놓거나 부실한 에러 메시지만을 남겨놓는다면 에러를 감춰버리는 일이 발생하게 됩니다. 이는 문제를 해결하기 보다는 감추는 것이고 추후에 더 큰 문제를 야기할 확률이 매우 높습니다. 따라서 예외 처리 구문에 더 정확한 에러 메세지와 처리 구문을 추가해야 합니다.&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Oct 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/python/clean_code5/</link>
        <guid isPermaLink="true">http://localhost:4000/python/clean_code5/</guid>
        
        <category>Python</category>
        
        <category>Coding</category>
        
        <category>Review</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>[파이썬] 좋은 이름 정하기</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;이 포스트의 내용은 저자 Al Sweigart의 “클린 코드, 이제는 파이썬이다” 4장 내용임을 사전에 미리 밝힙니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  코드 스크립트를 작성하다보면 의외로 어려운 것이 이름 짓기 입니다. 클래스, 매소드, 변수의 의미를 잘 담아내면서 중복을 피하고 깔끔한 이름을 붙이는 것이 생각보다 쉽지 않습니다. 특히, 변수에 변수명을 별 생각없이 붙이다보면, 무의미하고 지저분한 이름들 투성이더군요. 이번 포스팅에서는 좋은 이름을 짓기 위한 몇 가지 지침에 대해 알아보고자 합니다!&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  코드 스크립트를 짧게는 수십 줄에서부터 길게는 수백줄에 달하게 작성하게 되는데, 변수명을 제대로 짓지 않는다면 돌아서면 까먹고 왜 이 변수를 사용한건지, 의미가 무엇인지, 어디에 쓰이는지 알기 어렵습니다. 게다가 만약 협업을 하거나 공유를 해야할 때를 생각하면 암호와도 같은 변수명, 함수명은 재앙과도 같을 것입니다. 따라서 변수, 함수, 클래스와 같은 식별자(identifier)에는 어느정도 &lt;strong&gt;일관되고 이해하기 쉬운 이름&lt;/strong&gt;을 짓는 것은 매우 중요합니다.&lt;/p&gt;

&lt;h1 id=&quot;1-대소문자-표기법&quot;&gt;1. 대소문자 표기법&lt;/h1&gt;
&lt;p&gt;  보통의 문장에는 띄어쓰기가 포함되어 있기 때문에 읽기 쉽지만, 파이썬 식별자(identifier)에는 공백이 포함될 수 없으므로 밑줄 혹은 대소문자를 활용해 뭉쳐진 단어를 구분하는 방법을 활용합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스네이크 표기법(snake_case) : 밑줄로 단어를 구분하는데 마치 뱀이 기어가는 모양과 흡사하다 하여 붙은 이름입니다. 상수를 제외한 변수명에는 소문자를 사용하요 변수명을 표시합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;START_DATE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;END_DATE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;average_payments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;START_DATE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;END_DATE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;카멜 표기법(camelCase) : 첫 단위 뒤에 따라 나오는 단어에 첫 글자를 대문자로 표시하는 방법입니다. 식별자가 마치 낙타의 혹처럼 생겼다하여 붙은 이름입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;startDate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;endDate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;averagePayments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startDate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endDate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  저는 개인적으로 카멜 표기법보다는 스네이크 표기법을 더 선호합니다. 밑줄로 구분되어 있기 때문에 좀 덜 답답해 보여서 입니다. 어떤 표기법을 선택하든 중요한 것은 일관적으로 사용하는 것이겠죠.&lt;/p&gt;

&lt;h1 id=&quot;2-pep-8의-명명-규약&quot;&gt;2. PEP 8의 명명 규약&lt;/h1&gt;
&lt;p&gt;  &lt;a href=&quot;https://peps.python.org/pep-0008/#naming-conventions&quot;&gt;PEP8&lt;/a&gt; 문서에는 명명 규약과 관련된 몇 가지 권장사항이 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;모든 문자는 ASCII 문자여야 한다.(강세 표시 부호가 없는 영문 표시)&lt;/li&gt;
    &lt;li&gt;모듈 이름은 짧아야 하며 모두 소문자로 표기한다.&lt;/li&gt;
    &lt;li&gt;클래스 이름은 파스칼 표기법으로 적어야 한다.&lt;/li&gt;
    &lt;li&gt;상수 변수는 대문자 스네이크 표기법으로 적어야 한다.&lt;/li&gt;
    &lt;li&gt;함수, 메소드, 변수 이름은 소문자 스네이크 표기법으로 적어야 한다.&lt;/li&gt;
    &lt;li&gt;메소드에 대한 첫 번째 인수는 항상 소문자로 self라고 이름 붙여야 한다.&lt;/li&gt;
    &lt;li&gt;클래스 메소드에 대한 첫 번째 인수는 항상 소문자로 cls라고 이름 붙여야 한다.&lt;/li&gt;
    &lt;li&gt;클래스의 Private 속성은 항상 밑줄(_)로 시작해야 한다.&lt;/li&gt;
    &lt;li&gt;클래스의 Public 속성은 절대로 밑줄(_)로 시작해야 한다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;  위의 권장 사항들은 무조건 지켜야 하는 것들은 아닙니다. 알고 한 것은 아니지만 대부분 무의식적으로 사용하던 것들이네요!&lt;/p&gt;

&lt;h1 id=&quot;3-이름의-적정-길이&quot;&gt;3. 이름의 적정 길이&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;너무 짧은 이름&lt;/strong&gt;&lt;br /&gt;
너무 짧은 이름을 사용하는 것도 좋지 않습니다. 너무 짧으면 무슨 그 정확한 의미를 알기 어려운 경우가 많습니다. 다음 이름은 피하는 것이 좋습니다.
    &lt;ul&gt;
      &lt;li&gt;한두 글자로 된 이름: &lt;br /&gt;
 예를 들어, 하나의 알파벳으로만 이름(a, b, c와 같이)을 붙이면 무슨 의미인지 알아차리기 어렵습니다.&lt;/li&gt;
      &lt;li&gt;여러 단어를 대표하는 줄임말: &lt;br /&gt;
‘mon’은 monitor, month, monster 등 여러 단어를 나타낼 수 있는 줄임말로 혼동을 줄 수 있습니다.&lt;/li&gt;
      &lt;li&gt;모호한 단어: &lt;br /&gt;
‘start’와 같은 하나의 단어만 사용한다면 그 의미가 모호합니다.&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;반면, 일부러 짧은 변수를 활용하는 경우도 있습니다. 반복문의 i, j인수나 데카르트 좌표에 x, y를 사용하거나, weight -&amp;gt; w, height -&amp;gt; h, number -&amp;gt; n 과 같은 경우가 있습니다.&lt;/p&gt;
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;너무 긴 이름&lt;/strong&gt;&lt;br /&gt;
 설명이 부족한 것보다는 지나친 설명이 차라리 좋습니다. 예를 들어, 프로그램 전역 변수에 payments와 같은 변수명이 있다면 어떤 payments인지 알기 어렵고 중복될 위험도 존재합니다. 
 따라서 annual_electric_bill_payment와 같이 단어들을 추가하면 모호함이 사라질 것입니다. &lt;br /&gt;
 너무 지나치게 긴 이름을 사용하지 않는 선에서 다음과 같은 정보들을 변수명에 추가하면 유용한 정보를 제공해는 유용한 방법입니다.
    &lt;ul&gt;
      &lt;li&gt;is, has:
  보통 변수명에 데이터 타입을 표시하진 않지만 bool 타입의 경우에는 is나 has와 같은 단어를 붙여서 사용하곤 합니다.&lt;/li&gt;
      &lt;li&gt;단위 정보 표시:
  kg, ton 등과 같은 단위를 표시하면 매우 유용한 정보를 제공하므로 역시 자주 사용하곤 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;순차적 숫자 접미사&lt;/strong&gt;&lt;br /&gt;
 본인이 작성하고도 가장 성의없는 식별자가 바로 순차적 숫자 접미사를 사용한 경우입니다. 저도 본 프로그램을 작성하기 전에 테스트 코드를 작성할 때는 귀찮아서 그냥 숫자를 붙여서 변수명을 붙이곤 합니다. 다만, 정식 프로그램 코드 스크립트를 작성할 때에는 명확한 의미를 알아볼 수 있도록 변수명을 짓습니다. &lt;br /&gt;&lt;br /&gt;
   책에서는 함수명 같은 경우에 함수명의 숫자 접미사를 붙이는 것보단 정수 인수를 받는 단일 함수를 작성하는 것이 더 좋다고 제안하고 있습니다. 이 부분은 생각지 못했던 부분인데 앞으로는 저도 코드를 짤 때, 숫자 접미사를 붙이기 보다는 정수 인수를 받도록 하는 것으로 활용해보겠습니다!&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;4-검색-가능한-이름&quot;&gt;4. 검색 가능한 이름&lt;/h1&gt;
&lt;p&gt;  간단한 프로그램이 아닌이상 대부분의 코드 스크립트의 길이가 세자리 수 이상으로 길어지곤 합니다. 그런 상황에서 변수나 함수를 검색할 때에는 보통 찾기 기능(ctrl+f)을 활용하게 됩니다. 따라서 어느정도 변수명을 검색하는 상황을 생각해 이름을 지어야 합니다. 뚜렷하게 구분되는 새부 정보를 변수명에 포함시켜주는 것도 좋은 방법이라 생각합니다. 책에서는 일반적인 이름 대신 설명적인 이름을 선택하는 것이 도움이 될 것이라고 얘기합니다. 에를 들면, email 대신 emailAddress나 downloadEmailAttachment, emailMessage, replyToAddress와 같은 모호한 이름 대신 좀 더 상세한 이름을 붙일 수 있도록 제시합니다.&lt;/p&gt;

&lt;h1 id=&quot;5-농담-말장난-문화적-참조는-x&quot;&gt;5. 농담, 말장난, 문화적 참조는 X&lt;/h1&gt;
&lt;p&gt;  뻔하디 뻔하지만 보통 이런 농담은 본인만 재밌을 확률이 매우 높습니다. 또 맥락을 모르는 사람이 본다면 뭔말인지 도저히 알아먹을 수가 없습니다. 당연히 농담이나 말장난은 안하는 것이 좋습니다.&lt;/p&gt;

&lt;h1 id=&quot;6-내장-이름-덮어쓰기&quot;&gt;6. 내장 이름 덮어쓰기&lt;/h1&gt;
&lt;p&gt;  파이썬의 내장(built-in) 이름을 사용해선 안 됩니다. 파이썬이 익숙하지 않은 초보자라면 어떤 내장함수들이 있는지 잘 모를때는 이런 실수를 범할 확률이 높을 수 있습니다. 만약, 내장함수의 이름을 덮어쓰면 버그가 발생할 확률이 높습니다. 다른 이름을 덮으 쓸 가능성이 높은 이름에는 다음과 같은 것들이 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;all, any, date, email, file, format, hash, id, input, list, min, max, object, open, random, set, str, sum, test, type 등&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  .py 이름이 서드파티 모듈 이름과 같은 경우에도 여러 문제가 발생할 수 있기 때문에 피해야 합니다.&lt;/p&gt;

&lt;h1 id=&quot;7-역대-최악의-변수명&quot;&gt;7. 역대 최악의 변수명&lt;/h1&gt;
&lt;p&gt;  저자는 data라는 변수명을 최약의 변수명이라고 지적합니다. 모든 변수는 데이터를 갖고 있개 때문에 data라는 변수명은 매우 범용적인 이름이기 때문입니다. 마찬가지인 이유로 temp도 좋지 않은 변수명이라고 지적합니다. 고백하자면, 저도 data, temp라는 변수명을 사용해왔었습니다. 보통 작업하는 dataframe에 data라는 변수명으로 짓고 사용하곤 했었습니다. 책을 읽고 나서는 저도 data, temp와 같은 범용적이고 일시적인 변수명은 사용하지 않고 귀찮더라도 조금에라도 의미를 더한 변수명을 사용하고자 합니다.&lt;/p&gt;

&lt;h1 id=&quot;8-마치며&quot;&gt;8. 마치며…&lt;/h1&gt;
&lt;p&gt;  저자는 일관적으로 얘기합니다. 일관적이고 가독성이 높은 코드를 작성하는 것이 중요하다 합니다. 변수명은 알고리즘, 컴퓨터 과학, 퍼포먼스와는 관련이 없지만 가독성 높은 코드를 작성하는 데에는 매우 중요합니다. 결국은 개인 취향에 따라 스타일이 정해지겠지만 널리 알려진 지침을 참고하여 교정하는 것도 좋은 방법이라 생각합니다. 또 하나는 다른 사람이 작성한 코드 스크립트를 읽어보고 좋은 것들은 가져오는 방법도 있습니다. 물론 당연히 양해를 구해야겠죠?😊 또 하다보면 저도 어느정도 습관이 생기더라구요. 이럴 때는 이런 변수명을 쓴다든지 하는,,, 뭐 여튼 많이보고 많이 써보는 것이 가장 좋은 것 같습니다!ㅎㅎ&lt;/p&gt;

</description>
        <pubDate>Thu, 19 Oct 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/python/clean_code4/</link>
        <guid isPermaLink="true">http://localhost:4000/python/clean_code4/</guid>
        
        <category>Python</category>
        
        <category>Coding</category>
        
        <category>Review</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>[파이썬] 코드 포매팅: 코딩 스타일 정립하기</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;이 포스트의 내용은 저자 Al Sweigart의 “클린 코드, 이제는 파이썬이다” 2부 내용임을 사전에 미리 밝힙니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  처음 R과 Python을 배울 때에는 코딩 스타일에 대해 신경쓰지 않았습니다. 어짜피 혼자 보는 코드고 누구에게 공유하거나 협업 하리라고는 생각하지 못했었기 때문입니다. 그러다보니, 일관적인 코딩 스타일이 정립되지 않은채로 나쁜 습관인 것들도 굳어진 채로 실무에서 까지 활용하고 있었습니다. 이번 포스팅에서는 일반적으로 제안되는 코딩 스타일에 대해서 알아보겠습니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  왜 코딩 스타일을 정립해야 할까요? 실무를 하다보면 혼자 하기보다는 대부분 협업해서 할일이 많습니다. 파이썬, SQL, BI Tool 등 프로그래밍 언어와는 무관하게 협업을 하면서 코드 포매팅이 중구난방이면 서로 공유하기 힘들어지고 효율성이 떨어지게 될 것입니다. 게다가 코드 유지보수를 위한 가독성에도 꼭 필요한 요소입니다. 물론, 사람마다 각각의 코딩 스타일이 있으므로 완벽하게 코딩 스타일을 똑같이 정립하여 적용할 순 없겠지만, 최소한 가독성이 좋도록 일관적인 코딩 스타일을 정립하는 중요하다고 생각합니다.&lt;/p&gt;

&lt;h1 id=&quot;0-스타일-가이드와-pep8&quot;&gt;0. 스타일 가이드와 PEP8&lt;/h1&gt;
&lt;p&gt;  본격적으로 들어가기 전에 PEP8(Python Enhancement Proposal 8)에 대해 소개하겠습니다. &lt;a href=&quot;https://peps.python.org/pep-0008/&quot;&gt;PEP8&lt;/a&gt;은 파이썬 코어 개발팀이 작성한 스타일 가이드 중 하나입니다. 비록 파이썬 코어 개발팀이 제안한 방식이지만 무조건적으로 받아들여야할 필요는 없습니다. 읽어보고 일반적인 코딩 스타일은 어떤지 파악해보시고 본인만의 코딩 스타일을 정립하는 데에 활용하시기 바랍니다.&lt;/p&gt;

&lt;h1 id=&quot;1-가로-간격&quot;&gt;1. 가로 간격&lt;/h1&gt;
&lt;p&gt;  가로 간격, 즉, 코드 한 줄 내의 빈 공간 배치에 대한 내용입니다. 들여쓰기와 띄어쓰기와 같은 공백을 적절하게 배치해야 가독성이 높은 코드를 작성할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;11-들여쓰기&quot;&gt;1.1 들여쓰기&lt;/h2&gt;
&lt;p&gt;  들여쓰기(indentation)란 코드 행의 시작부에 있는 공백을 의미합니다. 보통, ‘Tab’키 혹은 ‘Space’키를 사용하여 들여쓰기를 하는데 이 책에서는 ‘Space’(공백)를 활용하는 것을 권고합니다. 이유는 탭은 \t로 \가 포함된 문자열로 랜더링되는 반면, 공백은 ‘ ‘으로 랜더링 되므로 서로 다르게 인식되기 때문입니다. 따라서 탭은 공백 수가 가변적입니다. 예를 들어 다음을 보면 이해가 쉽습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/cleancode_tabspace.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  첫 번째 셀은 공백으로 구분하고 두 번째 셀은 탭으로 구분한 것입니다. 탭을 사용하게 되면 보이는 것과 같이 다음 탭스톱(tab stop)에서 텍스트가 이어지게 되므로 공백이 가변적이게 됩니다. 따라서, 탭이 나타내는 공백 폭이 가변적이기 때문에 &lt;strong&gt;탭은 소스코드에서 사용해서는 안됩니다&lt;/strong&gt;.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  파이썬의 경우, 보편적인 들여쓰기 관례는 공백 4칸입니다. (대부분의 코드 에디터와 IDE에서 탭 키를 누르면 4개 혹은 8개의 공백 문자를 자동으로 삽입합니다.)
예를 들어, 다음 예제에서 마침표를 사용해 공백 문자를 표시했습니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getCatAmount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;....&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numCats&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;How many cats do you have?&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;....&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numCats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;........&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;You should get more cats&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;사실 저도 VCS를 활용해 코드 스크립트를 작성할 때, 무의식적으로 탭키를 사용하곤 했었습니다. 물론, VCS가 자동으로 탭키를 공백 4개로 삽입해주긴 합니다. 편의성이 있어서 탭키를 활용하지만 이 부분에 인지했으니 유의하여 사용할 수 있도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;12-코드-행-내의-공백-활용&quot;&gt;1.2 코드 행 내의 공백 활용&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;연산자와 식별자 사이에 공백 한 칸&lt;/strong&gt;&lt;br /&gt;
저도 가장 즐겨쓰는 코딩 스타일 중 하나입니다. 연산자와 식별자 사이에 공간이 없다면 답답하고 읽기 힘들어서 항상 공백을 넣어서 코드를 짭니다. 공백을 넣어주면 구분이 확연하게 잘 됩니다. 아래 잘된 예와 나쁜 예를 보면 확 와닿을 겁니다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;# 잘된 예
&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blanks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blanks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secretWord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blanks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:]&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;# 나쁜 예
&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blanks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blanks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;secreWord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blanks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;구분자는 뒤쪽에 공백 한 칸&lt;/strong&gt;&lt;br /&gt;
 쉼표와 같은 구분자를 쓸 때틑 보통 구분자 뒤쪽에 공백을 줍니다. 역시 구분자를 기준으로 앞뒤 명확하게 구분을 잘 보이게 하기 위함입니다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;# 잘된 예
&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bacon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ham&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;42.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.1415&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.718&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;# 나쁜 예1
&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bacon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ham&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;42.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.1415&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.718&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;# 나쁜 예2
&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bacon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ham&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;42.0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.1415&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.718&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;나쁜 예2 같은 경우에도 구분은 잘 되는 편이지만 뭔가 지면을 낭비하는 것 같아 선호하는 스타일은 아닙니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;마침표 앞뒤에는 공백 X&lt;/strong&gt;&lt;br /&gt;
 공백이 없으면 객체와 그 속성 간의 연결을 강조할 수 있습니다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;# 잘된 예
&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;Hello, world&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;upper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;# 나쁜 예
&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;Hello, world&apos;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;upper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;함수, 메소드, 컨테이너 이름 뒤에는 공백 X&lt;/strong&gt;&lt;br /&gt;
 함수나 메소드 명 뒤에는 괄호 쌍이 바로 따라 붙어야 쉽게 식별할 수 있습니다. 따라서, 함수나 메소드명 뒤에는 공백을 넣지 않는 게 좋습니다. 마찬가지로 인덱스, 슬라이스, 키를 쓸 때에도 대괄호 앞에 공백을 넣지 않는게 좋습니다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;# 잘된 예
&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Hello, World!&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;pet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;# 나쁜 예
&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Hello, World!&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;spam&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;pet&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;공백이 들어가있는 코드 행을 보면 어색한 것을 알 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;여는 괄호와 닫는 괄호 앞에는 공백 X&lt;/strong&gt;&lt;br /&gt;
 괄호, 대괄호, 중괄호와 괄호 안의 내용 사이에는 공백이 없는 게 좋습니다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;# 잘된 예
&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bacon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ham&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;42.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.1415&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.718&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;# 나쁜 예
&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;spam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eggs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bacon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ham&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;42.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.1415&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.718&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;물론 나쁜 예처럼 코드를 작성하더라도 전혀 문제가 되진 않습니다. 다만, 가독성이 특별히 개선되지 않으므로 굳이 써야 할 이유는 없을 것 같습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;코드행 끝 주석 앞에는 공백 2칸&lt;/strong&gt;&lt;br /&gt;
 코드 행 끝에 주석을 추가할 경우, 코드가 끝 나는 지점 뒤 2칸의 공백을 넣어준 후 주석을 입력합니다. 공백이 없는 경우는 구분하기가 어렵고 가독성이 떨어집니다. 저는 코드 행 마다 길이가 다르므로 가장 긴 코드행의 맞춰 주석을 작성하곤 했습니다. 다만, 그런 경우에는 코드 행이 짧은 경우에는 코드와 주석이 너무 떨어져 보기가 힘든 경우가 많았습니다. 이 책을 읽은 이후로는 코드 행의 주석을 추가할 경우 공백 2칸을 넣어준 뒤에 작성하고 있습니다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;# 잘된 예
&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;Hello, world!&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 인사말 출력
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;2-세로-간격&quot;&gt;2. 세로 간격&lt;/h1&gt;
&lt;p&gt;  코드를 짤 때 세로 간격을 적절하게 배치하는 것 또한 매우 중요합니다. 세로 간격(vertical spacing)은 코드 행 사이에 빈 행을 배치하는 것을 의미합니다. 책에서는 세로 간격에 대해서 가로 간격처럼 일반적인 권장사항들은 없습니다. 다만, 제가 프로그램을 짜면서 즐겨 사용하는 방식이 몇 가지 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;클래스 내 메서드는 빈 행으로 구분하기&lt;/strong&gt;&lt;br /&gt;
 클래스 내 메서드 간 빈 행으로 구분해줄 경우, 눈으로 식별하기가 한결 수월했습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;if문, 반복문, try문 등 시작 부분 빈 행으로 구분하기&lt;/strong&gt;&lt;br /&gt;
 보통 한 if문, 반복문, try문 등 한 코드 단락부분에서 시작부분 앞 코드 행과 구별해주기 위하여 빈 행을 삽입하는 방식을 즐겨합니다. 코드가 긴 경우, 빈 행으로 구분되어 있으면 코드 단략을 한 눈에 쉽게 식별할 수 있기에 자주 사용합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;세미콜론(;)은 사용 X&lt;/strong&gt;&lt;br /&gt;
 각자 개인의 취향이 있겠지만, 저는 세미콜론(;)을 거의 활용하지 않습니다. 저는 한 행의 한 코드만 들어가도록 작성하는 습관이 있어서 한 코드행의 여러 코드가 들어가는 것을 선호하지 않습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모듈당 하나의 import문으로 작성&lt;/strong&gt;&lt;br /&gt;
 모듈을 불러올 때에도 마찬가지로 하나의 모듈당 하나의 import 문을 사용하는 것을 선호합니다. PEP8에서는 import 문을 다음과 같이 세 그룹으로 묶어서 순서대로 배치할 것을 권장합니다.
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;math, os, sys등 파이썬 표준 라이브러리의 모듈&lt;/li&gt;
        &lt;li&gt;selenium, requests, django 등 서드파티 모듈&lt;/li&gt;
        &lt;li&gt;현재 작성중인 프로그램의 일부 로컬 모듈&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;의식하진 않지만 보통 모듈을 불러올 때, 보통 위에 순서대로 작성하곤 했습니다. 사실 굳이 지켜야 할 정도로 의미있는 규칙이라 생각하진 않지만 어느정도 체계가 있으면 좋을 것 같다는 생각은 합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;3-마치며&quot;&gt;3. 마치며&lt;/h1&gt;
&lt;p&gt;  코딩 스타일이란 정답이 있는 것은 아닙니다. 하지만 동일한 내용을 전달하더라도 읽기 쉬운 글이 있고 어려운 글이 있습니다. 당연히 내용이 동일하다면 읽기 수월한 글이 더 좋은 글이겠죠? 코드도 마찬가지라 생각합니다. 결국 중요한 것은 일관된 코딩 스타일을 유지하며 내가 작성한 코드를 남이 봤을 때에도 수월하게 이해할 수 있느냐는 점입니다. 코딩 스타일이 일관되지 않다면, 본인이 작성한 코드를 한참 지난 후에 보면 이해가 잘 안될 때가 많습니다. 본인이 작성한 코드도 읽기 어려운데 남이 작성한 코드는 오죽할까요😭. 답이 없기에 더 나은 스타일은 없는지 고민해보고 적용해보고 다듬어 나갈 수 밖에 없는 것이 코딩 스타일이라 생각합니다.&lt;/p&gt;
</description>
        <pubDate>Sun, 08 Oct 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/python/clean_code3/</link>
        <guid isPermaLink="true">http://localhost:4000/python/clean_code3/</guid>
        
        <category>Python</category>
        
        <category>Coding</category>
        
        <category>Review</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>[파이썬] 파이썬 준비하기: 기본 개념 알아보기</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;이 포스트의 내용은 저자 Al Sweigart의 “클린 코드, 이제는 파이썬이다” 1부 내용임을 사전에 미리 밝힙니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;안녕하세요. 우선 알아두면 좋을만한 기본 개념부터 짚어보고자 합니다.&lt;/p&gt;

&lt;h1 id=&quot;기본-개념&quot;&gt;기본 개념&lt;/h1&gt;
&lt;h2 id=&quot;파일&quot;&gt;파일&lt;/h2&gt;
&lt;p&gt;  파일은 데이터의 모임으로 보조기억장치에 저장된 것을 말한다(Naver 지식백과). 파일에는 2가지 중요한 속성이 있는데 바로 &lt;strong&gt;파일명(filename)&lt;/strong&gt;과 &lt;strong&gt;경로(path)&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;파일명&lt;/strong&gt;은 말그대로 파일의 이름과 확장자를 통해 파일의 유형을 나타낸다.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;경로&lt;/strong&gt;는 쉽게 말해서 컴퓨터에 파일의 위치를 지정한다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를 들어, mac을 기준으로 경로는 보통 다음과 같습니다.&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;/Users/mato/Documents/post.docx&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;&lt;br /&gt;
  좌측 ‘/’는 루트 디렉토리로 모든 파일 및 디렉토리의 시작점입니다. 그 아래 Users는 모든 사용자의 홈 디렉토리가 포함되어 있으며, 모든 파일, 문서 및 리소스를 저장하는데 사용됩니다. (윈도우의 경우 루트 폴더는 C:\이며, 홈 디렉토리는 C:\Users입니다) 경로에 Documents가 폴더를 의미하며 마지막 post.docx가 파일입니다.
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;작업-디렉토리working-directory&quot;&gt;작업 디렉토리(Working Directory)&lt;/h2&gt;
&lt;p&gt;  컴퓨터에 실행되는 모든 프로그램에는 현재 작업 디렉토리(current working directory, cwd)가 있습니다. 정확한 의미는 아니지만 저는 현재 프로그램이 데이터를 읽어오고 출력하는 위치라고 이해하고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;절대-경로-vs-상대경로&quot;&gt;절대 경로 vs 상대경로&lt;/h2&gt;
&lt;p&gt;파일 경로를 지정하는 방법에는 2가지 방법이 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;절대경로&lt;/strong&gt;: 항상 루트 폴더에서 시작되는 절대 경로 ex) /Users/mato/Documents/post.docx&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;상대경로&lt;/strong&gt;: 프로그램에 현재 작업 디렉토리에 따라 달라지는 상대 경로 ex) ./post.docx&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;  실무에서 저는 주로 절대 경로를 지정하여 사용하는 편이긴 합니다. 상대 경로를 사용해야 할 필요성이 아직까진 없었습니다.&lt;/p&gt;

&lt;h2 id=&quot;프로그램과-프로세스&quot;&gt;프로그램과 프로세스&lt;/h2&gt;
&lt;p&gt;  프로그램(Program)은 게임, 워드, 피피티, 웹 브라우저 등 실행할 수 있는 소프트웨어 응용프로그램(application)을 의미합니다. 프로세스(process)는 프로그램 실행 인스턴스입니다. 예를 들면, 만약 우리가 여러 개의 구글 웹 브라우저를 띄어 놓은 상황을 생각해봅시다. 이것은 하나의 웹 브라우저 프로그램의 프로세스가 여러개 동작중인 상태입니다. 또한 동일한 구글 웹 브라우저이더라도 각각 프로세스는 서로 분리된 상태로 유지된다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;명령행-인수&quot;&gt;명령행 인수&lt;/h2&gt;
&lt;p&gt;  &lt;strong&gt;명령행 인수(command line argument)&lt;/strong&gt;는 명령어 뒤에 입력하는 텍스트입니다. 파이썬 함수 호출에 전달되는 인수처럼, 명령어에 특정한 옵션이나 추가적인 지침을 제공합니다. &lt;strong&gt;명령행 옵션(command line option)&lt;/strong&gt;은 단일 문자 또는 짧은 단어로 이뤄진 명령행 인수이며 명령어에 대해 옵션을 제공한다.&lt;/p&gt;

&lt;h2 id=&quot;필수-명령어-모음&quot;&gt;필수 명령어 모음&lt;/h2&gt;
&lt;p&gt;  알아두면 좋은 자주 사용하는 명령어들입니다.&lt;/p&gt;
&lt;h3 id=&quot;1-와일드카드&quot;&gt;1. 와일드카드&lt;/h3&gt;
&lt;p&gt;  폴더나 파일명을 명령행 인수로 받는 경우, 와일드카드 문자인 *과 ?을 허용합니다. *는 개수와 무관하게 문자를 받아들이고, ?는 문자 하나만을 의미합니다. 예를 들어 “*.py”는 .py로 끝나는 모든 텍스트 집합을 의미합니다.&lt;/p&gt;

&lt;h3 id=&quot;2-cd-디렉토리-변경&quot;&gt;2. cd: 디렉토리 변경&lt;/h3&gt;
&lt;p&gt;  cd [대상 폴더]를 실행하면 작업 디렉토리가 대상 폴더로 변경됩니다.&lt;/p&gt;

&lt;h3 id=&quot;3-dir-ls-폴더-내용-열거&quot;&gt;3. dir, ls: 폴더 내용 열거&lt;/h3&gt;
&lt;p&gt;  윈도우는 dir, mac은 ls 명령어는 현재 작업 디렉토리에 위치한 모든 폴더와 파일을 표시합니다. &lt;br /&gt;
ls 명령어의 옵션 중 -l과 -a는 유용한 옵션입니다. -l은 파일 크기, 권한, 수정 시점 등 여러 정보를 포함하는 목록을 출력합니다. -a는 숨겨진 파일을 포함한 모든 파일 목록을 출력합니다. 두 옵션은 -al로 하나로 합쳐 사용할 수 있습니다.
&lt;br /&gt;&lt;br /&gt;
  윈도우에서 dir /s를 실행하면 현재 작업 디렉토리의 폴더와 하위 폴더가 모두 표시됩니다.&lt;/p&gt;

&lt;h3 id=&quot;4-copy-cp-복사하기&quot;&gt;4. copy, cp: 복사하기&lt;/h3&gt;
&lt;p&gt;  copy(cp) [원본 파일 또는 폴더] [대상 폴더] 명령어를 통해 파일이나 폴더의 복제본을 생성할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;5-move-mv-이동하기&quot;&gt;5. move, mv: 이동하기&lt;/h3&gt;
&lt;p&gt;  mv [원본 파일 또는 폴더] [대상 폴더] 명령어를 통해 파일이나 폴더를 대상폴더로 이동시킬 수 있습니다. 윈도우는 mv 대신 move를 사용하면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;6-ren-mv-이름-변경하기&quot;&gt;6. ren, mv: 이름 변경하기&lt;/h3&gt;
&lt;p&gt;  mv [파일 또는 폴더] [새 이름] 명령어를 통해 파일이나 폴더의 이름을 바꿀 수 있다. 유의해야 할 점은 mac에서 mv 명령어는 파일 이동과 파일명 변경 모두 가능합니다. 윈도우는 ren을 사용하면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;7-del-rm-파일-삭제하기&quot;&gt;7. del, rm: 파일 삭제하기&lt;/h3&gt;
&lt;p&gt;  rm [파일] 명령어를 통해 파일을 삭제할 수 있습니다. rm 명령어는 -r 옵션을 활용해야지만 폴더를 삭제할 수 있습니다. 윈도우는 del 을 사용하면 되지만 차이점이 있습니다. del 명령어의 경우 하위 폴더는 그대로 둔 채 파일만 삭제합니다. 만약 원본 폴더를 삭제하려면 rd 명령어를 사용해야 합니다. 그리고 하위 폴더 내에 폴더를 삭제하려면 del /s 명령어를 사용해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;8-md-mkdir-폴더-생성하기&quot;&gt;8. md, mkdir: 폴더 생성하기&lt;/h3&gt;
&lt;p&gt;  mkdir [새 폴더] 명령어를 통해 새 폴더를 생성할 수 있습니다. 윈도우에서는 md 명령어를 사용합니다.&lt;/p&gt;

&lt;h3 id=&quot;9-rd-rmdir-폴더-삭제하기&quot;&gt;9. rd, rmdir: 폴더 삭제하기&lt;/h3&gt;
&lt;p&gt;  폴더를 삭제하기 위해서는 rmdir(mac)와 rd(윈도우) 명령어를 사용해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;10-where-which-프로그램-위치-검색&quot;&gt;10. where, which: 프로그램 위치 검색&lt;/h3&gt;
&lt;p&gt;  mac에서는 which [프로그램], 윈도우에서는 where [프로그램] 명령어를 통헤 프로그램의 위치를 알 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;11-clear-cls-터미널-내용-삭제&quot;&gt;11. clear, cls: 터미널 내용 삭제&lt;/h3&gt;
&lt;p&gt;  지저분한 터미널 창을 지울 떄 활용하는 명령어입니다.&lt;/p&gt;
</description>
        <pubDate>Thu, 05 Oct 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/python/clean_code2/</link>
        <guid isPermaLink="true">http://localhost:4000/python/clean_code2/</guid>
        
        <category>Python</category>
        
        <category>Coding</category>
        
        <category>Review</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>[파이썬] 클린 코드, 깨끗한 코드 작성하기!</title>
        <description>&lt;p&gt;안녕하세요. 실무를 하다보면 종종 파이썬이나 R을 활용해 업무를 해야할 때가 있습니다. 특별한 체계없이 프로그램이 돌아갈 수 있을 정도로만 코드를 작성하고 개발해 왔습니다. 하지만 이러한 주먹구구식 방식으로는 한계가 분명했습니다. 프로그램을 작성한 본인도 읽기 힘든 코드, 성능을 고려하지 않은 코드, 주석과 설명이 부족한 코드, 그 외에 좋지 못한 프로그램 개발 습관까지… 더 이상 이렇게는 안되겠다는 생각이 들었습니다. 이제는 아마추어가 아닌 전문가로서 다른 누가 보더라도 인정할 수 있는 코드를 작성하고 싶었습니다. 주 목적은 내 코드에서 나는 악취를 줄여 가독성을 높이고 오류를 줄이고 성능을 개선하여 생산성을 높이고자 함입니다.&lt;br /&gt;&lt;br /&gt;
  우선 어떤 코드가 좋은 코드인지를 알기 위해서 프로그래밍 관련 책을 읽기로 했습니다. 워낙 정보가 많아서 구글링, 유투브로도 찾을 수 있었겠지만 한 권의 책으로 정리되어 있는 책을 읽어보는 것이 코드 작성에 대한 전체적인 그림을 파악할 수 있다고 생각했습니다. 따라서, 서점에 가서 이것저것 살펴보다가 다음 책은 골랐습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;클린 코드 이제는 파이썬이다. author by Al Sweigart&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/클린코드 이제는 파이썬이다.jpeg&quot; alt=&quot;image&quot; /&gt;
&lt;br /&gt;
  이 책을 읽어보고 따라하고 정리해가면서 파이썬 초보 데이터 분석가에서 전문적이고 우수한 파이썬 데이터 분석가로 진화하고자 합니다. 추가로 항상 빈약하다고 느끼던 컴퓨터 관련 전문 지식도 채울 수 있으면 정말 좋겠네요 ㅎㅎ 여하튼, 앞으로 책을 읽고 블로그 포스팅을 작성하면서 공부한 내용들을 익히고 기록하고자 합니다😊&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Oct 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/python/clean_code1/</link>
        <guid isPermaLink="true">http://localhost:4000/python/clean_code1/</guid>
        
        <category>Python</category>
        
        <category>Coding</category>
        
        <category>Review</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>[SQL] LeetCode 풀이 후기</title>
        <description>&lt;p&gt;안녕하세요. Leetcode SQL50 모든 문제를 풀어보고 정리까지 마쳤습니다. &lt;br /&gt;&lt;br /&gt;
  실무에서 Qlik Sense로 데이터 모델을 개발할 때 유사 SQL을 사용하지만 보통에 SQL과는 차이가 있었고, 그 외에는 SQL을 다룰 일이 없었습니다. 따라서, 한 번쯤은 SQL을 다시 한 번 공부해야 겠다고 생각하고 있었고 LeetCode를 선택해 풀어봤습니다. LeetCode를 선택한 이유는 일단 문제 수가 50문제로 적당했고 파트별로 나눠져 있어서 연습하기에 좋았습니다. 문제들을 풀어보면서 &lt;strong&gt;&lt;em&gt;SQL을 이렇게 활용해서 데이터를 이렇게 뽑아내는구나&lt;/em&gt;&lt;/strong&gt;하는 감을 잡을 수 있다는 점이 좋았습니다.
&lt;br /&gt;&lt;br /&gt;
  또 하나 느꼈던 점은 큰 틀에서 내가 실무에서 쓰고 있는 언어와 SQL이 유사하다는 것도 느낄 수 있어서 좋았습니다. DA에게 SQL 활용 능력이 매우 중요시 되는데, SQL 활용 능력이 떨어지진 않을까 걱정과 조바심이 있었는데 직접 다뤄보니 크게 걱정할 것은 아니란 생각이 들었습니다. 비록 부족할 순 있지만 중요한 것은 이렇게 부족한 것들은 꾸준히 채워넣을 수 있어야 하는 것이겠죠.&lt;br /&gt;&lt;br /&gt;
  마지막으로 문제를 풀면서 놓쳤던 것들은 지속적으로 공부할 예정입니다. 일회성으로 끝나지 않고 꾸준히 SQL 지식을 채워놔야 겠습니다. 이렇게 하다보면 언젠가는 SQL이 필요할 때 도움이 될 것이라 믿습니다. 후기는 이렇게 간단하게 마치겠습니다!&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Oct 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/SQL_LeetCode_Final/</link>
        <guid isPermaLink="true">http://localhost:4000/data/SQL_LeetCode_Final/</guid>
        
        <category>Data</category>
        
        <category>SQL</category>
        
        <category>LeetCode</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[SQL] LeetCode 풀이: Advanced String Functions / RegEx / Clause</title>
        <description>&lt;p&gt;안녕하세요. Leetcode SQL50 마지막 파트인 Advanced String Functions/RegEx/Clause 파트입니다. &lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;7-advanced-string-functions--regex--clause&quot;&gt;7. Advanced String Functions / RegEx / Clause&lt;/h1&gt;
&lt;h2 id=&quot;71-1667-fix-names-in-a-table&quot;&gt;7.1 1667. Fix Names in a Table&lt;/h2&gt;

&lt;p&gt;  Text 데이터의 첫 번째 글자는 대문자로 하고 그 다음 문자부터 소문자로 고치는 문제입니다.&lt;/p&gt;

&lt;h3 id=&quot;711-solution&quot;&gt;7.1.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Upper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Lower&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Substr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;From&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Users&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  텍스트를 첫 번째 글자와 나머지로 나눈 다음 각각 대문자로, 소문자로 바꿔준 다음 다시 하나의 텍스트로 합쳐주면 됩니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Concat(): 텍스트를 합치는 함수&lt;/li&gt;
    &lt;li&gt;Upper(): 텍스트를 대문자로 바꿔주는 함수&lt;/li&gt;
    &lt;li&gt;Lower(): 텍스트를 소문자로 바꿔주는 함수&lt;/li&gt;
    &lt;li&gt;Left(a: text, b: int) : a(text)를 좌측 기준으로 b(int)까지 반환하는 함수&lt;/li&gt;
    &lt;li&gt;Substr(a: text, b: int, c: int) : a(text)를 b(int)부터 c(int) 길이만큼 반환하는 함수&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;72-1527-patients-with-a-condition&quot;&gt;7.2 1527. Patients With a Condition&lt;/h2&gt;
&lt;p&gt;  진단명이 DIAB1으로 시작하는 환자를 골라내는 문자입니다. 정규표현식을 활용하여 골라내면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;721-solution&quot;&gt;7.2.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;patient_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;patient_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;conditions&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Patients&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;conditions&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;% DIAB1%&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conditions&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Like&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;DIAB1%&apos;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  진단명이 ‘DIAB1’으로 시작하는 Case만 골라와야합니다. 다만, 예시 테이블을 보면 DIAB1 앞에 다른 병명이 붙은 것을 확인할 수 있습니다. 따라서, 모든 Case를 고려하여 다음과 같이 조건을 적용하면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;73-196-delete-duplicate-emails&quot;&gt;7.3 196. Delete Duplicate Emails&lt;/h2&gt;
&lt;p&gt;  중복된 이메일을 제거합니다. 만약 중복된 이메일이 있다면 id가 큰 값을 제거해줍니다.&lt;/p&gt;

&lt;h3 id=&quot;731-solution&quot;&gt;7.3.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  Self Table Join을 활용하여 중복된 이메일 중 id가 큰 값을 제거해줍니다.&lt;/p&gt;

&lt;h2 id=&quot;74-176-second-highest-salary&quot;&gt;7.4 176. Second Highest Salary&lt;/h2&gt;
&lt;p&gt;  Employee 중 Salary가 두번째로 높은 사람을 찾는 문제입니다.&lt;/p&gt;

&lt;h3 id=&quot;741-solution&quot;&gt;7.4.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;As&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SecondHighestSalary&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  Subquery를 활용헤 Salary가 두번째로 높은 salary를 찾아줍니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offset 1&lt;/code&gt;을 통해 첫 번째 위치가 아닌 두번째 위치에서 데이터를 가져오도록 합니다.&lt;/p&gt;

&lt;h2 id=&quot;75-1484-group-sold-products-by-the-date&quot;&gt;7.5 1484. Group Sold Products By The Date&lt;/h2&gt;
&lt;p&gt;  sell_date 별로 제품 판매 수와 판매 제품들을 구하는 문제입니다.&lt;/p&gt;

&lt;h3 id=&quot;751-solution&quot;&gt;7.5.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sell_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_sold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;group_concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;products&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Activities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sell_date&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sell_date&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  특별히 어려운 문제는 아닙니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Group_Concat()&lt;/code&gt; 함수를 활용해 그룹 별로 텍스트를 하나의 텍스트로 합쳐줍니다.&lt;/p&gt;

&lt;h2 id=&quot;76-1327-list-the-products-ordered-in-a-period&quot;&gt;7.6 1327. List the Products Ordered in a Period&lt;/h2&gt;
&lt;p&gt;  2020년 2월 최소 100개의 물건을 판매한 제품을 구하는 문제입니다.&lt;/p&gt;

&lt;h3 id=&quot;761-solution&quot;&gt;7.6.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;Sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Products&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Orders&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;order_date&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;LIKE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&quot;2020-02%&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;HAViNG&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;Sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  2020년 2월 데이터를 가져오기 위해 “2020-02%”를 주면 2020-02로 시작하는 데이터만 가져오게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;77-1517-find-users-with-valid-e-mails&quot;&gt;7.7 1517. Find Users With Valid E-Mails&lt;/h2&gt;
&lt;p&gt;  유효한 이메일 형식을 가진 데이터를 불러옵니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;prefix name은 문자로 시작함&lt;/li&gt;
    &lt;li&gt;도메인은 ‘@leetcode.com’이어야함&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;771-solution&quot;&gt;7.7.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mail&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Users&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REGEXP&lt;/span&gt;  &lt;span class=&quot;s1&quot;&gt;&apos;^[A-Za-z][A-Za-z0-9_.-]*@leetcode[.]com&apos;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  정규표현식을 활용하기 위해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mail REGEXP  &apos;^[A-Za-z][A-Za-z0-9_.-]*@leetcode[.]com&apos;&lt;/code&gt;과 같이 REGEXP 구문을 활용합니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;^&lt;/strong&gt;은 다음 문자열로 시작하는 문자열을 찾습니다.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;[]&lt;/strong&gt;은 []안에 나열된 패턴의 문자열을 찾습니다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;  따라서 위 구문을 풀어보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^[A-Za-z]&lt;/code&gt;은 알파벳 문자로 시작하는 문자열을 찾습니다. 그 다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[A-Za-z0-9_.-]&lt;/code&gt;은 []안에 나열된 알파벳, 숫자, _, ., -의 문자열 조합을 가진 패턴을 찾습니다.&lt;/p&gt;
</description>
        <pubDate>Sun, 01 Oct 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/SQL_LeetCode11/</link>
        <guid isPermaLink="true">http://localhost:4000/data/SQL_LeetCode11/</guid>
        
        <category>Data</category>
        
        <category>SQL</category>
        
        <category>LeetCode</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[SQL] LeetCode 풀이: Subqueries</title>
        <description>&lt;p&gt;안녕하세요. 이번 문제부터는 Subquery 파트입니다. &lt;br /&gt;
 원하는 데이터를 추출하기 위해서는 Subquery를 능숙하게 다룰 줄 알아야 합니다. Subquery는 말 그대로 Query속 query입니다. 좀 더 자세하게 얘기하면 &lt;strong&gt;&lt;em&gt;SELECT 문 안에 또 다른 SELECT 문&lt;/em&gt;&lt;/strong&gt;을 의미합니다. Main query 안에서 괄호로 둘러쌓인 SELECT문입니다. Subquery는 어떤 값을 반환하는 곳에도 쓰이고, 테이블로 사용되거나 조건은 불러오는데 사용되기도 합니다.&lt;/p&gt;

&lt;h1 id=&quot;6-subqueries&quot;&gt;6. Subqueries&lt;/h1&gt;
&lt;h2 id=&quot;61-1978-employees-whose-manager-left-the-company&quot;&gt;6.1 1978. Employees Whose Manager Left the Company&lt;/h2&gt;

&lt;p&gt;  이 문제는 $30000 이하의 salary를 받고 manager가 직원 중 존재하지 않는(퇴사한) 직원을 구하는 문제입니다.&lt;/p&gt;

&lt;h3 id=&quot;611-solution&quot;&gt;6.1.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Employees&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30000&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;manager_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Employees&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  원하는 답을 구하기 위해서는 Where 절에 두 가지 조건이 필요합니다. 하나는 &lt;strong&gt;$30000 이하&lt;/strong&gt;와 &lt;strong&gt;manager가 퇴사한&lt;/strong&gt; 조건입니다. 2번째 조건을 만족시키기 위해서는 manager_id가 employer_id에 존재하는지 판변해야 합니다. Subquery를 사용해 Employee 테이블에서 employer_id를 가져온 다음, manager_id가 subquery를 통해 불러온 employer_id에 없는 지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Not in ()&lt;/code&gt; 구문을 활용해 필터링하면 manager가 퇴사한 employer를 필터링 할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;62-626-exchange-seats&quot;&gt;6.2 626. Exchange Seats&lt;/h2&gt;
&lt;p&gt;  학생들의 id가 연속하는 두명의 학생끼리 자리를 swap하는 문제이다. 마지막 id의 학생이 혼자일 경우 swap하지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;621-solution&quot;&gt;6.2.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;over&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group_n&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;asc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;desc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group_n&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Seat&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  문제를 풀기 위해서 2가지 step으로 나눠서 문제를 풀었다. 첫 번째는 id가 연속하는 2명의 학생끼리 그룹을 만들어 준 다음, 두번째로 두명씩 짝지어진 그룹 내에서 학생끼리 Swap을 해줬다. 단계별로 설명해보면 다음과 같다. &lt;br /&gt;
  학생들을 두 명씩 그룹짓기 위해 학생들의 id를 2로 나눠준 다음 그 몫을 구했다. 예를 들면, 학생의 id가 1과 2인 학생들의 id를 2로 나눈 값을 반올림하면 1, 2와 3인 학생들의 id를 2로 나눈 값을 반올림하면 2이므로 2명씩 순차적으로 짝지어지게 된다. 이렇게 두 명씩 그룹화 할 수 있다. 이런 방식으로 그룹화를 하고 Subquery로 불러온다.&lt;br /&gt;
  다음으로는 그룹 내에 학생들의 id의 순서를 바꿔주면 됩니다. 순서를 바꿔주기 위해서 window function 중 하나인 rank 함수를 활용했습니다. Order by 기능을 이용해 group_n을 오름차순 순으로, 그 다음 기존 id를 내림차순 순으로 정렬해 rank를 부여하면 자연스럽게 순서가 바뀐 id를 갖게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;63-1341-movie-rating&quot;&gt;6.3 1341. Movie Rating&lt;/h2&gt;
&lt;p&gt;  두 가지 답을 찾아야 하는 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;가장 높은 평점을 부여한 사람&lt;/li&gt;
    &lt;li&gt;2020년 2월 가장 높은 평균 평점을 받은 영화&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;631-solution&quot;&gt;6.3.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;As&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MovieRating&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;As&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;desc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;UNION&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;As&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MovieRating&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Movies&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;movie_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;movie_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;created_at&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&quot;2020-02-%&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;movie_id&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rating&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;desc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  Subquery를 사용하지 않고도 간단하게 풀리는 문제입니다. 각각 답을 구한 후, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNION ALL&lt;/code&gt;을 활용해 테이블을 합쳐줍니다.&lt;/p&gt;

&lt;h2 id=&quot;64-1321-restaurant-growth&quot;&gt;6.4 1321. Restaurant Growth&lt;/h2&gt;
&lt;p&gt;  레스토랑에서 매일 지난 7일동안 평균 매출액을 구하는 문제입니다. 일별로 지난 7일동안 평균 매출액을 구해야 하기 때문에 window function을 활용했습니다.&lt;/p&gt;

&lt;h3 id=&quot;641-solution&quot;&gt;6.4.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited_on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average_amount&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;visited_on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;SUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Over&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited_on&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;RANGE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BETWEEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DAY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRECEDING&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ROW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;MIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited_on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OVER&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st_date&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Customer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited_on&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st_date&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  지난 7일간 평균 매출액을 구하기 위해 우선 지난 7일간 매출액 합계를 구하기 위해 window function을 활용했습니다. 지난 7일간을 어떻게 구현하면 될까요? 다음과 같은 구문을 활용했습니다. &lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sum(amount) Over (ORDER BY visited_on RANGE BETWEEN INTERVAL 6 DAY PRECEDING AND CURRENT ROW)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  특정 구간을 구하기 위해서 보통 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BETWEEN A AND B&lt;/code&gt;와 같이 BETWEEN 구문을 활용합니다. visited_on(방문일)을 기준으로 정렬하고, A에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INTERVAL 6 DAY PRECEDING&lt;/code&gt;는 현재로부터 6일전을 의미하고 B에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CURRENT&lt;/code&gt;는 현재를 의미합니다. 따라서 visited_on을 기준으로 6일 전 ~ 오늘까지를 의미하게 되며 그 기간동안의 합계를 구하는 구문이 됩니다. 복잡해 보일 수 있지만 하나하나 뜯어보면 어렵지 않게 이해할 수 있습니다.&lt;br /&gt;
  그 다음 ‘1st_date’를 구해줍니다. 이는 visited_on을 기준으로 과거 6일치의 데이터가 없는 케이스를 제거해주기 위함입니다. 최종 테이블을 구현하기 위한 테이블 구문을 subquery로 미리 테이블을 불러온 다음 마지막으로 평균 매출액을 구하면 쉽게 최종 테이블을 구할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;65-602-friend-requests-ii-who-has-the-most-friends&quot;&gt;6.5 602. Friend Requests II: Who Has the Most Friends&lt;/h2&gt;
&lt;p&gt;  가장 많은 친구를 가진 사람과 가장 많은 사람과 친구인 사람을 구하는 문제입니다.&lt;/p&gt;

&lt;h3 id=&quot;651-solution&quot;&gt;6.5.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;requester_id&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accepter_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;RequestAccepted&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;requester_id&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UNION&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;accepter_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;requester_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;RequestAccepted&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;accepter_id&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;desc&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  Subquery안에 UNION ALL 구문을 활용해 테이블을 불러왔습니다. 하나하나 뜯어보겠습니다.&lt;br /&gt;
  첫 번째 테이블을 보면, requerster_id별로 accepter_id 수를 집계했습니다. 두 번째 테이블은 반대로 accepter_id별로 requester_id 수를 집계했습니다. 각각 수를 집계한 이유는 요청자와 수락자 한 쌍이 모두 친구이기 때문입니다. 예를 들어, 1번이 2번에게 요청한 경우 1과 2는 친구이고, 3번이 1번에게 친구를 요청한 경우도 1과 3은 친구입니다. 따라서 1번에게는 2, 3의 친구 즉 2명의 친구가 있는 것입니다. 따라서 모든 id별로 각각 수를 집계한 것입니다.
&lt;br /&gt;
  id별로 requseter_id, accepter_id를 모두 집계한 다음 id별로 합계를 구한다면 총 친구 수를 구할 수 있습니다. 여기서 친구 수를 내림차순으로 정렬한 다음 가장 최상단에 값만 불러오면 가장 많은 친구를 가진 id를 찾을 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;66-585-investments-in-2016&quot;&gt;6.6 585. Investments in 2016&lt;/h2&gt;
&lt;p&gt;  다음 조건을 만족하는 2016년 총 투자액을 구하는 문제입니다. 조건은 다음과 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;2개 이상의 정책의 tiv_2015가 동일해야함&lt;/li&gt;
    &lt;li&gt;다른 policyholder와 지역이 겹치지 않아야 함&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;661-solution&quot;&gt;6.6.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tiv_2016&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tiv_2016&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Insurance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;INNER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Insurance&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;HAVING&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;On&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tiv_2015&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tiv_2015&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Insurance&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tiv_2015&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Having&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  이 문제를 풀기 위해 2개의 subquery를 활용했습니다. 우선 INNER JOIN 절에 있는 subquery부터 보겠습니다.&lt;br /&gt;
  pid별로 지역이 겹치지 않는 pid만 남기기 위해 INNER JOIN을 수행한 사례입니다. lat과 lon을 concat(string을 결합)하여 t라는 컬럼을 생성하고 HAVING절을 통해 t가 1개인 경우만 불러옵니다. 이 테이블을 Insurance 테이블과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;On concat(i.lat, i.lon) = i2.t&lt;/code&gt; 키를 활용해 결합한다면 i2 테이블의 t의 수가 1인 케이스만 결합되기에 지역이 겹치는 pid는 모두 제외되게 됩니다.
&lt;br /&gt;
  그 다음 tiv_2015가 두 개 이상 동일한 케이스를 불러오기 위해 WHERE 절에도 subquery를 활용해줍니다. subquery를 활용해 tiv_2015별로 pid 수를 집계한다음 그 수가 2개 이상인 경우만 불러온 후, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tiv_2015 in ()&lt;/code&gt;을 활용해 조건을 주면 원하는 최종 테이블을 추출할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;67-185-department-top-three-salaries&quot;&gt;6.7 185. Department Top Three Salaries&lt;/h2&gt;
&lt;p&gt;  부서 별로 연봉이 가장 높은 3명의 사람을 구하는 문제입니다.&lt;/p&gt;

&lt;h3 id=&quot;671-solution&quot;&gt;6.7.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Department&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Salary&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; 
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dense_rank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OVER&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Partition&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;departmentId&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;desc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salary_rank&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Department&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;departmentId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;salary_rank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  어렵지 않게 푼 문제입니다. Window function 중 하나인 dense_rank() 함수를 활용해 부서별로 salary가 높은 순서를 구합니다. dense_rank는 중복된 것들은 하나로 처리하여 순서를 부여합니다.(2등이 2명일 경우 다음 등수를 4로 가지 않고 3으로 부여) 그 다음 Join 절을 이용해 부서명을 붙여주고 salary_rank가 3 이하인 경우를 구해주면 부서별로 salary가 높은 3명을 구할 수 있습니다!&lt;/p&gt;
</description>
        <pubDate>Sun, 01 Oct 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/SQL_LeetCode10/</link>
        <guid isPermaLink="true">http://localhost:4000/data/SQL_LeetCode10/</guid>
        
        <category>Data</category>
        
        <category>SQL</category>
        
        <category>LeetCode</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[SQL] LeetCode 풀이: Advanced Select and Joins(2/2)</title>
        <description>&lt;p&gt;  안녕하세요. 바로 이어가겠습니다!&lt;/p&gt;

&lt;h1 id=&quot;5-advanced-and-select-joins&quot;&gt;5. Advanced and Select Joins&lt;/h1&gt;
&lt;h2 id=&quot;54-180-consecutive-numbers&quot;&gt;5.4 180. Consecutive Numbers&lt;/h2&gt;

&lt;p&gt;  이 문제는 적어도 3번 이상 반복되는 숫자를 구하는 문제입니다. 다양한 방법이 있겠지만 저는 Window 함수를 사용해 풀었습니다.&lt;/p&gt;

&lt;h3 id=&quot;541-solution&quot;&gt;5.4.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Distinct&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConsecutiveNums&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;over&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;over&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_2&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Logs&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  Window 함수 중에서 lead와 lag 중 원하는 것을 활용하면 됩니다. lag 혹은 lead만 2번 써도 되고 두 함수 모두 사용해도 됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lag(num, 1) over()&lt;/code&gt;은 num 컬럼에 바로 다음 순서의 데이터를 불러오고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lag(num 2) over&lt;/code&gt;은 그 다음 2번째 데이터를 불러옵니다. 그렇게 테이블을 만든 다음에 num, num_1과 num_2가 모두 데이터만 불러오면 3번 반복되는 숫자를 가져올 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;542-good-to-know---window-function&quot;&gt;5.4.2 Good to Know - Window Function&lt;/h3&gt;
&lt;p&gt;  Window 함수는 group by 없이 집계함수를 쓰거나 순위, 행간의 데이터 전처리를 수행할 때 많이 사용됩니다. Window 함수에 대한 기본 양식은 다음과 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Funcion(Column) over (Partition By A Order By B)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  window로 활용할 수 있는 함수는 기본적인 aggregate function(sum, avg, count 등)과 nonaggregate function(rank, lead, lag 등)이 있습니다. 그리고 over 안에 Partition By는 Group By와 유사합니다. 예를 들어, 그룹 별 집계할 때 쓰이기도 하고, 그룹 내 Ranking을 찾을 때에도 쓰입니다. Order By는 말 그대로 정렬하는 기능이며 Order By와 동일합니다. &lt;br /&gt;
  Window 함수는 내용이 많아 여기 다 적긴 어렵고 따로 자세하게 적을 예정입니다!&lt;/p&gt;

&lt;h2 id=&quot;55-1164-product-price-at-a-given-date&quot;&gt;5.5 1164. Product Price at a Given Date&lt;/h2&gt;
&lt;p&gt;  특정 시점(2019-08-16)에 모든 제품의 가격을 구하는 문제입니다. 하나 특이한 점은 Products 테이블에는 new_price 정보와 변경 날짜만 담겨있습니다. 변경 이전 금액은 모두 10으로 동일하다고 합니다. 따라서 케이스를 다음과 같이 2가지로 나눠야 합니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;2019-08-16 이전에 가격이 바뀐 경우&lt;/li&gt;
    &lt;li&gt;2019-08-16 이후에 가격이 바뀐 경우&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;551-solution&quot;&gt;5.5.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;new_price&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;price&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Products&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;change_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;change_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;From&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Products&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;change_date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;2019-08-16&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;UNION&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;price&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Products&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Having&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;change_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;2019-08-16&apos;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  전 위 두가지 케이스 각각 해당하는 query를 질의하여 테이블을 불러오고 UNION을 활용하는 것으로 문제를 해결했습니다. 한 번에 처리하는 방법이 떠오르지 않더라구요. &lt;br /&gt;
  첫 번째 케이스를 처리하기 위해서 변경 날짜가 2019-08-16 이전에 제품별로 가장 최근 가격 변경 날짜의 케이스만 불러왔습니다. 이 경우에는 2019-08-16 이전에 제품의 가격 변경이 있었고 new-price가 곧 price가 됩니다. &lt;br /&gt;
  두 번째 케이스를 처리하기 위해서는 제품별로 첫 가격 변경 날짜가 2019-08-16 이후인 케이스만 불러오면 됩니다. 첫 가격 변경 날짜가 2019-08-16 이후인 케이스는 2019-08-16에는 price가 10이기 때문에, price 값을 10으로 설정해주면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;56-1204-last-person-to-fit-in-the-bus&quot;&gt;5.6 1204. Last Person to Fit in the Bus&lt;/h2&gt;
&lt;p&gt;  버스 탑승객의 총 무게가 1000km에 제한이 있고, 대기자들 중 가장 마지막으로 탑승하는 사람을 찾으면 되는 문제입니다. 저는 탑승대기자들을 순서대로 정렬한 후, 몸무게를 누적합해서 1000kg limit에 걸리는 사람을 찾았습니다.&lt;/p&gt;

&lt;h3 id=&quot;531-solution&quot;&gt;5.3.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;person_name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;person_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;person_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;SUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;over&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total_weight&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Queue&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;asc&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;total_weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;total_weight&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;desc&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  누적합을 구하기 위해서 위 5.4 케이스처럼 window 함수를 활용했습니다. Partition by 는 필요없으니 쓰지 않고 순서대로 정렬(order by turn)해준 다음 합계를 구하면 순서대로 누적합을 구할 수 있습니다. 누적합을 구했다면 이제 1000kg가 넘기 직전 마지막 사람을 구하면 됩니다. 저는 total_weight를 내림차순하여 가장 윗(limit 1)사람을 불러왔습니다.&lt;/p&gt;

&lt;h2 id=&quot;56-1907-count-salary-categories&quot;&gt;5.6 1907. Count Salary Categories&lt;/h2&gt;
&lt;p&gt;  income을 category화 하는 문제입니다.&lt;/p&gt;

&lt;h3 id=&quot;531-solution-1&quot;&gt;5.3.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;s1&quot;&gt;&apos;Low Salary&apos;&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;income&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;accounts_count&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Accounts&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UNION&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;s1&quot;&gt;&apos;Average Salary&apos;&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;income&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Between&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20000&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;accounts_count&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Accounts&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UNION&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;s1&quot;&gt;&apos;High Salary&apos;&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;income&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;accounts_count&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Accounts&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  union을 활용해 Low, Average, High Salary 별로 query를 질의한 다음 합쳤습니다. 보통 다수의 프로그래밍 언어에서 bool 형태의 데이터 타입은 int 타입과 매칭되는데 True -&amp;gt; 1로, False -&amp;gt; 0으로 치환됩니다. 따라서 Sum(조건 문)의 경우, 조건을 만족하는 수를 구하는 쿼리가 됩니다. &lt;br /&gt;
  처음에 Union을 쓰지 않고 CASE 구문을 활용해서 그룹 별로 category화 한 다음 Count하여 집계하려 했는데 문제가 풀리지 않았습니다. 왜냐하면 Average 그룹에 해당하는 데이터가 없었기에 Count로 집계한 경우 Null로 제외되기 때문입니다. 단순히 문제를 푸는 것을 떠나서 실상황에서 데이터를 추출할 때 0값인 경우도 필요한지 아닌지에 따라 적절한 Query를 사용해야 합니다. 딱 보면 한눈에 결과가 그려지는 실력이면 좋겠지만, 이렇게 해보면서 경험을 쌓아가고 공부하는 수밖에 없을 것 같네요. 하다보면 언젠가는 고수의 경지에 오를 수 있겠죠!ㅎㅎ&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Sep 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/SQL_LeetCode9/</link>
        <guid isPermaLink="true">http://localhost:4000/data/SQL_LeetCode9/</guid>
        
        <category>Data</category>
        
        <category>SQL</category>
        
        <category>LeetCode</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[SQL] LeetCode 풀이: Advanced Select and Joins(1/2)</title>
        <description>&lt;p&gt;  안녕하세요. 이번 Section은 Advanced Select and Joins입니다.&lt;/p&gt;

&lt;h1 id=&quot;5-advanced-and-select-joins&quot;&gt;5. Advanced and Select Joins&lt;/h1&gt;
&lt;h2 id=&quot;51-1731-the-number-of-employees-which-report-to-each-employee&quot;&gt;5.1 1731. The Number of Employees Which Report to Each Employee&lt;/h2&gt;
&lt;p&gt;  모든 manager에 이름과 다이렉트로 보고하는 employee에 수, 그리고 employee의 평균 나이를 구하는 문제입니다.
단계를 나눠보면,&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;manager 알아내기&lt;/li&gt;
    &lt;li&gt;manager에게 리포트하는 employee 수 집계하기&lt;/li&gt;
    &lt;li&gt;manager에게 리포트하는 employee의 평균 나이 집계하기&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;순으로 정리하면 될 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;511-solution&quot;&gt;5.1.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt;             &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reports_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average_age&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Employees&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;INNER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Employees&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reports_to&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  manager를 찾아내기 위해 Self Table Join을 활용했습니다. Join Key를 a 테이블에서는 employee_i와 b 테이블에서 reports_to로 설정해 줍니다. 게다가 INNER Join을 했기 때문에 a.employee_id와 b.reports_to가 두 테이블에 모두 있는 케이스만 Join이 됩니다. 그려보면 a 테이블에는 매니저만 남고, b 테이블이 employee가 join되는 그림입니다. 따라서 최종 테이블에 manager만 남게 됩니다.&lt;br /&gt;
  그 다음부터는 집계함수를 이용하여 집계하면 문제는 풀립니다!&lt;/p&gt;

&lt;h2 id=&quot;52-1789-primary-department-for-each-employee&quot;&gt;5.2 1789. Primary Department for Each Employee&lt;/h2&gt;
&lt;p&gt;  Employee 별로 primary department를 구하는 문제입니다. 이 문제에서 고려해야 할 점은 employee가 속한 department가 꼭 1개가 아니라 1개 이상인 경우가 있다는 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;521-solution&quot;&gt;5.2.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;department_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;primary_flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Y&apos;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;UNION&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;department_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; 
                    &lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Having&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  Employee 별로 속한 department수가 상이하기 때문에 아예 나눠서 처리하는 게 적절해 보입니다. 1. department가 2개 이상인 경우, primary_flag = ‘Y’인 조건으로 primary department를 구하고 2. 1개일 경우는 그 department가 primary department이기에 department수가 1개인 경우만 조건으로 걸어서 primary department를 구해줍니다. 그 다음에는 Union을 활용해 두 결과를 하나의 테이블로 구해주면 됩니다!&lt;/p&gt;

&lt;h3 id=&quot;522-good-to-know---union&quot;&gt;5.2.2 Good to Know - UNION&lt;/h3&gt;
&lt;p&gt;  SQL에서는 UNION과 UNION ALL을 활용해 두 테이블을 하나의 테이블로 합칠 수 있습니다. 파이썬에서 pd.concat()과 유사한 것으로 생각하면 되겠네요. 사용법은 간단합니다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(A 테이블) UNION (ALL) (B 테이블)&lt;/code&gt; 입니다. 컬럼명을 기준으로 union되는 것 같으니 컬럼명에 주의하고 활용하면 됩니다. UNION의 경우에는 중복값을 제거하는 반면, UNION ALL은 중복값을 제거해주지 않으므로 상황에 맞게 사용하시면 됩니다!&lt;/p&gt;

&lt;h2 id=&quot;53-610-triangle-judgement&quot;&gt;5.3 610. Triangle Judgement&lt;/h2&gt;
&lt;p&gt;  x, y와 z 변의 길이로 삼각형을 그릴 수 있는지를 판변하는 문제입니다. 3변의 길이가 주어졌을 때, 삼각형임을 판별하는 식은 다음과 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;가장 큰 변의 길이가 다른 두 변의 길이의 합보다 작아야 함&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;531-solution&quot;&gt;5.3.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;WHEN&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;Then&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Yes&apos;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;ELSE&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;No&apos;&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triangle&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Triangle&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  Case 구문을 활용해서 삼각형을 판별할 수 있는 조건을 줍니다. 다만, x, y와 z 중, 가장 큰 변의 길이가 무엇인지 모르기 때문에 x, y와 z 각각 판별해줘야 합니다. 만약, x, y와 z 중 하나라도 위 조건을 만족하지 못한다면 삼각형을 형성할 수 없습니다. 따라서 위 조건을 모두 만족하는 경우 ‘Yes’, 하나라도 만족하지 못하는 경우에는 ‘No’로 판별해주기 위에 각 조건들을 And로 연결했습니다!&lt;/p&gt;

&lt;h3 id=&quot;532-good-to-know---case구문&quot;&gt;5.3.2 Good to Know - CASE구문&lt;/h3&gt;
&lt;p&gt;  CASE 구문은 주로 여러 조건에 따라 구분해야 할 때 사용합니다. 필요한 조건이 하나인 경우에는 If()를 사용할 수 있지만 여러개인 경우 CASE 구문을 사용하는게 적절합니다. 그리고 직관적으로 이해할 수 있고 사용법도 쉽습니다. 기본적인 사용법은 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CASE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;WHEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AA&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;WHEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BB&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;WHEN&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CC&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ELSE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DD&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CASE_EXAMPLE&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  A를 만족하는 경우 AA를 할당하고 B를 만족하는 경우 BB, C를 만족하는 경우 CC, A,B와 C 어디에도 해당하지 않는 경우에 DD를 할당합니다.&lt;/p&gt;
</description>
        <pubDate>Sat, 16 Sep 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/SQL_LeetCode8/</link>
        <guid isPermaLink="true">http://localhost:4000/data/SQL_LeetCode8/</guid>
        
        <category>Data</category>
        
        <category>SQL</category>
        
        <category>LeetCode</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[SQL] LeetCode 풀이: Sorting and Grouping(2/2)</title>
        <description>&lt;p&gt;  안녕하세요. 드디어 문제는 다 풀었습니다! 문제 풀었던 것들 정리하면서 부족한 부분은 채우고자 합니다. 문제를 어떻게 풀었는지와 공부한 것들만 적고 필요없는 부분은 굳이 안 적으려고 합니다.&lt;/p&gt;

&lt;h1 id=&quot;4-sorting-and-grouping&quot;&gt;4. Sorting and Grouping&lt;/h1&gt;
&lt;h2 id=&quot;46-1729-find-followers-count&quot;&gt;4.6 1729 Find Followers Count&lt;/h2&gt;
&lt;p&gt;  각 user 별로 follower가 몇 명인지를 구하는 문제입니다. 쉬운 문제네요.&lt;/p&gt;

&lt;h3 id=&quot;461-solution&quot;&gt;4.6.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;follower_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;followers_count&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Followers&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;asc&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  user 별로 follwer 수를 집계하면 됩니다!&lt;/p&gt;

&lt;h2 id=&quot;47-619-biggest-single-number&quot;&gt;4.7 619. Biggest Single Number&lt;/h2&gt;
&lt;p&gt;  MyNumbers Table에 num 중 오직 한 번만 나타난 것 중 가장 큰 값을 구하는 문제입니다. num 별로 수를 count로 집계하여 그 값이 1인 num만 가져오는 조건을 주면 될 것 같습니다.&lt;/p&gt;
&lt;h3 id=&quot;471-solution&quot;&gt;4.7.1 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MyNumbers&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyNumbers&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;HAVING&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  문제를 보고 떠올렸던 것은 우선 NyNumbers에서 중복되지 않은 값만 추려서 가져오자였습니다. 그래서 HAVING을 사용해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count(num) = 1&lt;/code&gt; 조건을 걸어서 중복된 값들은 제거했습니다.
그 다음에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt;을 사용해 해당 num만 가져온 후, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max&lt;/code&gt;값을 구했습니다.&lt;/p&gt;

</description>
        <pubDate>Tue, 12 Sep 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/SQL_LeetCode7/</link>
        <guid isPermaLink="true">http://localhost:4000/data/SQL_LeetCode7/</guid>
        
        <category>Data</category>
        
        <category>SQL</category>
        
        <category>LeetCode</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[회고록] 23년 9월 1주차: 에너지 절감(2/2)</title>
        <description>&lt;p&gt;  안녕하세요. 지난 &lt;a href=&quot;https://mato-park.github.io/data/weekly_memoir_5/&quot;&gt;회고록&lt;/a&gt;에서 적었던 에너지 절감 프로젝트가 마무리되어 가고 있습니다. 프로젝트를 진행하면서 &lt;a href=&quot;https://mato-park.github.io/data/weekly_memoir_7/&quot;&gt;분석 모델링&lt;/a&gt;도 수행하기도 했고 이 얘기에 이어서 마무리 짓지 못했던 회고록을 이어서 작성해보겠습니다. 
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-에너지-절감-포인트-도출&quot;&gt;4. 에너지 절감 포인트 도출&lt;/h2&gt;
&lt;p&gt;  앞의 과정이 끝났다면 에너지 별로 문제점 진단이 끝났을 것입니다. 그럼 데이터 분석을 통한 에너지 절감이 가능한 경우는 다음과 같이 정리가 될 것입니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;에너지 사용량의 산포(범위, 표준편차, 분산, 사분위 범위 등)가 큰 경우&lt;/li&gt;
    &lt;li&gt;과거 설비 운전 패턴이 다양한 경우&lt;/li&gt;
    &lt;li&gt;공정 품질 수준이 관리선 대비 여유가 큰 경우&lt;/li&gt;
    &lt;li&gt;에너지 관련 관리 지표의 변동이 있는 경우&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;  각 상황 별로 분석한 내용에 대해서 간략하게 정리하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;41-에너지-사용량-산포-원인분석&quot;&gt;4.1 에너지 사용량 산포 원인분석&lt;/h3&gt;
&lt;p&gt;  말 그대로 에너지 사용량 산포가 큰 이유를 찾아내는 것입니다. 어떤 공정, 품질 인자로 인하여 에너지 사용량의 변동이 큰지 탐색해 나갑니다. 우선 공정 별로 &lt;strong&gt;공정 메커니즘 이해&lt;/strong&gt;가 중요합니다. 왜냐하면 공정 별로 중요한 외생 변수는 무엇인지, 후보인자를 선별해야 하기 때문입니다. 중요 외생변수를 통제해가면서 에너지 사용량과 상관성이 높은 변수들을 탐색해 나갑니다. 주로 EDA를 하면서 인자들을 탐색하고 필요하다면 분석 모델링을 통해 다변량이 에너지 사용량에 미치는 효과를 추정해내기도 합니다.&lt;br /&gt;&lt;br /&gt;
  주요 인자들을 통제했음에도 불구하고 산포가 남아있는 경우가 바로 에너지 절감 포인트입니다. 공정 최적화가 되지 못해 에너지 사용량의 낭비가 있거나, 너무 과도하게 품질을 관리하고 있는 경우기 있을 수 있습니다. 주요 인자들을 제외한 공정 인자의 변동이 에너지 사용량의 영향을 미친다면 최적화를 통해 에너지 절감이 가능합니다.&lt;br /&gt;&lt;br /&gt;
  에너지 사용량의 산포가 있음에도 공정 인자와 매치되지 않는 경우는 설비 이상을 의심해봐야 합니다. 하지만 이 부분은 데이터로 볼 수 있는 부분이 아니기에, 우리는 문제점만 전달하고 현업 담당자에게 뒷 일은 맡겨야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;42-최적-설비-운전-패턴-도출&quot;&gt;4.2 최적 설비 운전 패턴 도출&lt;/h3&gt;
&lt;p&gt;  특정 공정 관리 인자의 온도를 맞추기 위해서 열매의 온도와 유량을 조정하면서 열교환을 합니다. 이때 다양한 운전 패턴이 있을 수 있습니다. 그렇다면 이 운전 패턴 간 에너지 사용량을 비교해보고 어떤 운전 패턴이 최적인지 탐색해볼 수 있습니다. 쉽게 예를 들면, 여름에 더울 때 에어컨 온도를 낮추고 바람 세기를 적게 하는 것이 더 효율적인지 혹은 온도를 조금 높이고 바람 세기를 세게 하는 것이 효율적인지를 비교해보는 것이라 생각하면 될 것 같습니다. &lt;br /&gt;&lt;br /&gt;
  너무 쉽고 당연한 얘기죠? 하지만 의외로 이런 곳에서 절감포인트가 나옵니다. 데이터 인프라가 약한 조직이라면 과거 긴 시간의 데이터를 활용하지 못하기 때문에 분명히 놓치고 있는 것이 있을 수 있기 때문에 확인하면 좋은 포인트입니다.&lt;/p&gt;

&lt;h3 id=&quot;43-공정-품질-수준이-관리선-대비-여유가-큰-경우&quot;&gt;4.3 공정 품질 수준이 관리선 대비 여유가 큰 경우&lt;/h3&gt;
&lt;p&gt;  공정 관리 수준이 너무 타이트할 수 있습니다. 공정의 여유가 있다면 품질 수준을 조금 낮추고 에너지 사용량을 줄이는 방안도 고려해 볼 수 있습니다. 다만 이 부분도 분석가의 역할은 현황만 진단하고 나머지 판단은 현업에 맡겨야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;44-에너지-관리-지표의-변동이-있는-경우&quot;&gt;4.4 에너지 관리 지표의 변동이 있는 경우&lt;/h3&gt;
&lt;p&gt;  예를 들어, 냉수 온도를 일정하게 유지해야 하는데 계절 별로 온도가 변동하는 경우가 있습니다. 이 경우, 데이터를 확인해 특별한 이유가 있는지 혹은 연관된 인자의 변동을 살펴보고 특별한 이유가 없다면 모종의 이유로 에너지가 낭비되고 있을 수 있습니다. 이 부분도 확인해보면 에너지 절감 포인트를 도출하는데 도움이 될 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;5-개선안-도출&quot;&gt;5. 개선안 도출&lt;/h2&gt;
&lt;p&gt;  분석을 통해 도출한 에너지 절감 포인트를 활용하여 에너지 사용량 개선안을 내야 합니다. 사실 이 부분부터는 분석가의 역할이 아니라 현업 담당자의 역할입니다. 분석을 통해 발견한 인자를 최적화하거나 혹은 분석 결과를 기반으로 아이디어를 도출해 개선안을 수립하고 실제 공정에 Test해보고 결과를 비교해봅니다. &lt;br /&gt;&lt;br /&gt; 
  뻔한 얘기지만 좋은 개선안을 내기 위해서는 좋은 분석의 선행이 필수인 것 같습니다. 왜냐하면 현업 담당자들을 에너지 절감을 위해 이미 다양한 아이디어를 내고 개선 활동을 하고 있기에, 새로운 것을 제시하고 설득하기 위해서는 철저한 논리와 데이터 기반의 객관적인 근거가 필요하기 때문입니다.&lt;/p&gt;

&lt;h2 id=&quot;6-모니터링-시스템-구축&quot;&gt;6. 모니터링 시스템 구축&lt;/h2&gt;
&lt;p&gt;  분석하고 개선안 내서 적용하면 끝일까요? 아닙니다. 에너지 사용량이 잘 관리되고 있는지 모니터링 할 수 있는 시스템이 필요합니다. 이번 프로젝트에서는 BI Tool을 활용해 향후 일별로 에너지 사용량을 모니터링 할 수 있는 시각화 대시보드 App을 개발하여 활용할 수 있게 했습니다. 앞으로는 과거 데이터와 비교하여 현재 에너지 사용량이 적절한지 판단할 수 있는 시스템이 갖춰졌습니다. 조직원 모두가 에너지 사용량을 확인할 수 있고 분석할 수 있습니다. 어쩌면 데이터 기반 의사결정 문화에도 큰 도움이 되리라 생각합니다.&lt;/p&gt;

&lt;h2 id=&quot;7-프로젝트를-마치며&quot;&gt;7. 프로젝트를 마치며..&lt;/h2&gt;
&lt;p&gt;  에너지 절감 분석 프로젝트를 해보니 &lt;strong&gt;현업 담당자들이 놓치고 있던 부분을 데이터를 활용해 짚어내는 것&lt;/strong&gt;이 주효했던 것 같습니다. 생각보다(?) 현업 담당자들은 다 잘하고 있고 문제없다 얘기하지만, 데이터를 까보면 아닌 경우가 허다했습니다. 그리고 분석의 난이도가 높아서 어렵다기보다는 공장의 모든 설비와 에너지를 살펴봐야 했기에 힘들었던 분석이었습니다. 그래도 에너지 별로 낭비요소를 찾아내고 개선이 이뤄지는 것을 보면서 역시 뿌듯하고 즐거웠던 프로젝트였습니다. 물론 아직 끝나지 않았습니다…&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Sep 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/weekly_memoir_9/</link>
        <guid isPermaLink="true">http://localhost:4000/data/weekly_memoir_9/</guid>
        
        <category>Data</category>
        
        <category>Memoir</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[SQL] LeetCode 풀이: Sorting and Grouping(1/2)</title>
        <description>&lt;p&gt;  안녕하세요. LeetCode50 50문제 별로 없네 생각하면서 시작했는데 고민해보고 정리하면서 하다보니 예상보다는 길어지네요. 부지런히 공부해서 8월달 내에는 끝내야겠습니다&lt;/p&gt;

&lt;h1 id=&quot;4-sorting-and-grouping&quot;&gt;4. Sorting and Grouping&lt;/h1&gt;
&lt;h2 id=&quot;41-number-of-unique-subjects-taught-by-each-teacher&quot;&gt;4.1 Number of Unique Subjects Taught by Each Teacher&lt;/h2&gt;
&lt;h3 id=&quot;411-table-description--question&quot;&gt;4.1.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Teacher&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Colum Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;teacher_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;subject_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dept_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;(subject_id, dept_id) is the primary key for this table.&lt;br /&gt;
Each row in this table indicates that the teacher with teacher_id teaches the subject subject_id in the department dept_id.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Calculate the number of unique subjects each teacher teaches in the university.&lt;/li&gt;
  &lt;li&gt;Return the result table in any order.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;412-solution&quot;&gt;4.1.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;teacher_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subject_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Teacher&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;teacher_id&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  선생님 별로 가르치는 과목 수를 구하면 된다. 중복을 제거하기 위하여 count 함수 안에 ‘distinct’를 적어주자 끝!&lt;/p&gt;

&lt;h2 id=&quot;42-user-activity-for-the-past-30-days-1&quot;&gt;4.2 User Activity for the Past 30 Days 1&lt;/h2&gt;
&lt;h3 id=&quot;421-table-description--question&quot;&gt;4.2.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Activity&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Colum Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;user_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;session_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;activity_date&lt;/td&gt;
      &lt;td&gt;date&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;activity_type&lt;/td&gt;
      &lt;td&gt;enum&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;There is no primary key for this table, it may have duplicate rows.&lt;br /&gt;
The activity_type column is an ENUM of type (‘open_session’, ‘end_session’, ‘scroll_down’, ‘send_message’).&lt;br /&gt;
The table shows the user activities for a social media website. &lt;br /&gt;
Note that each session belongs to exactly one user.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Write an SQL query to find the daily active user count for a period of 30 days ending 2019-07-27 inclusively. A user was active on someday if they made at least one activity on that day.&lt;/li&gt;
  &lt;li&gt;Return the result table in any order.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;422-solution&quot;&gt;4.2.2 Solution&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;Select&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;activity_date&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;As&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;day&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;As&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;active_users&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Activity&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;activity_date&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BETWEEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date_Sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;2019-07-27&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;2019-07-27&apos;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;activity_date&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  2019년 7월 27일을 기준으로 30일 전부터 기준일까지 일자별로 활성화 유저 수를 계산하면 된다. count를 사용하여 수를 집계하고 기간은 Where 절에 Between과 date_sub를 활용하여 기간 조건을 설정했다.&lt;/p&gt;

&lt;h2 id=&quot;43-product-sales-analysis-3&quot;&gt;4.3 Product Sales Analysis 3&lt;/h2&gt;
&lt;h3 id=&quot;431-table-description--question&quot;&gt;4.3.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Sales&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;sale_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;product_id(FK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;year(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;quantity&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;price&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;(sale_id, year) is the primary key of this table.&lt;br /&gt;
product_id is a foreign key to Product table.&lt;br /&gt;
Each row of this table shows a sale on the product product_id in a certain year.&lt;br /&gt;
Note that the price is per unit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;table: Product&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;product_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;product_name&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;product_id is the primary key of this table.&lt;br /&gt;
Each row of this table indicates the product name of each product.&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Write an SQL query that selects the product id, year, quantity, and price for the first year of every product sold.&lt;/li&gt;
  &lt;li&gt;Return the resulting table in any order.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  product별로 첫 해에 판매한 수량과 판매가격을 구하는 문제이다.&lt;/p&gt;

&lt;h3 id=&quot;432-solution&quot;&gt;4.3.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;year&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;As&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_year&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;quantity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;price&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Sales&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;year&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;year&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;year&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;From&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sales&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  각 Product 별로 첫 해에 해당하는 Record를 어떻게 가져올까 고민을 많이 했었다. 처음에 떠올린 아이디어는 프로덕트 별로 연도를 오름차순으로 정렬한 다음 가장 위에 있는 Record를 가져오는 것이었다. 구글링도 해봤지만 내가 생각했던 솔루션은 찾기 어려웠다. 따라서 다른 방법을 고민하다가 찾은 것이 위 쿼리문이다.&lt;br /&gt;
  아이디어는 간단하다. 프로덕트 별로 첫 해는 year 값이 가장 &lt;strong&gt;낮은&lt;/strong&gt; 값일 것이다. 왜냐하면 날짜는 일정한 방향으로 흐르기 때문이다. 따라서 WHERE 절에 subquery를 활용하여 프로덕트 별로 year가 가장 낮은 Record를 가져올 수 있는 조건 절을 추가했다.&lt;/p&gt;

&lt;h2 id=&quot;44-class-more-than-5-students&quot;&gt;4.4 Class More Than 5 Students&lt;/h2&gt;
&lt;h3 id=&quot;441-table-descriptoin--question&quot;&gt;4.4.1 Table descriptoin &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Courses&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;student(PK)&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;class(PK)&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;(student, class) is the primary key column for this table.&lt;br /&gt;
Each row of this table indicates the name of a student and the class in which they are enrolled.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Find all the classes that have at least five students.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Return the result table in any order.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;382-solution&quot;&gt;3.8.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Courses&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Having&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 31 Jul 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/SQL_LeetCode6/</link>
        <guid isPermaLink="true">http://localhost:4000/data/SQL_LeetCode6/</guid>
        
        <category>Data</category>
        
        <category>SQL</category>
        
        <category>LeetCode</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[SQL] LeetCode 풀이: Basic Aggregate Functions(2/2)</title>
        <description>&lt;p&gt;  안녕하세요. 이번 포스트부터는 LeetCode50 Aggregate Functions 두번째 파트 이어 가겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;3-basic-aggregate-functions&quot;&gt;3. Basic Aggregate Functions&lt;/h1&gt;
&lt;h2 id=&quot;35-queries-quality-and-percentage&quot;&gt;3.5 Queries Quality and Percentage&lt;/h2&gt;
&lt;h3 id=&quot;351-table-description--question&quot;&gt;3.5.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Queries&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Colum Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;query_name&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;result&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;position&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rating&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;There is no primary key for this table, it may have duplicate rows.&lt;br /&gt;
This table contains information collected from some queries on a database.&lt;br /&gt;
The position column has a value from 1 to 500.&lt;br /&gt;
The rating column has a value from 1 to 5. Query with rating less than 3 is a poor query.&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;We define query quality as: The average of the ratio between query rating and its position.&lt;/li&gt;
  &lt;li&gt;We also define poor query percentage as: The percentage of all queries with rating less than 3.&lt;/li&gt;
  &lt;li&gt;Write an SQL query to find each query_name, the quality and poor_query_percentage.&lt;/li&gt;
  &lt;li&gt;Both quality and poor_query_percentage should be rounded to 2 decimal places.&lt;/li&gt;
  &lt;li&gt;Return the result table in any order.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;352-solution&quot;&gt;3.5.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;query_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rating&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quality&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;When&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rating&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;poor_query_percentage&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- round(avg(rating &amp;lt; 3) * 100, 2) as poor_query_percentage&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Queries&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;query_name&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  문제에서 요구한 대로 quality와 poor_query_percentage를 구하면 된다. 다만, poor_query_percentage를 구하는 방법은 사람마다 스타일에 따라 다양한 방법으로 풀 수 있을 것 같다. 난 CASE 구문을 사용해서 rating 3을 기준으로 나눠줘서 Avg를 구했다. 다른 사람들의 풀이를 참조해보니 단순하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rating &amp;lt; 3&lt;/code&gt;구문으로도 구현한 방법도 있었다.&lt;/p&gt;

&lt;h2 id=&quot;36-monthly-transactions-i&quot;&gt;3.6 Monthly Transactions I&lt;/h2&gt;
&lt;h3 id=&quot;361-table-description--question&quot;&gt;3.6.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Prices&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Colum Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;country&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;state&lt;/td&gt;
      &lt;td&gt;enum&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;amount&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;trans_date&lt;/td&gt;
      &lt;td&gt;date&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;The table has information about incoming transactions.&lt;br /&gt;
The state column is an enum of type [“approved”, “declined”].&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;br /&gt;
Write an SQL query to find for each month and country, the number of transactions and their total amount, the number of approved transactions and their total amount.&lt;br /&gt;
Return the result table in any order.&lt;/p&gt;

&lt;h3 id=&quot;362-solution&quot;&gt;3.6.2 Solution&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DATE_FORMAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trans_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;%Y-%m&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;month&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;country&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                               &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trans_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHEN&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&quot;approved&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;End&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                 &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;approved_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;As&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trans_total_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;When&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&quot;approved&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;          &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;approved_total_amount&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Transactions&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;month&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;country&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  집계함수를 적절히 사용하면 간단하게 풀 수 있는 문제이다. CASE구문과 IF 구문은 취향에 따라 쓰면 될 것 같다. 사실 취향보다는 성능이 좋거나 가독성이 좋은 코드로 활용하는게 좋겠지만, 성능비교는 어려우므로 내 취향에 맞는 코드를 선택했다.&lt;/p&gt;

&lt;h2 id=&quot;37-immediate-food-delivery-ii&quot;&gt;3.7 Immediate Food Delivery II&lt;/h2&gt;
&lt;h3 id=&quot;371-table-description--question&quot;&gt;3.7.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Delivery&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;delivery_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;customer_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;order_date&lt;/td&gt;
      &lt;td&gt;date&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;customer_pref_delivery_date&lt;/td&gt;
      &lt;td&gt;date&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;The table holds information about food delivery to customers that make orders at some date and specify a preferred delivery date (on the same order date or after it).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If the customer’s preferred delivery date is the same as the order date, then the order is called immediate; otherwise, it is called scheduled.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;The first order of a customer is the order with the earliest order date that the customer made. It is guaranteed that a customer has precisely one first order.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Write an SQL query to find the percentage of immediate orders in the first orders of all customers, rounded to 2 decimal places.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  고객 별 첫주문이 Immediate Order인 비율을 구해야 하는 문제이다. 그렇다면 1. 고객 별로 첫 주문날짜를 구해야 하며, 2. 첫 주문이 Immediate인지 schedule인지 구해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;372-solution&quot;&gt;3.7.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHEN&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_order_date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer_pref_delivery_date&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ELSE&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;immediate_percentage&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Delivery&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;Min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_order_date&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Delivery&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;On&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order_date&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  처음 고민했던 부분은 고객 별 첫 주문 날짜를 어떻게 구해야할까였다. Immediate인지, schedule인지 판단하는 두 번째 부분은 크게 어렵지 않게 풀 수 있었다. 그룹 별 sorting하여 first value를 찾아볼까도 했었는데 어려워서 진행하진 않았다. 다음 Idea로는 서브퀴리를 활용해 ‘first_order_date’를 구하여 Join하는 것이었다. 그에 맞게 SQL query를 작성하였고 문제는 잘 풀렸다.&lt;/p&gt;

&lt;h3 id=&quot;373-improved&quot;&gt;3.7.3 Improved&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;order_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Delivery&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  문제를 풀고 다른 분들의 solutions을 참조해봤는데 역시나 좋은 답변이 있었다. 다른 사람들은 WHERE () in (); 절을 사용한 Solution들이 많았다. Join절 없이 (customer_id, order_rate)가 (customer_id, min(order_date))와 일치하는 Record들만 가져올 수 있도록 조건을 설정해서 first_order_date를 구할 수 있었다.&lt;/p&gt;

&lt;h2 id=&quot;38-game-play-analysis-iv&quot;&gt;3.8 Game Play Analysis IV&lt;/h2&gt;
&lt;h3 id=&quot;381-table-descriptoin--question&quot;&gt;3.8.1 Table descriptoin &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Activity&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;player_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;device_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;event_date&lt;/td&gt;
      &lt;td&gt;date&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;games_played&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;(player_id, event_date) is the primary key of this table.&lt;br /&gt;
This table shows the activity of players of some games.&lt;br /&gt;
Each row is a record of a player who logged in and played a number of games (possibly 0) before logging out on someday using some device.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Write an SQL query to report the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to count the number of players that logged in for at least two consecutive days starting from their first login date, then divide that number by the total number of players.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  이틀 연속으로 접속한 유저의 비율을 구하는 문제이다.&lt;/p&gt;
&lt;h3 id=&quot;382-solution&quot;&gt;3.8.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ROUND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;player_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;player_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Activity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fraction&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Activity&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;player_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATE_SUB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;player_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;MIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_login&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Activity&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;player_id&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  이 문제는 사실 못 풀었다. 그래서 다름 사람들은 어떻게 풀었는지 Solution을 보면서 공부했다. 위 SQL Query는 앞선 문제와 유사한 WHERE () IN () 절을 사용했다. 풀어보면, 각 event_date - 1일자와 첫 event_date(Min으로 구함)가 같은 Record만을 가져오는 것이다. 그렇다면 이틀 연속으로 접속한 유저 수를 구할 수 있고(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Count(Distinct player_id)&lt;/code&gt;), subquery를 활용해 전체 유저 수(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT Count(Distinct player_id) FROM Activity&lt;/code&gt;)를 구하여 나눠주는 방식이다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  또 다른 방식으로는 다음과 같은 Solution이 있었다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;player_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;DATE_SUB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event_date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;over&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;partition&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;player_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_return&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  전체 쿼리는 아니고 is_return을 구하는 쿼리인데, 이튿날 접속한 유저를 구하는 쿼리이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Over(partition by *)&lt;/code&gt;구문은 * 별로 집계를 수행할 때 쓰는 구문이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt;절과 유사하면서도 차이점이 있는데, 1. 집계된 값을 반환하면서 동시에 기존 행 값도 함께 볼 수 있으며, ```Over()``절과 함께 Window함수와 함께 사용할 수 있다. 이 부분도 따로 정리해야겠다.&lt;br /&gt;
  위 구문을 보면, player_id 별로 event_date - 1일자가 min(event_date)와 같으면 1 다르면 0을 반환해 이틀 연속으로 접속한 유저를 구분할 수 있게끔 한 구문이라고 해석하면 될 것 같다.&lt;/p&gt;

</description>
        <pubDate>Sun, 23 Jul 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/SQL_LeetCode5/</link>
        <guid isPermaLink="true">http://localhost:4000/data/SQL_LeetCode5/</guid>
        
        <category>Data</category>
        
        <category>SQL</category>
        
        <category>LeetCode</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[SQL] LeetCode 풀이: Basic Aggregate Functions(1/2)</title>
        <description>&lt;p&gt;  안녕하세요. 이번 포스트부터는 LeetCode50 Aggregate Functions 이어 가겠습니다. 문제를 풀어보다가 중간중간 막히는 부분이 많았던 구간인 것 같습니다.😂&lt;/p&gt;

&lt;h1 id=&quot;집계-함수aggregate-funstion란&quot;&gt;집계 함수(Aggregate Funstion)란?&lt;/h1&gt;
&lt;p&gt;  집계 함수란 &lt;strong&gt;테이블 전체 혹은 여러 행으로부터 하나의 결과값을 반환하는 함수&lt;/strong&gt;입니다. 예를 들어, Avg, Sum, Max, Min, Count 등 함수가 집계 함수이며, GROUP BY 절과 함께 사용됩니다.&lt;/p&gt;

&lt;h1 id=&quot;3-basic-aggregate-functions&quot;&gt;3. Basic Aggregate Functions&lt;/h1&gt;
&lt;h2 id=&quot;31-not-boring-movies&quot;&gt;3.1 Not Boring Movies&lt;/h2&gt;
&lt;h3 id=&quot;311-table-description--question&quot;&gt;3.1.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Cinema&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Colum Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;movie&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;description&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rating&lt;/td&gt;
      &lt;td&gt;float&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each row contains information about the name of a movie, its genre, and its rating.&lt;br /&gt;
rating is a 2 decimal places float in the range [0, 10]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Write an SQL query to report the movies with an odd-numbered ID and a description that is not “boring”.&lt;/li&gt;
  &lt;li&gt;Return the result table ordered by rating in descending order..&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;312-solution&quot;&gt;3.1.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;movie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rating&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Cinema&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;description&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;boring&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- or mod(id, 2) &amp;lt;&amp;gt; 0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rating&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;desc&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  간단한 문제이다. 지루하지 않은 영화를 필터링하기 위하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;description != &apos;boring&apos;&lt;/code&gt; 조건절을 추가한 다음, 홀수인 id를 추출하기 위한 조건절을 추가하면 된다.&lt;br /&gt;
  홀수인 id를 고르기 위해서는 id(int)를 2로 나눴을 때 나머지가 0인지 1인지 체크하면 된다.&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;313-good-to-know&quot;&gt;3.1.3 Good to Know&lt;/h3&gt;
&lt;p&gt;  나머지를 구하는 방법은 여러가지가 있다. 우선 ‘%’ 연산자도 나머지를 반환하는 연산자인데 위 풀이에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id % 2&lt;/code&gt;는 id를 2로 나눈 나머지를 반환한다. mod(a,b)함수도 나머지를 반환하는 함수이며 a를 b로 나눈 나머지를 반환한다.&lt;/p&gt;

&lt;h2 id=&quot;32-average-selling-price&quot;&gt;3.2 Average Selling Price&lt;/h2&gt;
&lt;h3 id=&quot;321-table-description--question&quot;&gt;3.2.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Prices&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Colum Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;product_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;start_date(PK)&lt;/td&gt;
      &lt;td&gt;date&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;end_date(PK)&lt;/td&gt;
      &lt;td&gt;date&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;price&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each row of this table indicates the price of the product_id in the period from start_date to end_date.&lt;br /&gt;
For each product_id there will be no two overlapping periods. That means there will be no two intersecting periods for the same product_id.&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;table: UnitsSold&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;product_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;purchase_date&lt;/td&gt;
      &lt;td&gt;date&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;units&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;There is no primary key for this table, it may contain duplicates.&lt;br /&gt;
Each row of this table indicates the date, units, and product_id of each product sold.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;br /&gt;
Write an SQL query to find the average selling price for each product. average_price should be rounded to 2 decimal places.&lt;br /&gt;
Return the result table in any order.&lt;/p&gt;

&lt;h3 id=&quot;322-solution&quot;&gt;3.2.2 Solution&lt;/h3&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;As&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;price&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;units&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;units&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;         &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average_price&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;From&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Prices&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UnitsSold&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start_date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;purchase_date&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end_date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;purchase_date&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  관건은 UnitsSold 테이블의 purchase_date가 Prices 테이블의 start_date와 end_date사이에 오도록 하는 것이다. 어떻게 하면 될까 고민해보다가 JOIN절의 On절에서 처리해보자 생각해보고 무작정해봤다. 그런데 Join이 잘 되길래 문제를 수월하게 풀 수 있었다. &lt;br /&gt;
  기존에 쓰던 툴은 이렇게 특정 Column이 어떤 기간 내에 오도록 Join하는 경우 제공하는 기능이 있었다. WildMatch라는 함수가 제공되어서 Key와 start인수, end인수를 입력하면 자동으로 매칭해줬다. 그래서 SQL도 유사한 함수가 있나 찾아봤는데 제공하는 함수는 없길래 다른 방법을 생각해봤고 적용했다.&lt;/p&gt;

&lt;h3 id=&quot;323-improve&quot;&gt;3.2.3 Improve&lt;/h3&gt;
&lt;p&gt;  무작정 적은 코드라 맞는지 틀린지 알 수가 없어 문제를 풀어보고나면 다른 사람들의 풀이를 참조해보곤 하는데 좋은 코드가 있었다!&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 내가 작성한 쿼리문&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UnitsSold&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start_date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;purchase_date&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end_date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;purchase_date&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 다름 사람들의 solution 참조해서 개선&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UnitsSold&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;purchase_date&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Between&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start_date&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end_date&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  Between구문이 있는지 몰랐었다. 속도가 뭐가 빠른지는 대용량 데이터를 테스트 해보지 않아서 잘 모르겠다. 다만, 아래 코드가 직관적으로 읽기 수월하다고 생각한다.&lt;/p&gt;

&lt;h2 id=&quot;33-project-employees-i&quot;&gt;3.3 Project Employees I&lt;/h2&gt;
&lt;h3 id=&quot;331-table-description--question&quot;&gt;3.3.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Project&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;project_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;employee_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;employee_id is a foreign key to Employee table.&lt;br /&gt;
Each row of this table indicates that the employee with employee_id is working on the project with project_id.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;table: Employee&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;employee_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;name&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;experience_years&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;employee_id is the primary key of this table. It’s guaranteed that experience_years is not NULL.&lt;br /&gt;
Each row of this table contains information about one employee.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;
Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.&lt;br /&gt;
Return the result table ordered by student_id and subject_name.&lt;/p&gt;

&lt;h3 id=&quot;332-solution&quot;&gt;3.3.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project_id&lt;/span&gt;                          &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;project_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;experience_years&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;average_years&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Project&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;On&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;employee_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project_id&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  기본적인 문제로 어려운 문제는 아니라 생각한다.&lt;/p&gt;

&lt;h2 id=&quot;34-percentage-of-users-attended-a-contest&quot;&gt;3.4 Percentage of Users Attended a Contest&lt;/h2&gt;
&lt;h3 id=&quot;341-table-descriptoin--question&quot;&gt;3.4.1 Table descriptoin &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Users&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;user_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;user_name&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each row of this table contains the name and the id of a user.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;table: Register&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;contest_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;user_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each row of this table contains the id of a user and the contest they registered into.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;
Write an SQL query to find the percentage of the users registered in each contest rounded to two decimals.&lt;br /&gt;
Return the result table ordered by percentage in descending order. In case of a tie, order it by contest_id in ascending order.&lt;/p&gt;

&lt;h3 id=&quot;342-solution&quot;&gt;3.4.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contest_id&lt;/span&gt;                                &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contest_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contest_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;From&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Users&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;percentage&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Register&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contest_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;percentage&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;desc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contest_id&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  이 문제는 쉽지 않았고 고민을 많이 했었다. 각 contest별로 참석율을 구하기 위해서는 총 user_id 수를 구한다음 나눠줘야 했다. 방법은 위 SQL코드처럼 subquery를 활용하는 방법이다. SELECT 절에서 사용됐고 단일 상수값을 반환하는 Subquery이다. Subquery는 아직은 생소해서 날잡고 한 번 정리해야 할 것 같다.&lt;/p&gt;

&lt;!-- ### 3.4.3 Good to Know
&amp;#160; 우선 첫번째 방법은 위 SQL코드처럼 subquery를 활용하는 방법이다. SELECT 절에서 사용됐고 단일 상수값을 반환하는 Subquery이다. Subquery는 아직은 생소해서 날잡고 한 번 정리해야 할 것 같다.&lt;br&gt;
&amp;#160; 두번째 방법은 해당 값을 변수로 선언하여 활용하는 방법이다. 
```sql
DECLARE @user int = (select count(*) from Users)

SELECT
    a.contest_id, round((count(r.user_id) * 1) / @user * 100, 2)    as percentage
FROM 
    Register a
GROUP BY a.contest_id 
ORDER BY  percentage Desc,  a.contest_id Asc
```
변수를 선언해서 활용하는 SQL 구문을 짜는 것도 꽤 깔끔해보인다. --&gt;
</description>
        <pubDate>Thu, 20 Jul 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/SQL_LeetCode4/</link>
        <guid isPermaLink="true">http://localhost:4000/data/SQL_LeetCode4/</guid>
        
        <category>Data</category>
        
        <category>SQL</category>
        
        <category>LeetCode</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[데이터분석] 4개 인자를 한 산점도에 나타내기</title>
        <description>&lt;p&gt;  4개 인자를 한 산점도 차트에 표현하는 미션이 주어졌습니다. 4개 인자를 한 산점도에..?? 왜 4개의 인자를 한 산점도로 표현해야했는지 그리고 어떻게 해결했는지 기록하고자 합니다.&lt;/p&gt;

&lt;h2 id=&quot;1-배경&quot;&gt;1. 배경&lt;/h2&gt;
&lt;p&gt;  데이터 분석을 통한 에너지 사용 절감 프로젝트의 일환으로 에너지 사용량을 모니터링 할 수 있는 대시보드 화면을 개발하던 중, 팀장님께서 현재 에너지 사용량이 적정한 수준으로 사용되고 있는지 확인할 수 있는 시각화 차트를 만들어보라고 하셨다. 데이터 분석을 통해 에너지 사용에 영향을 미치는 중요한 3가지 인자를 도출했고, 이를 기반으로 어떻게 하면 클라이언트가 쉽게 볼 수 있는 시각화 차트를 구성할 수 있을지 고민해봤습니다. 우선, 어떤 차트를 통해 표현할 지를 정해야 했는데 인자 간 관계를 볼 때 기본적으로 사용하는 산점도를 활용해 표현해보고자 했습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;※ BI Tool로 Qlik Sense를 활용하는데 3차원 산점도는 제공하고 있지 않아 주로 2차원 산점도를 활용해 대시보드를 개발하고 있습니다. ?3차원 산점도 Extension을 찾아볼까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-문제점&quot;&gt;2. 문제점&lt;/h2&gt;
&lt;p&gt;  다만 1개의 Y인자와 3개의 X인자 즉 4개의 인자를 한 산점도에 표현해야 하는 문제점이 있었습니다. 산점도는 보통 Y축과 X축 그리고 Z축(색으로 표시)을 활용하여 3개 인자 간 관계를 표현하기엔 적합하지만 4개 인자를 한번에 표현하기에는 한계가 있었습니다. 측정값을 활용해 Point의 크기를 조절하여 하나의 차원을 더 추가할 수 있지만, 가시성이 많이 떨어지는 문제가 있었습니다. 어떻게 해결할 수 있을지 이런 저런 방법을 고민했었고, 몇 가지 떠올렸던 아이디어는 다음과 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;21-대안1-매개변수-활용해보기&quot;&gt;2.1 대안1: 매개변수 활용해보기&lt;/h3&gt;
&lt;p&gt;  Y축은 에너지 사용량으로 고정한 채, X축과 Z축을 매개 변수를 활용해 원하는 인자를 선택하여 산점도를 그릴 수 있게끔 해봤습니다. 장점은 사용자가 매개 변수를 활용해 원하는 대로 인자를 클릭하면서 데이터를 볼 수 있지만, 4개 인자를 한 번에 표현하지 못하는 것은 여전했습니다. 이는 사용자가 인자를 클릭해가면서 머릿속에 상상해가면서 비교하거나, 따로 캡쳐를 떠가면서 비교해야 하기에 활용도가 많이 떨어지는 아쉬움이 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;22-대안2-여러-산점도를-그리기&quot;&gt;2.2 대안2: 여러 산점도를 그리기&lt;/h3&gt;
&lt;p&gt;  대시보드를 만들 때, 굳이 하나의 산점도만 그려야 한다는 법은 없습니다. 그래서 여러 개의 산점도를 한 화면에 그려보면 어떨까 생각했습니다. 그려보고 나니 여러개의 산점도를 통해 정보를 얻을 수 있지만, 여전히 4개의 인자를 한 산점도에서 확인하지 못하는 한계가 있었습니다. 또 하나의 문제는 차트가 많아지는 것은 사용자가 받아들여야 하는 정보가 그 만큼 증가한다는 것이고 복잡해지기 때문에 사용 편의성도 떨어지게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;3-해결책&quot;&gt;3. 해결책!&lt;/h2&gt;
&lt;p&gt;  이런저런 고민을 해봤지만 해결이 잘 안되던 차에 팀장님과 회의를 하면서 한 가지 기발한 아이디어를 주셨습니다. 기본 아이디어는 &lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;인자의 개수를 4개 → 3개로 줄이는 것&lt;/strong&gt;&lt;/span&gt;이었습니다. 왜 생각을 못했던 걸까요? 듣고 나니 명쾌하고 심플했습니다. 인자의 개수를 줄이면 2차원 산점도로도 충분히 표현이 가능합니다. 그렇다면 어떻게 줄일 수 있었을까요?&lt;/p&gt;

&lt;h3 id=&quot;31-x1인자-영향력-없애기&quot;&gt;3.1 X1인자 영향력 없애기&lt;/h3&gt;
&lt;p&gt;  3가지 X인자를 각각 X1, X2, X3인자라고 하겠습니다. X3인자는 외기 온도이며, 외생적으로 주어지는 변수입니다. 이제 나머지 X1인자와 X2인자에 대해서 쉽게 예를 들어보겠습니다. 우리가 맛있는 라면을 끓이기 위해서는 냄비에 물과 라면을 각각 넣어줘야 합니다. 라면을 많이 넣을수록 물도 많이 넣어야하고 물이 많아질수록 GAS 사용량도 늘어나겠죠?(비유가 찰떡이네요🤣) 여기서 X1인자를 라면 양, X2인자를 물 투입량, Y인자를 GAS사용량이라고 해보겠습니다. 에너지 사용 관점에서 이렇게 표현해보면 어떨까요? &lt;strong&gt;&amp;lt;라면 1g당 물 투입량, 라면 1g당 GAS 사용량&amp;gt;&lt;/strong&gt; 자연스럽게 3개 인자를 2개 인자로 줄일 수 있게 됐습니다! 또한 라면 양에 따라 에너지 사용량에 미치는 영향까지 제거하여 비교할 수 있게 됐습니다. 간단하지만 왜 생각을 못했었는지..ㅎㅎㅎ&lt;br /&gt;&lt;br /&gt;
  사실 어떤 한 인자를 나눠줌으로써 효과를 제거하는 방법이 새로운 방법은 아니고 많이 쓰이는 방법입니다. 심지어 제가 석사과정 중에 응용미시계량, 계량을 전공하면서 정말 많이 썼던 방법이었습니다. 까먹고 있었을 뿐… 예를 들면 경제학에서는 인구수에 따른 효과를 제거하기 위해 2가지 방법을 사용하는데, 하나는 X변수로 회귀식에 추가하거나 다른 하나는 Y인자를 인구수로 나눠서 1인당 Y값으로 변환해 인구수에 따른 효과를 제거하는 방법을 사용합니다. 아무래도 도메인 영역이 다르다보니 지레 단정짓고 다양한 시도를 해보지 못했던 것 같습니다. 긍정적이라면 앞으로는 이 방법을 활용할 수 있겠죠?ㅎㅎ&lt;/p&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;  비록 까먹고 있던 스킬이지만 이번 프로젝트를 통해 다시 한 번 복기할 수 있었습니다. 4개 인자를 한 산점도에 어떻게 표시하지? 이 포인트에 너무 매몰되어 있었던 것 같습니다. 이렇게 데이터를 시각적으로 표현하는 방법은 너무나 다양하고 정답이 없기에 이렇게 경험을 쌓아가면서 내실을 다져가야겠습니다.&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Jul 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/data_analysis1/</link>
        <guid isPermaLink="true">http://localhost:4000/data/data_analysis1/</guid>
        
        <category>Data</category>
        
        <category>Data Analysis</category>
        
        <category>Visualization</category>
        
        <category>Scatter Plot</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[회고록] 23년 7월 3주차: 커뮤니케이션</title>
        <description>&lt;p&gt;  이번주는 커뮤니케이션 관련하여 2가지 이슈가 있었습니다. 한 번은 팀 회의를 하면서 서로의 커뮤니케이션을 보면서 느꼈던 점과 다른 한 번은 클라이언트와 화상회의를 하면서 느꼈던 점들을 기록해보고자 합니다. 테마를 정해보자면 다음과 같이 정리할 수 있을 것 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;효율적인 커뮤니케이션&lt;/li&gt;
    &lt;li&gt;보수적인(&amp;amp;방어적인) 클라이언트 설득하기&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-효율적인-커뮤니케이션&quot;&gt;1. 효율적인 커뮤니케이션&lt;/h2&gt;
&lt;p&gt;  업무에 있어서 효율적인 커뮤니케이션이란 무엇일까요? &lt;br /&gt;
⇨ &lt;strong&gt;원하는 바 혹은 현 상황을 명확하게 정리해서 빠르게 상대방이 이해할 수 있도록 전달하는 것&lt;/strong&gt;이라고 생각합니다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  업무에 있어서 상호간에 효율적인 커뮤니케이션은 매우 중요합니다. 프로젝트 방향에 대해 명확한 의사결정을 내리거나 문제를 제대로 풀어내는 과정에서 서로 오해를 없애고, 시간 낭비를 줄이기 위해서는 효율적인 커뮤니케이션이 필요합니다. 효율적인 커뮤니케이션의 중요성에 대해서는 많은 분들이 동의하실 거라 생각합니다. 다만, 효율적인 커뮤니케이션이 잘 될 때도 있지만 안되는 경우도 종종 있습니다. 왜 효율적인 커뮤니케이션이 어렵고, 어떻게 하면 좋을지에 대한 스스로의 고민을 적어보고자 합니다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;11-왜-어려울까&quot;&gt;1.1 왜 어려울까?&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;※ 지극히 개인적인 경험에 의한 고찰입니다. 특히 주니어의 입장으로 겪은 경험들입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  일을 처음 시작하면서 어려웠던 점 중에 하나가 &lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;내가 해야할 말과 하고싶은 말을 구분하는 것&lt;/strong&gt;&lt;/span&gt;이었습니다. 실무자들은 자신이 맡은 실무와 관련된 사항들을 일일이 나열하면서 커뮤니케이션 하는 경우가 왕왕 있습니다. 하지만, 중요한 것은 관리자나 의사결정권자들에게 디테일한 부분은 부차적인 것이라는 점입니다. 당장 의사결정에 필요한 핵심 정보, 근거가 필요합니다. 그렇기에 같은 장소에 있지만 서로 다른 얘기를 하면서 커뮤니케이션은 정체되고 서로를 탓하게 되는 경우가 생기는 것 같습니다.&lt;br /&gt;&lt;br /&gt;
  그 다음으로는 본인이 &lt;strong&gt;해당 사항에 대해 완벽하게 숙지하지 못할 때&lt;/strong&gt; 커뮤니케이션이 제대로 이루어지지 않았습니다. 저도 어떤 사항에 대해 잘 숙지하고 있다고 생각했음에도 막상 누군가 물어봐서 말로 대답을 할 때, 대답을 제대로 하지 못한 경우가 있습니다. 이는 사실 애매하게 알고 있던 것이었습니다. 제대로 알지 못하기에 제대로 답하지 못하고 둘러대기 시작합니다. 그렇게 되면 이 커뮤니케이션은 점점 꼬이게 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;12-어떻게-해야할까&quot;&gt;1.2 어떻게 해야할까?&lt;/h3&gt;
&lt;p&gt;  우선 중요한 것은 &lt;strong&gt;상대방이 무엇을 원하는지 정확히 파악&lt;/strong&gt;해야 합니다. 눈치가 빠른 사람이라면 쉽겠지만 그렇지 않은 분이라면 애매한 경우엔 무조건 되물어서 상대방의 질문의 의도를 명확히 파악해야 합니다. 질문의 의도만 명확히 파악해도 반 이상은 해결되는 것 같습니다. &lt;br /&gt;&lt;br /&gt;
  그 다음으로는 &lt;strong&gt;두괄식&lt;/strong&gt;으로 하는게 훨씬 효율적이라 생각합니다. 해야할 말과 하고싶은 말이 상이한 경우 해야할 말을 먼저하고 그 후에 하고싶은 말을 해야합니다. 일단, 질문사항이나 요구사항에 명확한 답변을 제시하고 그에 따른 디테일은 후에 나열하면서 커뮤니케이션을 이어가는 것도 한 방법이라 생각합니다. 디테일이 먼저 나가면 커뮤니케이션이 제자리에서 빙빙 돌게 되는 경우를 보게 됩니다. &lt;br /&gt;&lt;br /&gt;
  아무래도 실무자 입장에서는 해당 사항에 대한 이슈 사항을 사소한 것이라도 얘기하고 싶기 마련입니다. 물론 이도 중요합니다. 숨기거나 놓치게 되면 나중에 문제가 생길 소지가 높기 때문입니다. 다만, 상대방의 궁금증을 먼저 해결한 후에 유도하여 논의를 진행시키는 것도 꽤 유용한 커뮤니케이션 스킬이라 생각합니다. &lt;br /&gt;&lt;br /&gt;
  마지막으로 커뮤니케이션을 하면서 횡설수설하게 되면 멈추고 본인이 현 이슈에 대해서 제대로 인지하고 있는지 돌아봐야 합니다. 그리고 정말 제대로 인지하지 못하고 있는 것이라면 인정한 후에 양해를 구하고 제대로 숙지한 다음에 진행해야 합니다. 고집부리고 억지부리면 시간만 흐르고 나중에 더 챙피할 일이 생길 수도 있습니다.&lt;/p&gt;

&lt;p&gt;  저도 효율적이고 명확한 커뮤니케이션을 하기 위해 노력하고 있습니다. 하지만 종종 실수를 하고, 시행착오를 겪습니다. 실수를 줄이고자 복기하기 위하여 기록하고 곱씹어보며 노력하는 중입니다😊&lt;/p&gt;

&lt;h2 id=&quot;2-보수적인방어적인-클라이언트-설득하기&quot;&gt;2. 보수적인(&amp;amp;방어적인) 클라이언트 설득하기&lt;/h2&gt;
&lt;p&gt;  우리 팀은 데이터 분석을 통한 컨설팅을 진행하기에 고객에게 기존의 업무 Process 대비 데이터에 기반한 새로운 업무 Process를 제시하는 경우가 있습니다. 데이터 기반의 업무 효율화, 의사결정 체계로의 전환으로 일종의 DT라고 볼 수 있겠습니다. 이러하다보니, 연차가 오래되고 보수적인 클라이언트의 경우 우리 팀의 제안에 대하여 굉장히 방어적인 태도를 보이는 경우가 잦습니다. 열심히 일해서 결과물을 가져갔는데 클라이언트의 반응이 “우린 이런거 필요없어요.”로 나올 때, 저도 사람인지라 허탈함이 밀려옵니다. &lt;br /&gt;&lt;br /&gt;
  지난 클라이언트와의 미팅에도 이러한 상황이 발생했습니다. 우리 팀은 당황했지만 결국은 팀장님이 클라이언트를 설득하는데 성공했습니다. 그 모습을 보면서 정말 배운 것이 많았고 꼭 기록해놔야 겠다고 생각했습니다.&lt;/p&gt;

&lt;h3 id=&quot;21-확신&quot;&gt;2.1 확신&lt;/h3&gt;
&lt;p&gt;  우리 팀은 우리가 제안하는 방향에 대해서 확신이 있었습니다. 다만, 아무래도 새로운 업무 Process이다보니 거부감이 심했습니다. 보수적인 클라이언트는 우리 팀이 제시한 내용에 대해 이해하기 어렵고 복잡하다 이렇게 까지 필요없다라고 계속 거부했습니다. 다만, 뉘앙스를 봤을 때 우리 팀이 제시한 방안이 틀린 것이 아니라 귀찮고 이해하기 어려우니 받아들이려고 하지 않는 태도로 보였습니다. 아마 팀장님은 이 부분을 캐치하고 파고드신 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;22-설득&quot;&gt;2.2 설득&lt;/h3&gt;
&lt;p&gt;  우리 팀은 우리가 제시한 방안에 대해서 조금 더 쉽게 풀어서 설명을 했고, &lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;이 제안이 기존 업무 Process 대비 어떠한 장점을 갖고 있는 지&lt;/strong&gt;&lt;/span&gt;를 설명했습니다. 우리가 잡은 Point는 다음과 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;데이터를 통한 빠른 문제 원인 파악 가능 - 효율성 제고&lt;/li&gt;
    &lt;li&gt;1번을 통한 명확한 업무 지시 및 문제 해결 가능&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;  설득을 하면서 클라이언트가 갖고 있는 오해를 풀어드렸고, 왜 이 제안이 기존에 업무 Process대비 장점이 있는지 어필했습니다. 그럼에도 불구하고 클라이언트에 태도는 완강했습니다. 하지만 팀장님은 포기하지 않고 끈질기게 설득에 들어갔습니다. 제가 봤을 때에 클라이언트가 마음을 열기 시작한 부분은 같이 차트를 보면서 데이터를 어떻게 해석해야 하는지 얘기하면서 부터였던 것 같습니다. 제 개인적인 느낌이라 아닐수도 있습니다. 다만, 지속적으로 설득하다보니 클라이언트도 우리가 제시한 논리에 공감하기 시작했고 고민하기 시작하더니 결국엔 한 번 해보겠다고 하면서 설득에 성공했습니다.&lt;/p&gt;

&lt;h3 id=&quot;23-뚝심&quot;&gt;2.3 뚝심&lt;/h3&gt;
&lt;p&gt;  분석 컨설팅을 하다보면 클라이언트를 설득하기 위해서 뚝심있게 밀고 나가야 할 때가 필요합니다. 클라이언트가 도메인 지식에 월등하기 때문에 보통은 클라이언트 의견에 좌지우지되기 쉽상이지만, 아니라고 생각할때는 강력하게 밀어붙여 설득이 필요합니다. 그러다 보면 부딪히는 경우도 생기지만, 논리적으로 탄탄하다면 결국엔 설득이 되는 것 같습니다(논리가 안 통하는 상대는 아직 만나본 적이 없기에 잘 모르겠습니다…). 클라이언트에게 너무 끌려다니기보단 확신을 갖고 밀어붙이는 태도도 필요하다는 것을 많이 배웠습니다.&lt;/p&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;  이번 주는 커뮤니케이션에 관한 다양한 이슈가 있었습니다. 커뮤니케이션은 분석 스킬, 실무 스킬과는 다른 의미로 매우 그리고 항상 어렵습니다. 낙담할 때도 있곤 하지만 더 나은 커뮤니케이션을 위하여 조금씩 개선시켜 나아가고자 합니다.&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Jul 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/weekly_memoir_8/</link>
        <guid isPermaLink="true">http://localhost:4000/data/weekly_memoir_8/</guid>
        
        <category>Data</category>
        
        <category>Memoir</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[회고록] 23년 7월 2주차: 분석 모델링 수행</title>
        <description>&lt;p&gt;  지난 2주는 에너지 사용량 증감 원인 분석하고 그 결과를 문서화 하느라 정신 없이 지나갔네요. 월간 보고회를 진행하기 위해 쳇바퀴 처럼 반복되는 매월이지만 최근 꽤나 재미있는 분석을 진행했습니다. 이번에는 분석 모델링을 통해서 Y인자의 변동을 설명하고자 하였고 흥미로운 결과가 나와서 기록하고자 합니다.&lt;/p&gt;

&lt;h2 id=&quot;1-배경이유&quot;&gt;1. 배경/이유&lt;/h2&gt;
&lt;p&gt;  저는 현재 공장 에너지 절감 프로젝트를 수행하고 있고, 에너지 별 문제를 진단하고 분석을 통해 절감 요소를 도출하거나 에너지 사용량 증감을 설명하는 인자들을 도출하는 작업을 하고 있습니다. 이전까지는 에너지 별 공정 매커니즘에 기반하여 후보영향인자들을 선정한 다음 인자별로 단변량 분석을 통해 문제를 풀어나갔습니다(믿기 어렵겠지만 상당 부분 단변량 분석을 통해 문제가 해결이 됩니다). 하지만, 이번에 분석한 에너지 사용량은 단변량으로 분석하기에는 한계가 있었습니다. 다양한 변수가 복학접으로 영향을 미치다보니 단변량 분석을 통해서는 명확한 관계가 드러나지 않았기 때문이었습니다. 따라서, 우리는 분석 모델링을 통해 에너지 Y인자의 변동을 잘 설명할 수 있는 X인자의 조합을 찾고 그 효과를 추정하기 위해 분석 모델링을 수행하였습니다.&lt;/p&gt;

&lt;h2 id=&quot;2-기준&quot;&gt;2. 기준&lt;/h2&gt;
&lt;p&gt;  다양한 인자들의 조합 중 최적의 조합을 찾기 위해서는 기준이 필요하다. 우리는 주로 &lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;설명력(R^2)&lt;/strong&gt;&lt;/span&gt;을 기준으로 판단을 한다(예측 모형이 아니다!). 왜냐하면 우리는 Y인자의 변동을 가장 잘 설명할 수 있는 모형을 찾고자 하기 때문이다. &lt;br /&gt;
  그 외에도 중요하게 따져봐야 할 것들이 있다. 선형 회귀식을 사용할 때에는 부호가 매커니즘과 일치하는지를 따져봐야 한다. 매커니즘과 맞지 않는 부호가 나올 경우, 클라이언트를 설득할 수 없다. 이 때에는 누락변수가 있는 것은 아닌지 이유를 살펴보고 보완을 해야 한다. &lt;br /&gt;
   또 중요한 점은 클라이언트가 납득할 수 있어야 한다. 흔히 도메인 지식이 약한 분석가 혹은 조직이 하는 실수가 수 많은 변수들을 떄려넣고 설명력 혹은 예측력이 가장 높은 모형을 클라이언트에게 제공하는 것인데, 이러한 결과를 제시할 경우 클라이언트에게 신뢰받기는 힘들 것이다. (이는 산업 분야마다 다르다. 하지만 분야를 막론하더라도 컨설팅을 수행하는 조직이라면 이 점을 반드시 유의해야 한다.)&lt;br /&gt;
  따라서 내 기준을 아래와 같이 정했다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;최우선 기준은 설명력이다. 다만, 설명력을 조금 손해보더라도 해석이 우월한 조합이 있다면 그 조합을 선택하자&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  어떻게 보면 주관적이고 분석가의 의도가 들어갈 수 밖에 없다. 그렇기에 항상 결과에 대해 의심하고 신중하게 선택하여야 한다. 이런 점에서 분석가 일을 하다보면 테크니컬한 문제들은 별게 아니란 생각이 든다. 항상 이렇게 분석하고 선택하는 과정이 훨씬 더 어렵다.&lt;/p&gt;

&lt;h2 id=&quot;3-결과&quot;&gt;3. 결과&lt;/h2&gt;
&lt;p&gt;  설명력과 매커니즘을 기반으로 선형회귀 모형을 활용해 다양한 인자들의 조합을 탐색하였고 3가지 인자의 조합을 최종 선택하였다. 3가지 인자로 선형 회귀 모형을 Fit 했을 때, Y인자 변동의 78%를 설명하는 결과를 얻을 수 있었다. 계수들의 부호도 모두 공정 매커니즘과 일치했고, 해석에도 만족스러웠다.&lt;/p&gt;

&lt;h2 id=&quot;4-활용&quot;&gt;4. 활용&lt;/h2&gt;
&lt;p&gt;  우리가 분석한 결과가 어떻게 활용될까? 우리는 분석 결과에 따르면 특정 X인자 (설비효율)가 개선될 경우, 금액적 효과가 대략 xx원이 될 것이라고 클라이언트에게 리포트 했다(물론 정말 그런지는 클라이언트가 정밀하게 따져보고 검증해야 하는 과정이 필요하다). 그 수치는 클라이언트가 예상했던 금액 효과 보다 컸다. 알고보니 클라이언트 사에서는 에너지 사용 절감을 위해 설비 교체 투자 건을 진행하고자 했지만, 투자 대비 절감 효과가 낮을 것으로 예상돼 보류 중인 상황이었다. (현재 경기가 안 좋다보니 투자에 매우 민감한 상황이다.) 하지만, 분석 결과에 따르면 설비 교체로 인한 절감 효과가 매우 클 것으로 예상되기에 클라이언트사에 의사결정 사항에 영향을 줄 수 있게 됐고, 변화가 생길 수도 있을 것이다.&lt;br /&gt;
  결국 어떤 조직이 데이터를 기반으로 의사결정 한다는 의미는 데이터 분석을 통해 객관적인 증거를 활용한다는 것이라 생각한다. 거기서 나의 역할은 더 신뢰할 수 있는 근거를 만들기 위해 엄밀한 분석을 수행하는 것이라 생각한다.&lt;/p&gt;

&lt;h2 id=&quot;5-흥미로운-점&quot;&gt;5. 흥미로운 점&lt;/h2&gt;
&lt;p&gt;  경제학 석사를 전공하면서 무수히 많은 회귀식을 생성했고 해석했다. 다만, 실무를 하면서 잠깐 멀어졌기에 감각(?)이 떨어졌다고 해야하나 여튼 그런 상황이었다. 단변량 분석에서 Y인자와 X인자 간의 관계가 명확하게 도출되지 않았지만, 다변량 분석 모델링을 통해 명쾌하게 해석되는 결과를 보면서 참 많은 생각이 들었다. 왜 단변량 분석에서는 잘 안보이고 다변량 분석에서는 잘 보였을까? 생각해봤을 때, 여러 인자가 복합적으로 영향을 미치기 때문이라 생각한다. 단변량 분석과 다변량 분석을 비교해보면 다음과 같을 것이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;단변량 분석: 여러 인자들이 중요한 순서(상관성이 높은 순 혹은 매커니즘 기반 순서)대로 Y인자 변동에 영향을 끼치는 경우, 단변량 분석이 용이함&lt;br /&gt;
  주로 상관성이 높은 X1인자를 고정한 후, Y인자의 산포를 설명하는 X2인자를 탐색하는 방법으로 분석을 수행함&lt;/li&gt;
    &lt;li&gt;다변량 분석: 다양한 인자들이 Y인자에 영향을 끼치는 경우, 다변량 분석이 용이함&lt;br /&gt;
  적합한 모델을 선정하고 모델링을 통해 분석을 수행함&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;  또 하나 깨달은 것은 &lt;strong&gt;상황에 맞게 적합한 분석 방법을 적용해야 한다는 것&lt;/strong&gt;이었다. 너무 당연한 얘기이려나? 그래도 단순히 알고 있는 것과 경험해보는 것은 다르기에 개인적으로도 아주 유익한 2주였다. 간만에 재밌었고 보람찬 분석이었다. 이런거 보면 모델링이 더 적성에 맞을지도..??ㅎㅎ&lt;/p&gt;
</description>
        <pubDate>Wed, 05 Jul 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/weekly_memoir_7/</link>
        <guid isPermaLink="true">http://localhost:4000/data/weekly_memoir_7/</guid>
        
        <category>Data</category>
        
        <category>Memoir</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[SQL] LeetCode 풀이: Basic Joins(2/2)</title>
        <description>&lt;p&gt;  안녕하세요. LeetCode50 Basic Join 이어 가겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;2-basic-joins&quot;&gt;2. Basic Joins&lt;/h1&gt;
&lt;h2 id=&quot;25-average-time-of-process-per-machine&quot;&gt;2.5 Average Time of Process per Machine&lt;/h2&gt;
&lt;h3 id=&quot;251-table-description--question&quot;&gt;2.5.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Activity&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Colum Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;machine_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;process_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;activity_type(PK)&lt;/td&gt;
      &lt;td&gt;enum&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;timestamp&lt;/td&gt;
      &lt;td&gt;float&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;The table shows the user activities for a factory website.&lt;br /&gt;
machine_id is the ID of a machine.
process_id is the ID of a process running on the machine with ID machine_id.
activity_type is an ENUM of type (‘start’, ‘end’).
timestamp is a float representing the current time in seconds.
‘start’ means the machine starts the process at the given timestamp and ‘end’ means the machine ends the process at the given timestamp.
The ‘start’ timestamp will always be before the ‘end’ timestamp for every (machine_id, process_id) pair.&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;There is a factory website that has several machines each running the same number of processes. Write an SQL query to find the average time each machine takes to complete a process.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;The time to complete a process is the ‘end’ timestamp minus the ‘start’ timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;The resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Return the result table in any order.&lt;/p&gt;

&lt;h3 id=&quot;252-solution&quot;&gt;2.5.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;timestamp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;As&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processing_time&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Activity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Activity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;start&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;end&apos;&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- end timestamp가 start timestamp 보다 이후여야 한다는 제약이 필요함&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine_id&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  Self Table Join이다. 문제에서 processing time = endtime - starttime으로 정의하고 있다. 따라서, machind_id 별로 endtime과 starttime 간 차이를 구할 수 있게 두 컬럼을 붙여주면 된다. JOIN을 수행할 a 테이블은 ‘start’인 timestamp만을 가져오고, b 테이블은 ‘end’인 timestamp만을 가져와서 join을 수행하여 processing time을 구하면 된다.&lt;br /&gt;
&lt;br /&gt;
  문제에 보면 machine_id, process_id 별 end timestamp가 start timestamp가 이후여야 한다. 문제 풀 때는 까먹어서 SQL 구문에 넣지 않았지만, 실무에서는 매우 중요하다. 실제로는 데이터의 무결성(Data Integrity)가 지켜지지 않는 경우가 많기 때문에, 정확한 데이터를 산출하기 위해서는 위와 같은 조건을 꼭 추가하여야 한다.&lt;/p&gt;

&lt;h3 id=&quot;253-good-to-know&quot;&gt;2.5.3 Good to Know&lt;/h3&gt;
&lt;p&gt;Round함수는 지정한 자릿수에 따라 반올림을 수행하는 함수이다. 만약 지정한 자릿수가 ‘3’이라면 소수점 넷째 자리에서 반올림하여 셋째자리까지 표시해준다.&lt;/p&gt;

&lt;h2 id=&quot;26-employee-bonus&quot;&gt;2.6 Employee Bonus&lt;/h2&gt;
&lt;h3 id=&quot;261-table-description--question&quot;&gt;2.6.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Employee&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Colum Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;empId(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;name&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;supervisor&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;salary&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;(sale_id, year) is the primary key of this table.&lt;br /&gt;
Each row of this table indicates the name and the ID of an employee in addition to their salary and the id of their manager.&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;table: Bonus&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;empId(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bonus(FK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;empId is a foreign key to empId from the Employee table.&lt;br /&gt;
Each row of this table contains the id of an employee and their respective bonus.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;br /&gt;
Write an SQL query to report the name and bonus amount of each employee with a bonus less than 1000.&lt;br /&gt;
Return the result table in any order.&lt;/p&gt;

&lt;h3 id=&quot;252-solution-1&quot;&gt;2.5.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bonus&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Bonus&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empId&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bonus&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;isnull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bonus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 문제와 마찬가지로 간단한 Join이라 부가설명 없이 넘어가도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;27-students-and-examinations&quot;&gt;2.7 Students and Examinations&lt;/h2&gt;
&lt;h3 id=&quot;271-table-description--question&quot;&gt;2.7.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Students&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;student_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;student_name&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each row of this table contains the ID and the name of one student in the school.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;table: Subjects&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;subject_name(PK)&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each row of this table contains the name of one subject in the school.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;table: Examinations&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;student_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;subject_name&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;There is no primary key for this table. &lt;u&gt;It may contain duplicates.&lt;/u&gt;&lt;br /&gt;
Each student from the Students table takes every course from the Subjects table.
Each row of this table indicates that a student with ID student_id attended the exam of subject_name.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;
Write an SQL query to find the number of times each student attended each exam.&lt;br /&gt;
Return the result table ordered by student_id and subject_name.&lt;/p&gt;

&lt;h3 id=&quot;272-solution&quot;&gt;2.7.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subject_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subject_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;           &lt;span class=&quot;k&quot;&gt;As&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attended_exams&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;From&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Students&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Cross&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Subjects&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Examinations&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subject_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subject_name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subject_name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;asc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subject_name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;asc&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; 문제에서 요구하는 답을 얻기 위해서는 3개의 테이블을 Join해야 한다. 학생별로 수강한 과목명을 붙이고 그 과목에 시험 응시한 과목을 붙여야 한다. students 테이블의 모든 학생들은 subjects에 있는 모든 과목을 수강했다고 한다. 그렇다면 students테이블의 students_id 별로 과목명을 모두 붙여주면 된다. 이럴때 사용하는 JOIN은 &lt;strong&gt;OUTER JOIN&lt;/strong&gt;이며, MySQL에선 ‘CROSS JOIN’으로 수행한다. CROSS JOIN은 각 테이블의 키별로 모든 값을 매칭하는 JOIN 방법이다. 수행 결과로 students_id 별로 모든 subjects name이 JOIN된다.&lt;br /&gt;
&lt;br /&gt;
  다음으로 students id 별로 시험 응시 내역을 붙여주면 된다. 기존 Cross Join을 수행한 테이블에 Examination을 Left Join 해주자. 그러면 시험을 응시했으면 값이 붙고 없으면 Null값이 붙는다. 따라서 c.subject name을 count해주면 시험 응시 횟수를 구할 수 있게 된다.(null값은 count하지 않는다.)&lt;/p&gt;

&lt;h3 id=&quot;273-good-to-know&quot;&gt;2.7.3 Good to Know&lt;/h3&gt;
&lt;p&gt;  실무에서 데이터 마트를 구성하다보면 대부분의 트러블은 대부분 테이블 간 JOIN에서 발생한다. 그 이유는 1) Key가 잘못(중복, 데이터 타입 상이 등)됐거나, 2) Join에 종류를 잘못설정 했거나, 3) 기타 모종의 이유… 등으로 발생한다. 특히, Key에 중복이 발생되거나, Outer Join을 잘못 수행할 경우 데이터가 뻥튀기 되면서 컴퓨팅 리소스 한계 이상으로 사용하게 되면서 서버가 맛탱이가는 일이 발생하고 서비스를 내리거나 엔진을 재시작하는 일이 발생한다. 따라서, Join은 항상 신중하게 해야 한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;JOIN 수행 전 KEY가 적절한 지, 데이터 중복 여부 정도는 미리 체크하기!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;28-managers-with-at-least-5-direct-reports&quot;&gt;2.8 Managers with at Least 5 Direct Reports&lt;/h2&gt;
&lt;h3 id=&quot;281-table-descriptoin--question&quot;&gt;2.8.1 Table descriptoin &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Employee&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;name&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;department&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;managerId&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each row of this table indicates the name of an employee, their department, and the id of their manager. If managerId is null, then the employee does not have a manager. No employee will be the manager of themself.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;
Write an SQL query to report the managers with at least five direct reports.&lt;br /&gt;
Return the result table in any order.&lt;/p&gt;

&lt;h3 id=&quot;282-solution&quot;&gt;2.8.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;managerId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;managerId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;managerId&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  maneger id 별로 id가 몇 명인지 구한다음 값이 5 이상인 manager id를 구하면 되는 문제이다. 처음에 문제를 보고 어떻게 풀어야 할지 감이 안와서 subquery를 활용했다. 개인적으로는 Simple하게 가장 좋다고 생각하기에 굳이 subquery를 써야하는 상황이 아니면 쓰고 싶지 않았다. (현 수준 문제에서 subquery를 요구하는 거 같진 않았다.) 하지만, 다른 아이디어가 없었기에 subquery로 manager id 별로 id 수를 구한 다음 left join하여 값이 5이상인 manager를 추출하였다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Better Solution&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;INNER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;managerId&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;HAVING&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  문제를 풀고 다른 사람의 solutions 중 개인적으로 가장 깔끔하다고 생각하여 가져왔다. 그리고 Having 절에 대해 처음 알게 됐다.(이전에는 몰랐다 ㅠㅠ)
SQL 코드도 짧아졌고 기존 코드보다 직관적으로 이해도 쉽다.&lt;/p&gt;

&lt;h3 id=&quot;283-good-to-know-where-vs-having&quot;&gt;2.8.3 Good to Know: Where vs. Having&lt;/h3&gt;
&lt;p&gt;  Where 절과 Having 절은 둘 다 필터링할 때 사용할 수 있다는 공통적인 기능을 제공하지만 차이가 있다. Having 절은 그룹을 필터링하는 데 쓰이며, 집계 함수를 사용하여 필터링이 가능한 반면, Where 절은 개별 행에 대한 필터링이 가능하며 집계 함수를 활용한 필터링이 불가능하다. 즉, Having은 그룹화 혹은 집계 값에 대한 레코드를 필터링하는데 사용되며, Where 절은 개별값에 대한 레코드를 필터링하는데 사용된다.&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@ljs7463/SQL-having-%EA%B3%BC-where-%EC%B0%A8%EC%9D%B4&quot;&gt;참조사이트&lt;/a&gt;: Having 절에 대한 내용은 해당 블로그에서 참조하였습니다.&lt;/p&gt;

&lt;h2 id=&quot;29-confirmation-rate&quot;&gt;2.9 Confirmation Rate&lt;/h2&gt;
&lt;h3 id=&quot;291-table-descriptoin--question&quot;&gt;2.9.1 Table descriptoin &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Signups&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;user_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;time_stamp&lt;/td&gt;
      &lt;td&gt;datetime&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Each row contains information about the signup time for the user with ID user_id.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;table: Confirmations&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;user_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;time_stamp(PK)&lt;/td&gt;
      &lt;td&gt;datetime&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;action&lt;/td&gt;
      &lt;td&gt;ENUM&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;user_id is a foreign key with a reference to the Signups table.
action is an ENUM of the type (‘confirmed’, ‘timeout’)
Each row of this table indicates that the user with ID user_id requested a confirmation message at time_stamp and that confirmation message was either confirmed (‘confirmed’) or expired without confirming (‘timeout’).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;
The confirmation rate of a user is the number of ‘confirmed’ messages divided by the total number of requested confirmation messages. The confirmation rate of a user that did not request any confirmation messages is 0. Round the confirmation rate to two decimal places.&lt;br /&gt;
Write an SQL query to find the confirmation rate of each user.&lt;br /&gt;
Return the result table in any order.&lt;/p&gt;

&lt;h3 id=&quot;292-solution&quot;&gt;2.9.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Coalesce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;confirmed&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;confirmation_rate&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;Signups&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;Confirmations&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  confirmation rate을 구하기 위해서는 confirmed 수와 total 수를 구해야 한다. 그래서 case 절을 사용해서 confirmed 수를 구했고 count(*)를 활용해 total 수를 구했다. 근데 굳이 각각 수를 더해서 나눠줄 필요없이 avg 함수를 활용해서 confirmation rate을 구할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;avg(case when c.action = &apos;confirmed&apos; then 1 else 0 end)&lt;/code&gt;, 이 방법도 깔끔하고 좋은 것 같다.&lt;/p&gt;

</description>
        <pubDate>Sat, 01 Jul 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/SQL_LeetCode3_Join2/</link>
        <guid isPermaLink="true">http://localhost:4000/data/SQL_LeetCode3_Join2/</guid>
        
        <category>Data</category>
        
        <category>SQL</category>
        
        <category>LeetCode</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[SQL] LeetCode 풀이: Basic Joins</title>
        <description>&lt;p&gt;  안녕하세요. LeetCode SQL50 두번째 파트인 Basic Joins입니다. Join은 2개 이상의 테이블을 Key를 활용해 하나로 합치는 기능입니다. Join의 방법은 left, inner, outer 등이 있으며 굉장히 많이 활용되는 기능입니다.&lt;/p&gt;

&lt;h1 id=&quot;2-basic-joins&quot;&gt;2. Basic Joins&lt;/h1&gt;
&lt;h2 id=&quot;21-replace-employee-id-with-the-unique-identifier&quot;&gt;2.1 Replace Employee ID With The Unique Identifier&lt;/h2&gt;
&lt;h3 id=&quot;211-table-description--question&quot;&gt;2.1.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Employees&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Colum Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;name&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;id is the primary key for this table.&lt;br /&gt;
Each row of this table contains the id and the name of an employee in a company.&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;table: EmployeeUNI&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;unique_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;(id, unique_id) is the primary key for this table.&lt;br /&gt;
Each row of this table contains the id and the corresponding unique id of an employee in the company.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;br /&gt;
Write an SQL query to show the unique ID of each user, If a user does not have a unique ID replace just show null.&lt;br /&gt;
Return the result table in any order.&lt;/p&gt;
&lt;h3 id=&quot;212-solution&quot;&gt;2.1.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_id&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unique_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;          &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Employees&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;EmployeeUNI&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;user_id를 key로 Empolyee테이블에 EmployeeUNI테이블의 unique_id를 붙이면 되는 아주 간단한 문제이다.&lt;/p&gt;

&lt;h3 id=&quot;213-good-to-know&quot;&gt;2.1.3 Good to Know&lt;/h3&gt;
&lt;p&gt;Left Join 할 때, 매칭되는 값이 없는 경우에는 null로 붙는다.&lt;/p&gt;

&lt;h2 id=&quot;22-product-sales-analysis-i&quot;&gt;2.2 Product Sales Analysis I&lt;/h2&gt;
&lt;h3 id=&quot;221-table-description--question&quot;&gt;2.2.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Sales&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Colum Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;sale_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;product_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;year&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;quantity&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;price&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;(sale_id, year) is the primary key of this table.&lt;br /&gt;
product_id is a foreign key to Product table.&lt;br /&gt;
Each row of this table shows a sale on the product product_id in a certain year.&lt;br /&gt;
Note that the price is per unit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;table: Product&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;product_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;product_name&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;product_id is the primary key of this table.&lt;br /&gt;
Each row of this table indicates the product name of each product.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;br /&gt;
Write an SQL query that reports the product_name, year, and price for each sale_id in the Sales table.&lt;br /&gt;
Return the result table in any order.&lt;/p&gt;

&lt;h3 id=&quot;222-solution&quot;&gt;2.2.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;year&lt;/span&gt;              &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;year&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;price&lt;/span&gt;             &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;price&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_name&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product_name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Sales&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Product&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 문제와 마찬가지로 간단한 Join이라 부가설명 없이 넘어가도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;23-customer-who-visited-but-did-not-make-any-transactions&quot;&gt;2.3 Customer Who Visited but Did Not Make Any Transactions&lt;/h2&gt;
&lt;h3 id=&quot;231-table-description--question&quot;&gt;2.3.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Visits&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;visit_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;customer_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;This table contains information about the customers who visited the mall.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;table: Transactions&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;transaction_id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;visit_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;amount&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;This table contains information about the transactions made during the visit_id.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;
Write a SQL query to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits.&lt;/p&gt;

&lt;h3 id=&quot;232-solution&quot;&gt;2.3.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count_no_trans&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Visits&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Transactions&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visit_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visit_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;isnull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visit_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;By&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer_id&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Join 하는 경우에도 WHERE 절이나 Group By를 통한 집계도 가능하다!&lt;/p&gt;

&lt;h2 id=&quot;24-rising-temperature&quot;&gt;2.4 Rising Temperature&lt;/h2&gt;
&lt;h3 id=&quot;241-table-descriptoin--question&quot;&gt;2.4.1 Table descriptoin &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;p&gt;table: Weather&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;id(PK)&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;recordDate&lt;/td&gt;
      &lt;td&gt;date&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;temperature&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;This table contains information about the temperature on a certain day.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;
Write an SQL query to find all dates’ Id with higher temperatures compared to its previous dates (yesterday).&lt;br /&gt;
Return the result table sorted by id in ascending order.&lt;/p&gt;

&lt;h3 id=&quot;242-solution&quot;&gt;2.4.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Weather&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Join&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;Weather&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recordDate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATE_ADD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recordDate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Interval&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Where&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temperature&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temperature&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;동일 테이블에 Join하는 self table join이며, 어제보다 오늘 기온이 높은 날을 찾아야 한다. 그러기 위해선 오늘 온도와 어제 온도를 비교할 수 있어야 한다. 기본 아이디어는 어제 날짜를 마치 오늘인 것처럼 변환해서 Join하는 것이다. 위 SQL 구문에서 Key 부분을 풀어서 설명하자면, b 테이블 날짜에서 하루를 더해준 날짜와 a 테이블 날짜를 Join 하게 되면 a 테이블 입장에서 전날 데이터가 Join 되게 된다. 예를 들어, ‘2023년 6월 28일’에서 하루 더해주면 ‘2023년 6월 29일’이 되고 이를 기존 테이블에 Join 했을 때, ‘2023년 6월 29일’에 28일 데이터가 붙게 된다. 처음 문제를 보고 막막했는데 아이디어만 잘 낸다면 어렵지 않게 풀 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;143-good-to-know&quot;&gt;1.4.3 Good to Know&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DATE_ADD&lt;/code&gt; 함수는 기준 날짜에 지정한 값만큼 더해주는 시간 함수이다. 첫번째 인수로는 기준 시간을 입력하고, 두번째 인수로 원하는 단위를 입력하면 된다. ‘Interval 1 DAY’는 하루만큼 더하라는 의미이며, second, month, year 등 다양한 인수를 넣어줄 수 있다.&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Jun 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/SQL_LeetCode2/</link>
        <guid isPermaLink="true">http://localhost:4000/data/SQL_LeetCode2/</guid>
        
        <category>Data</category>
        
        <category>SQL</category>
        
        <category>LeetCode</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[SQL] LeetCode 풀이</title>
        <description>&lt;p&gt;  안녕하세요. 데이터 분석가에게 SQL 활용 능력은 필수적이라 생각됩니다. 웬만한 데이터 분석가 JD 요구사항에 SQL 활용능력이 없는 경우는 없더군요. 저도 데이터 분석가 업무를 하면서 실무에서 유사(?) SQL을 활용해 데이터 마트를 만들지만 내가 SQL을 제대로 다루고 있는지 항상 의문이 따라왔습니다. 게다가 제 SQL 활용 능력이 어느정도인지 궁금하기도 했습니다. 따라서 실무 외에 SQL을 제대로 한 번 공부해보고 싶었고, 그 중 하나로 웹에 SQL 문제를 풀어보기로 했습니다. 구글링을 해보니 SQL 문제를 제공하는 여러 사이트가 나왔고, 그 중에서 LeetCode가 50문제 정도를 무료로 제공하길래 시작으로 괜찮다 싶어서 정했습니다! 리트코드 50문제를 풀어보고 문제별로 Solution을 이 블로그에 정리하고자 합니다.&lt;/p&gt;

&lt;h1 id=&quot;1-select&quot;&gt;1. Select&lt;/h1&gt;
&lt;p&gt;  첫 Section은 Select로 아주 기본적인 SQL 문을 활용해 풀 수 있는 문제들이었다.&lt;/p&gt;
&lt;h2 id=&quot;11-recyclable-and-low-fat-products&quot;&gt;1.1 Recyclable and Low Fat Products&lt;/h2&gt;
&lt;h3 id=&quot;111-table-description--question&quot;&gt;1.1.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Colum Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Product_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;low fats&lt;/td&gt;
      &lt;td&gt;enum&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;recyclable&lt;/td&gt;
      &lt;td&gt;enum&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;table name is “PRODUCTS”&lt;br /&gt;
product_id is the primary key for this table. &lt;br /&gt;
low_fats is an ENUM of type (‘Y’, ‘N’) where ‘Y’ means this product is low fat and ‘N’ means it is not.&lt;br /&gt;
recyclable is an ENUM of types (‘Y’, ‘N’) where ‘Y’ means this product is recyclable and ‘N’ means it is not.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;br /&gt;
Write an SQL query to find the ids of products that are both low fat and recyclable.&lt;br /&gt;
Return the result table in any order.&lt;/p&gt;
&lt;h3 id=&quot;112-solution&quot;&gt;1.1.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;PRODUCTS&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;low_fats&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Y&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recyclable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Y&apos;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문제가 요구하는 것은 low fat이고 재활용 가능한 제품명을 추출해 보여달라는 것이다. low fat &amp;amp; recyclable한 제품만을 추출하기 위해 조건절을 추가해주면 된다. WHERE 조건절도 각각 본인 스타일에 맞게 쓰면 된다. 하나의 정답만 있는 것은 아니다.&lt;/p&gt;

&lt;h3 id=&quot;113-good-to-know&quot;&gt;1.1.3 Good to Know&lt;/h3&gt;
&lt;p&gt;Enum 타입 데이터는 Character형 데이터 타입이며, 해당 Column에 할당할 수 있는 값들을 지정해 줄 수 있다. 해당 데이터 칼럼에 값들을 제약할 수 있는 기능을 재공해준다(데이터 정합성 확보에 유리함). Enum 타입 데이터 칼럼은 값과 index 모두 활용하여 값을 불러올 수 있다. &lt;br /&gt;
다만, Enum 타입에 새로운 데이터를 추가할 때 번거로움이 있으며 정렬이나 연산 시 불리하다는 의견도 있는 것 같다. 추가로 Enum 타입 데이터를 지원하지 않는 DBMS로의 이식이 어려울 수 있을 것 같다. 따라서 굳이 Enum 타입 데이터를 활용하기 보다는 참조 테이블을 활용하는 것이 좋을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;12-find-customer-referee&quot;&gt;1.2 Find Customer Referee&lt;/h2&gt;
&lt;h3 id=&quot;121-table-description--question&quot;&gt;1.2.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Colum Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;name&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;refree_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;br /&gt;
Customer table:&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;referee_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Will&lt;/td&gt;
      &lt;td&gt;null&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Jane&lt;/td&gt;
      &lt;td&gt;null&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Alex&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Bill&lt;/td&gt;
      &lt;td&gt;null&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Zack&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;Mark&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;table name is “Customer”&lt;br /&gt;
Each row of this table indicates the id of a customer, their name, and the id of the customer who referred them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;br /&gt;
Write an SQL query to report the names of the customer that are not referred by the customer with id = 2.
Return the result table in any order.&lt;/p&gt;

&lt;h3 id=&quot;122-solution&quot;&gt;1.2.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Customer&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;referee_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;isnull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;referee_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;input Table을 보면 refree_id에 null값이 포함되어 있다. 만약 Where 조건절에 refree_id != 2 조건만 있으면 refree_id가 null인 값을 제외시켜 버리기 때문에, refree_id가 null인 record를 불러오기 위해 조건을 추가해야 한다. 따라서 refree_id != 2 or isnull(refree_id)로 조건절을 줘야 refree_id가 2인 record를 제외한 모든 record를 불러오게 된다.&lt;/p&gt;

&lt;h3 id=&quot;133-good-to-know&quot;&gt;1.3.3 Good to Know&lt;/h3&gt;
&lt;p&gt;다른 사람이 올린 Solution 중, null값을 처리하는 다양한 방법이 있길래 알아두면 좋을 것 같아 기록하고자 한다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;refree_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IS&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Coalesce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;refree_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;isnull() 등 함수를 활용하여 null값을 처리하는게 익숙하다보니 함수로 처리했는데, 함수를 쓰지 않아도 “IS Null” 구문으로 처리가 가능하다. 직관적으로 이해하기 쉽다. &lt;br /&gt;
coalesce 함수는 보통 Null값이 있는 데이터 컬럼을 처리할 때 종종 사용하는 함수이다. 첫 번째 인수로 들어가 있는 컬럼의 값이 Null인 경우 두 번째 인수의 값을 할당하고 두 번째 인수의 값도 Null인 경우 그 다음 인수의 값을 할당해주는 식의 함수이다. 위의 코드를 해석하면 refree_id가 null인 경우에 0을 할당해주고 그 값이 2가 아닌 경우를 판별하는 조건문이다. If 문을 활용하는 것보다 훨씬 깔끔하다 ㅎㅎ&lt;/p&gt;

&lt;h2 id=&quot;13-big-countries&quot;&gt;1.3 Big Countries&lt;/h2&gt;
&lt;h3 id=&quot;131-table-description--question&quot;&gt;1.3.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;name&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;continent&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;area&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;population&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;gdp&lt;/td&gt;
      &lt;td&gt;bigint&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;name is the primary key column for this table.&lt;br /&gt;
Each row of this table gives information about the name of a country, the continent to which it belongs, its area, the population, and its GDP value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;br /&gt;
Customer table:&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;continent&lt;/th&gt;
      &lt;th&gt;area&lt;/th&gt;
      &lt;th&gt;population&lt;/th&gt;
      &lt;th&gt;gdp&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Afghanistan&lt;/td&gt;
      &lt;td&gt;Asia&lt;/td&gt;
      &lt;td&gt;652230&lt;/td&gt;
      &lt;td&gt;25500100&lt;/td&gt;
      &lt;td&gt;20343000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Albania&lt;/td&gt;
      &lt;td&gt;Europe&lt;/td&gt;
      &lt;td&gt;28748&lt;/td&gt;
      &lt;td&gt;2831741&lt;/td&gt;
      &lt;td&gt;12960000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Algeria&lt;/td&gt;
      &lt;td&gt;Africa&lt;/td&gt;
      &lt;td&gt;2381741&lt;/td&gt;
      &lt;td&gt;37100000&lt;/td&gt;
      &lt;td&gt;188681000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Andorra&lt;/td&gt;
      &lt;td&gt;Europe&lt;/td&gt;
      &lt;td&gt;468&lt;/td&gt;
      &lt;td&gt;78115&lt;/td&gt;
      &lt;td&gt;3712000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Angola&lt;/td&gt;
      &lt;td&gt;Africa&lt;/td&gt;
      &lt;td&gt;1246700&lt;/td&gt;
      &lt;td&gt;20609294&lt;/td&gt;
      &lt;td&gt;100990000000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;
A country is big if:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;it has an area of at least three million (i.e., 3000000 km2), or&lt;/li&gt;
  &lt;li&gt;it has a population of at least twenty-five million (i.e., 25000000).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Write an SQL query to report the name, population, and area of the big countries.&lt;br /&gt;
big 조건에 부합하는 국가의 국가명, 인구, 면적을 report하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;132-solution&quot;&gt;1.3.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;population&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;area&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; 
  &lt;span class=&quot;n&quot;&gt;World&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;area&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3000000&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;population&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25000000&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;간단한 문제이므로 추가설명은 하지 않도록 하겠다.&lt;/p&gt;

&lt;h2 id=&quot;14-article-views-i&quot;&gt;1.4 Article Views I&lt;/h2&gt;
&lt;h3 id=&quot;141-table-descriptoin--question&quot;&gt;1.4.1 Table descriptoin &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;article_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;author_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;viewer_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;view_date&lt;/td&gt;
      &lt;td&gt;date&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;There is no primary key for this table, it may have &lt;strong&gt;duplicate rows.&lt;/strong&gt; &lt;br /&gt;
Each row of this table indicates that some viewer viewed an article (written by some author) on some date. &lt;br /&gt;
Note that &lt;strong&gt;equal author_id and viewer_id indicate the same person.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;주의해야 할 점은 데이터가 중복인 row가 있다는 것과 author_id와 viewer_id가 값이 같다면 동일인물이라는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;br /&gt;
Customer table:&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;article_id&lt;/th&gt;
      &lt;th&gt;author_id&lt;/th&gt;
      &lt;th&gt;viewer_id&lt;/th&gt;
      &lt;th&gt;view_date&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;2019-08-01&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;2019-08-02&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2019-08-01&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;2019-08-02&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2019-07-22&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;2019-07-21&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;2019-07-21&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;
Write an SQL query to find all the authors that viewed at least one of their own articles.&lt;br /&gt;
Return the result table sorted by id in ascending order.&lt;/p&gt;

&lt;h3 id=&quot;142-solution&quot;&gt;1.4.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;author_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Views&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;author_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewer_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;asc&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;중복값을 처리하기 위해 SELECT 문 뒤에 DISTINCT를 추가했다. 실무에서도 Table을 로드할 때, 습관적으로 Distinct를 붙여주곤 한다. 특히, 여러 테이블을 Join할 때, 중복값이 있는 경우 결과값이 뻥튀기 되어 컴퓨팅 리소스를 한계 이상으로 활용하여 다운될 수 있는 위험이 있기 때문이다. 물론 중복이 애초에 안생기게 하는 것이 최선이지만 혹시 모를 사고를 미연에 방지하기 위한 습관이다.&lt;/p&gt;

&lt;h3 id=&quot;143-good-to-know&quot;&gt;1.4.3 Good to Know&lt;/h3&gt;
&lt;p&gt;SQL린이 시절, 오름차순 내림차순이 항상 헷갈렸다. 이제는 헷갈릴 일이 없긴 하지만, 오름차순은 낮은 값부터 높은 값 순으로 정렬하는 거고 영어로 보통 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asc or ascending&lt;/code&gt;로 표기한다. 내림차순은 반대이며 보통 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;desc or descending&lt;/code&gt;으로 표기한다.&lt;/p&gt;

&lt;h2 id=&quot;15-invalid-tweets&quot;&gt;1.5 Invalid Tweets&lt;/h2&gt;
&lt;h3 id=&quot;151-table-description--question&quot;&gt;1.5.1 Table Description &amp;amp; Question&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Table&lt;/strong&gt; description&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Column Name&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;tweet_id&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;content&lt;/td&gt;
      &lt;td&gt;varchar&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;tweet_id is the primary key for this table.&lt;br /&gt;
This table contains all the tweets in a social media app.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt;&lt;br /&gt;
Customer table:&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;tweet_id&lt;/th&gt;
      &lt;th&gt;content&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Vote for Biden&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Let us make America great again!&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt; &lt;br /&gt;
Write an SQL query to find the IDs of the invalid tweets. The tweet is invalid if the number of characters used in the content of the tweet is &lt;strong&gt;strictly greater than 15.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;152-solution&quot;&gt;1.5.2 Solution&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tweet_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Tweets&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문제에서 요구한 글자수가 15보다 많은 tweet_id를 추출하기 위해서 content 데이터의 글자수를 알아야한다. character형태의 데이터의 글자수를 알기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;length()&lt;/code&gt; 함수를 활용하면 된다.&lt;/p&gt;

</description>
        <pubDate>Sun, 18 Jun 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/SQL_LeetCode1/</link>
        <guid isPermaLink="true">http://localhost:4000/data/SQL_LeetCode1/</guid>
        
        <category>Data</category>
        
        <category>SQL</category>
        
        <category>LeetCode</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[하루일기] 23년 6월 13일: 감정적인 대응</title>
        <description>&lt;p&gt;  오늘 클라이언트와 아주 약간 언짢은 상황이 발생했다. 좀처럼 적극적으로 액션을 취하지 않는 클라이언트에게 나도 팀장님도 답답함이 계속 쌓여가는 상황이었는데, 클라이언트와 커뮤니케이션 과정에서 감정적인 대응이 나와버렸다. 화를 내거나 공격적인 언사를 한 것은 아니었지만, 스스로 조금 더 냉정하게 대응했으면 어떘을까 하는 아쉬움이 많이 남습니다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  상황은 이러했다. 팀장님은 답답한 마음에 타 사업부에 분석 사례를 클라이언트가 참고할 수 있도록 공유하라 지시했고, 짧은 메시지와 함꼐 자료를 첨부하여 메일을 보냈다. 문제는 클라이언트가 굉장히 불편하게 받아들이면서 발생했다. 클라이언트가 마치 자기보고 배우라는 듯이 자료를 보낸거냐부터 시작해서 엔지니어 입장에서 택도 없는 분석이라면서 말도 안되는 거라면서 따졌다. (물론, 숨은 의도는 그게 맞다. 게다가 자료는 공장 엔지니어가 직접 작성한 자료라 아예 틀린 말은 아닐 것이다.) 여기서 나의 올바른 대응은 나도 팀장님의 지시사항을 수행한 것이며, 도움이 될 수 있도록 자료를 공유하고자 한 것이라고 어필을 해야 했다. 하지만 그 동안 답답한 마음이 쌓였던 탓인지 자그마한 설전이 오고가게 됐다. 도메인 영역 지식으로 논리를 펼치니 난 더 할 말이 없었고, 알겠다고 수긍하며 일단락 지었다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  오늘 일련의 해프닝을 겪으며 스스로에게 아쉬었던 점은 다음과 같다&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;감정적으로 대응한 점
      &lt;ul&gt;
        &lt;li&gt;내 뜻대로 안된다고 답답해하거나 조급해 하지 말기&lt;/li&gt;
        &lt;li&gt;감정적인 반응에 감정적으로 맞대응 하지 말기&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;나의 역할은 중간 커뮤니케이선
      &lt;ul&gt;
        &lt;li&gt;클라이언트와 팀장 사이에 중간 커뮤니케이션 분배 잘하기&lt;/li&gt;
        &lt;li&gt;책임과 역할 소재 분명히 하기&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;어설픈 논리와 근거로 커뮤니케이션 하지 않기
      &lt;ul&gt;
        &lt;li&gt;상대방은 한 분야의 전문가이므로 어설픈 얘기는 통하지 않음&lt;/li&gt;
        &lt;li&gt;적어도 최소한의 논리로 무장하기&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;  일을 하다보면 클라이언트와 의견 충돌이 발생하고 언쟁이 발생할 수 있다고 생각하고 실제로 벌어졌습니다. 갈등 상황을 피하는 것이 능사는 아니라 생각합니다. 서로의 의견을 논리정연하게 피력하고 건설적으로 대화하는 것이 중요하겠죠. 다만, 감정적으로 대응하는 것은 프로답지 못한 행동이라 생각되고 반성하게 되네요. 앞으로는 오늘같은 일이 일어나더라도 차분하고 이성적으로 대응할 수 있는 사람이 되도록 노력하겠습니다.&lt;/p&gt;
</description>
        <pubDate>Tue, 13 Jun 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/daily_memo/</link>
        <guid isPermaLink="true">http://localhost:4000/data/daily_memo/</guid>
        
        <category>Data</category>
        
        <category>Memoir</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[회고록] 23년 6월 2주차: 분석 능력이란 뭘까?</title>
        <description>&lt;p&gt;  최근 SNS 중 하나인 링크드인을 자주 봅니다. 따로 글을 쓰거나 하진 않지만, 제가 몸담고 있는 업계에 다른 동료분들이 어떤 생각을 가지고 일하는 지 알 수 있어서 꽤 재밌게 보고 있습니다. 링크드인 속에는 수많은 데이터 분석가(+데이터 전문가) 분들이 있고, 저마다의 업무 역량, 분석 역량을 뽐내고 계십니다. 피드들을 열심히 눈팅하다보니 문득 그런 생각이 들더군요. &lt;strong&gt;그렇다면 과연 분석 능력이란 뭘까요?&lt;/strong&gt; 나의 분석 능력은 뛰어나다고 할 수 있는 건가? 나는 좋은 분석가인가? 라는 고민이 이어지게 됩니다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  생각하면 할수록 정말 답하기 어려운 질문인 것 같습니다. 업무 분야도 다 다르고 각자 생각하는 기준이 다 다르기 떄문이기에 딱 하나의 정답은 없는 것 같습니다. 별다른 구분 없이 생각나는대로 나열해보겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;데이터 분석을 통해 프로덕트에 유의미한 성장을 이끌어 냄&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;데이터 분석을 통해 클라이언트의 문제를 해결해 냄&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;최신 예측 모형에 대하여 꾸준히 학습하고 예측력이 좋은 ML 모형을 개발할 줄 암&lt;/li&gt;
    &lt;li&gt;데이터 분석을 수행할 다양한 Tool을 다룰줄 암&lt;/li&gt;
    &lt;li&gt;데이터 핸들링을 기가막히게 함&lt;/li&gt;
    &lt;li&gt;BI를 활용해 대쉬보드/리포트/분석화면을 설계하고 개발함&lt;/li&gt;
    &lt;li&gt;도메인 지식에 대한 깊이있는 이해가 있음&lt;/li&gt;
    &lt;li&gt;데이터 분석 결과를 타인에게 설득할 수 있는 커뮤니케이션 스킬 혹은 문서 작성 스킬&lt;/li&gt;
    &lt;li&gt;업무를 대하는 태도, 책임감, 성실함 등&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;  데이터 분석가의 가장 궁극적인 목표는 결국 1 &amp;amp; 2번은 잘 할 수 있는 분석가가 되는 것이겠죠. 다만, 이는 온전히 개인의 역량으로 뭔가를 이루어내기 어렵다는 점에서 분석가의 개인적인 분석 능력이라 평하기는 매우 어렵습니다. 그리고 따지고 보면 1 &amp;amp; 2번 외에 나머지 항목들은 결국 1 &amp;amp; 2번을 잘하기 위한 것들입니다. 데이터 분석을 잘 하기 위한 도구인거죠. 칼을 잘 다룬다고 무조건 맛있는 음식을 만들어 내는 것은 아닌 것처럼 다양한 도구를 잘 다룬다고 데이터 분석을 잘한다고 하기는 어렵습니다. 실제로 IT 기반 &amp;amp; 코딩 능력 하나 없이 셀프서비스 소프트웨어를 활용해 데이터 분석을 기가막히게 본업에 활용해 유의미한 가치를 만들어내는 분들도 봤습니다. 물론, 도구를 잘 다루면 분석을 잘하고 분석 능력이 좋을 확률은 그렇지 않은 사람보다 훨씬 더 높다고 생각합니다. 하지만 중요한 것은 본질을 놓쳐서는 안된다는 것입니다. 너무 기술적인 부분에 집중하다보면 정작 분석에 있어서는 아쉬운 부분이 있을 수도 있다고 생각합니다. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  그렇다보니 시중에 쏟아지는 최신 기술, 동향에 압도되기 보다는 현재 본인 업무에 있어서 필요한 것을 채워가는게 중요하다고 생각합니다. 저도 가끔은 쏟아지는 최신 기술, 트렌드에 압도되는 것 같을 때도 있고 조급해질 떄도 있습니다. 그럴때면 괜히 조바심을 내기보다는 천천히 내가 부족한 것을 채우기 위해, 그리고 내 분석 업무에 도움될 만한 것들을 갖추기 위해 노력하고 있습니다. 그러다 보면 더 나은, 더 뛰어난 분석가가 될 수 있다고 생각하며 계속 채워나가는 중입니다. 개인적으로 요즘 가장 중요하게 생각하는 것은 분석함에 있어서 얼마나 논리적으로 사고하는가 입니다. 우리가 마주한 문제에 있어서 논리적으로 가설을 세우고 정리하여 접근해야지 헤매지 않고 답을 발견해 나갈 수 있다 생각합니다. 논리가 빈약한 채로 분석을 하면 장담컨대 답을 도출해 내기 어려울 뿐만 아니라 클라이언트를 설득하기는 더 어려울 것입니다. 그래서 전 의식적으로라도 더 논리적으로 사고하고 문제에 접근하고자 노력하고 있습니다. 가장 좋은 방법은 훌룡한 선배, 동료들의 방식을 보고 배우는 것입니다. 그렇기에 좋은 동료가 있는 집단으로 가야하는 것이구요. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  앞서 말했듯이 뛰어난 분석 능력은 무엇인가에 대한 하나의 답은 없는 것 같습니다. 하지만 분석가에 존재의의에 대해 고민하다보면 뛰어난 분석가가 되기 위해 무엇을 잘 해야 하는지는 명확한 것 같습니다. 훌룡한 분석가가 되기 위해 꾸준하게 나아가고자 합니다. 우리 모두 화이팅입니다!&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Jun 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/weekly_memoir_6/</link>
        <guid isPermaLink="true">http://localhost:4000/data/weekly_memoir_6/</guid>
        
        <category>Data</category>
        
        <category>Memoir</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[회고록] 23년 5월 3주차: 에너지 절감(1/2)</title>
        <description>&lt;p&gt;  안녕하세요. 요즘엔 &lt;strong&gt;데이터 분석을 통해 공장에서 사용하는 에너지 절감 프로젝트&lt;/strong&gt;를 수행중에 있습니다. 최근 에너지 원가 상승으로 인하여 에너지 비용이 증가하여 공장 입장에서는 부담이 되고 있는 상황입니다. 따라서 공장에서는 에너지 절감을 위해 다양한 활동을 수행하고 있고, 그 노력의 일환으로 데이터 분석을 통한 에너지 사용 절감안을 도출하고자 합니다. ‘23년 1년 프로젝트로 기획됐고 2월부터 시작해 현재 진행중에 있습니다. 보안 상 디테일한 부분을 얘기하긴 어렵지만 어떻게 데이터 분석 프로젝트를 진행하고 있는지 간략하게만 기록하겠습니다.
&lt;br /&gt;&lt;br /&gt;
  에너지 절감을 위하여 다양한 접근 방법이 있겠지만 우리는 다음과 같은 방식으로 단계로 데이터 분석 프로젝트를 진행했습니다.&lt;/p&gt;

&lt;h2 id=&quot;1-에너지-파악&quot;&gt;1. 에너지 파악&lt;/h2&gt;
&lt;p&gt;  우선, 공장에서 사용하고 있는 에너지 종류와 에너지 별 사용 목적에 대해 파악이 필요합니다. 어떤 에너지를 사용하고 있고, 공장에서 사용하고 있는 다양한 에너지 중 가장 중요도가 큰 에너지는 무엇인지, 어느 공정에 어떤 목적으로 사용되고 있는지 등에 대한 공정 파악이 필요합니다. 에너지 사용 공정 메커니즘에 대한 이해없는 데이터 분석을 통해 유효한 인사이트를 도출하기는 어렵기 때문입니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;사용 에너지 종류, 중요도(우선순위), 사용 목적 파악&lt;/li&gt;
    &lt;li&gt;에너지 사용 공정에 대한 공정 메커니즘 파악&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-데이터-수집&quot;&gt;2. 데이터 수집&lt;/h2&gt;
&lt;p&gt;  프로젝트 대상 공장에서 사용하고 있는 에너지에 대한 파악이 되면, 본격적인 데이터 분석을 위한 데이터 수집이 필요합니다. 중요한 것은 에너지 사용량을 데이터로 관리하고 있는지부터 알아야 합니다(데이터가 없다면 애초에 분석 프로젝트 진행이 불가합니다). 데이터가 있다면 어디에 어떻게 관리하고 있는지, 어떻게 데이터를 가져와서 분석할 것인지에 대한 논의가 필요합니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;데이터 존재 여부 파악(에너지 사용량, 관련 공정 센싱, 품질 데이터 등)&lt;/li&gt;
    &lt;li&gt;데이터 저장 위치, 형태 등 파악&lt;/li&gt;
    &lt;li&gt;데이터 전처리 및 분석 데이터 마트 생성&lt;/li&gt;
    &lt;li&gt;BI 분석 화면 개발&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;21-데이터-이슈&quot;&gt;2.1 데이터 이슈&lt;/h3&gt;
&lt;p&gt;  현재 프로젝트 대상 공장에서는 공정/설비별로 사용하고 있는 에너지 사용량을 일/월 별로 기입하여 관리하고 있었고, 분석 데이터 마트를 생성하기 위해서는 엑셀로부터 데이터를 추출하는 프로그램을 짜야했습니다. 문제는 작업자가 일일이 수기로 입력한 데이터 이기에 오기입된 데이터도 많고 예외처리를 해야할 것이 정말 많았습니다. 이 오류를 처리하는데 애 많이 먹었습니다😭. 이에 더하여 외기온도 데이터가 필요한데 공장에서 수집하는 데이터가 없었기에, 공공기관데이터포털에서 제공하는 지역별 온도 데이터를 수집해서 대용으로 사용했습니다. rest api 호출하는 방식을 활용해 가져오는 데이터 추출 코드를 짜봤는데 재밌었습니다😄.&lt;/p&gt;

&lt;h3 id=&quot;22-주의할-점&quot;&gt;2.2 주의할 점&lt;/h3&gt;
&lt;p&gt;  데이터의 단위를 정확하게 확인해야 합니다. 특히, 공학, 자연과학 계열 전공자가 아니라 사회계열, 수리계열, 컴공계열 전공자라면 에너지(물질) 단위가 굉장히 헷갈릴 수 있습니다. 예를 들어, 유량 단위인지, 질량 단위인지 그리고 일별 사용량인지, 시간당 사용량인지 등 정확하게 파악이 필요합니다. 만약 단위를 제대로 감안하지 않은 채로 데이터 전처리하고 분석을 진행한다면 후에 계산이 잘못될 수 있으니 유의해야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;3-에너지-사용-현황-파악-문제점-도출&quot;&gt;3. 에너지 사용 현황 파악, 문제점 도출&lt;/h2&gt;
&lt;p&gt;  앞의 과정은 데이터 분석을 위한 준비과정이었다면 여기서부턴 본격적인 데이터 분석 과정에 들어갑니다. 이번 프로젝트에서는 다음 절차로 진행했습니다.&lt;/p&gt;

&lt;h3 id=&quot;31-분석-대상-순서-선정&quot;&gt;3.1 분석 대상, 순서 선정&lt;/h3&gt;
&lt;p&gt;  공장에서는 다양한 에너지를 사용해 제품을 생산하기 때문에 우선순위를 선정하여 진행합니다. (물론 인력이 충분하고 여유가 있다면 모든 에너지에 대하여 한 번에 진행해도 됩니다. 다만, 현실적으로 매우 어렵죠) 데이터 현황분석을 통해 사용량이 가장 많고 산포가 큰 에너지 순으로 우선순의를 정하거나 혹은 클라이언트의 요청으로 우선순위를 정하게 됩니다. 에너지 사용 산포가 작거나, 중요도가 낮은 에너지의 경우 분석 대상에서 제외되는 경우도 있습니다. 분석 대상이 선정된다면 관련 공정 메커니즘에 대한 이해는 필수입니다! 대상 공정에서 에너지가 사용되는 목적과 공정/품질 관리 인자와 기준 존재 여부 등 에너지 관련 공정 메커니즘 파악이 필요합니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;분석 대상 및 우선순위 선정&lt;/li&gt;
    &lt;li&gt;분석 대상 공정 메커니즘(에너지 관련) 파악&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;32-문제점-진단&quot;&gt;3.2 문제점 진단&lt;/h3&gt;
&lt;p&gt;  분석 대상이 선정되면 문제점을 진단해야 합니다. 현재 에너지 사용량이 적정 수준을 벗어나 과다한 것은 아닌 지, 절감 요소는 존재하는지 판단해야 합니다. &lt;br /&gt;&lt;br /&gt;
  그렇다면 &lt;strong&gt;판단 기준&lt;/strong&gt;은 무엇일까요?&lt;br /&gt;
  가장 기본은 &lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;외생 변수&lt;/strong&gt;&lt;/span&gt; 기준으로 체크하는 것입니다. 보통 가정집에서도 전기 요금을 비교할 때, 동월 간 비교를 합니다. 왜일까요? 여름에 에어컨을 틀면서 전기 요금이 많이 청구되고 따라서 환절기와 하절기 간 전기 요금 비교는 무의미하기 때문입니다. 공장도 마찬가지입니다. 동일 기온, 동일 생산조건, 동일 생산량(투입량)을 기준으로 에너지 사용량을 비교해야 합니다. 예를 들어, 계절별로 에너지 사용량에 차이가 발생하는 경우 외기온도를 고정시킨 다음에 에너지 사용량의 산포를 확인해야 합니다. 따라서 특정 공정별 사용 에너지에 따라 외생변수를 잘 정의해야 할 필요가 있습니다. &lt;br /&gt;
  다음으로는 &lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;공정 변경 혹은 운전 패턴 변경&lt;/strong&gt;&lt;/span&gt; 이력에 따른 에너지 사용량 변동을 파악하는 것입니다. 과거 공정 운전 패턴의 변경에 따라 에너지 사용량의 변화가 있는지 비교하여 현재 에너지 사용량에 대한 수준을 파악할 수 있습니다. 공정 운전 패턴 변경이 에너지 관점에서 낭비가 발생한다면 재검토해 볼 필요가 있을 수 있고 혹은 추가 개선 포인트를 도출해 낼 수 도 있을 겁니다. &lt;br /&gt;&lt;br /&gt;
  판단 기준에 따라 현재 에너지 사용이 적절한 지 혹은 과거 대비 낭비요소가 있는 지 등 다양한 측면에서 문제점을 진단합니다. 만약 낭비요소가 존재한다면 다음 스텝으로 넘어가 에너지 사용량의 편차(산포) 발생 원인을 도출하는 작업을 하게 됩니다. 낭비요소 없이 현 수준이 최적 에너지 사용 상태라면 더 이상 분석을 진행하지 않습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;에너지 별 외생변수 파악&lt;/li&gt;
    &lt;li&gt;공정 운전 패턴 변경이력 파악&lt;/li&gt;
    &lt;li&gt;문제점 진단&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;321-주의사항&quot;&gt;3.2.1 주의사항&lt;/h4&gt;
&lt;p&gt;  에너지 사용 문제점을 진단할 때 반드시 고려해야 할 부분이 바로 &lt;strong&gt;공정 품질&lt;/strong&gt;입니다. 에너지 사용량을 절감했지만 공정 품질을 만족하지 못한다면 이는 에너지 사용 과소 상태로 적절한 수준의 에너지 사용량이 아닙니다. 이 상태에서는 오히려 에너지를 더 투입하여 품질을 만족시켜야만 합니다. 반대로 현재 에너지 사용 수준에서 품질 관리 수준 대비 마진이 커 여유가 있다면, 에너지 과다 상태로 에너지 절감안 도출을 검토해 볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;4-다음-회고록을-기약하며&quot;&gt;4. 다음 회고록을 기약하며…&lt;/h2&gt;
&lt;p&gt;  회고록을 작성하다보니 처음 생각한 것 보다 내용이 너무 길어졌습니다. 현재 진행중인 프로젝트이기도 하고 남은 내용은 다음 회고록에 적을 수 있도록 하겠습니다. 그럼 이번 회고록은 여기서 마치도록 하겠습니다. 감사합니다!&lt;/p&gt;
</description>
        <pubDate>Sun, 21 May 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/weekly_memoir_5/</link>
        <guid isPermaLink="true">http://localhost:4000/data/weekly_memoir_5/</guid>
        
        <category>Data</category>
        
        <category>Memoir</category>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>[회고록] 23년 5월 1주차 회고록</title>
        <description>&lt;p&gt;  이번 회고록은 조금은 다른 내용에 대해서 적어보고자 합니다. 일과 관련된 얘기지만 업무나 기술, 테크와 관련된 얘기가 아닌 마음가짐?에 대한 얘기를 적어보고자 합니다.
&lt;br /&gt;&lt;br /&gt;
  4월 초부터 최근 1달간은 개인적인 사정으로 멘탈이 굉장히 좋지 않았습니다. 무던한 성격이라 웬만한 일에는 감정적으로 동요가 되지 않는 편인데도 불구하고 최근에는 감정적으로 좋지 않았습니다.
멘탈도 많이 흔들리고, 아무래도 잡생각과 고민이 많아지다보니 업무 중에도 집중하기가 쉽지 않았습니다. 업무 중에 다른 생각이 들때마다 “이러면 안돼, 집중해야 해, 프로다운 모습을 보여야 해”하며
마음을 다잡아봤지만, 생각처럼 쉽지 않았습니다. 심적으로 편하지 않은 상태다보니 육체적인 면에도 안좋은 영향을 끼쳤습니다. 육체적으로 피로해지니 심적으로도 더 안 좋아지구요. 악순환에 빠진 상태였습니다. 
차라리, 아예 다른 생각을 못하도록 일이 미친듯이 많았으면 집중할 수 있지 않을까란 생각도 해봤습니다. 이렇게 업무에 온전히 집중하지 못한 상태로 시간을 보냈습니다. 그러다가 외부적으로 상황이 해결되고 나니 
차츰 좋아졌고 다시 정상궤도로 올라올 수 있었습니다. 
&lt;br /&gt;&lt;br /&gt;
  이러한 시간을 겪다보니 개인적으로 느낀 점이 많았습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;내가 컨트롤 할 수 없는 외부 상황에 의해서 영향을 받을 수 있다는 점&lt;/li&gt;
    &lt;li&gt;멘탈적으로 혼란스러운 시기에 어떻게 하면 안정적으로 업무에 집중할 수 있는지에 대한 고민&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;  정리하자면, 어떻게 하면 &lt;strong&gt;마인드 컨트롤&lt;/strong&gt;을 잘 할 수 있을까에 대한 고민인 것 같습니다. 이 고민은 앞으로도 쭉 해야할 고민일 거라 생각합니다. 특히 내 스스로의 의지로 이 상황을 해결한 것이 아니라
외부적으로 해결되고 나서 안정된 점을 보았을 때 더욱 고민이 깊어졌습니다. 왜냐하면 앞으로 긴 인생을 살면서 스스로 어찌할 수 없는 상황이 분명히 생길 것이고 심지어 더 큰 문제를 맞닦뜨리게 될 수도 있다고 생각했습니다.
&lt;br /&gt;&lt;br /&gt;
  하나 긍정적인 점이 있다면, 그것은 이렇게 멘탈적으로 흔들릴 수 있는 스스로를 알게 됐고 인정하게 됐다는 점입니다. 이전까지만 해도 진심으로 저는 제가 강철 멘탈을 지닌 줄 알았지만, 전혀 그렇지 않을 수 있다는 것을 
알았습니다. 그렇지 않을 수 있다는 점을 받아들이고 나니 앞으로 이러한 문제가 발생할 것을 대비해야 겠다는 마음이 들었습니다.
&lt;br /&gt;&lt;br /&gt;
  개인적으로 도움이 많이 된 방법은 &lt;strong&gt;1. 운동하기&lt;/strong&gt;와 &lt;strong&gt;2. 가깝고 의지할 수 있는 사람들과 시간 보내기&lt;/strong&gt;가 있었습니다. 운동같은 경우에는 러닝이 참 도움이 많이 됐습니다. 언제나 지치고 우울감이 들때면, 억지로라도 
러닝을 하러 나갑니다. 한강변을 따라 야경을 보면서 러닝을 하다보면 숨이 차기 시작하면서 잡생각이 없어지고 몸이 풀리면서 기분도 한결 나아집니다. 다음으로는 제가 사랑하는 사람들을 만나 대화하고 시간을 보내는 것 입니다.
특히, 부모님을 찾아뵈어 만나면 그냥 그대로 위안이 되고 의지가 되더군요. 그렇게 주말을 보내면 재충전이 되고 더 나은 한주를 보낼 수 있었습니다.
&lt;br /&gt;&lt;br /&gt;
  반대로 지양해야 될 것은 지나친 음주였습니다. 멘탈이 안좋다보니 지인들과 술자리가 잦아졌습니다. 초반에는 기분도 풀리고 즐겁고 좋았습니다. 다만, 무의미한 술자리가 잦아지게 되면서 점점 숙취로 인한 피로는 쌓여가고 
반동으로 오는 우울감까지 더해지면서 상황이 나아지진 않더군요. 뭐든지 적당히가 좋은 것 같습니다.
&lt;br /&gt;&lt;br /&gt;
  마지막으로 다음에도 이런 일이 발생한다면 어떻게 하면 좋을까 생각했던 것이 있습니다. 바로, &lt;strong&gt;문제가 되는 상황을 최대한 빠르게 해결하는게 답&lt;/strong&gt;일 수도 있겠다 생각이 들었습니다. 나를 힘들게 하는 문제가 있다면 
더 적극적으로 해결해서 문제를 치울 수 있다면 그렇게 하는게 최선이란 생각이 들었습니다. 보통 업무를 함에도 우선순위를 정하듯이, 조금 더 큰 범위에서 우선순위를 정해보는 것이라 생각합니다.&lt;/p&gt;
</description>
        <pubDate>Sun, 07 May 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/weekly_memoir_4/</link>
        <guid isPermaLink="true">http://localhost:4000/data/weekly_memoir_4/</guid>
        
        <category>Data</category>
        
        <category>Memoir</category>
        
        
        <category>Data</category>
        
      </item>
    
  </channel>
</rss>