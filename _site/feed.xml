<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-10-10T23:05:12+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">끊임없이 성장하는 데이터 분석가</title><subtitle>조금씩 쌓아가다 보면 큰 산이 되겠지</subtitle><author><name>박마토</name></author><entry><title type="html">[파이썬] 코드 포매팅: 코딩 스타일 정립하기</title><link href="http://localhost:4000/python/clean_code3/" rel="alternate" type="text/html" title="[파이썬] 코드 포매팅: 코딩 스타일 정립하기" /><published>2023-10-08T00:00:00+09:00</published><updated>2023-10-06T06:17:00+09:00</updated><id>http://localhost:4000/python/clean_code3</id><content type="html" xml:base="http://localhost:4000/python/clean_code3/"><![CDATA[<blockquote>
  <p>이 포스트의 내용은 저자 Al Sweigart의 “클린 코드, 이제는 파이썬이다” 2부 내용임을 사전에 미리 밝힙니다!</p>
</blockquote>

<p>  처음 R과 Python을 배울 때에는 코딩 스타일에 대해 신경쓰지 않았습니다. 어짜피 혼자 보는 코드고 누구에게 공유하거나 협업 하리라고는 생각하지 못했었기 때문입니다. 그러다보니, 일관적인 코딩 스타일이 정립되지 않은채로 나쁜 습관인 것들도 굳어진 채로 실무에서 까지 활용하고 있었습니다. 이번 포스팅에서는 일반적으로 제안되는 코딩 스타일에 대해서 알아보겠습니다.<br /></p>

<p>  왜 코딩 스타일을 정립해야 할까요? 실무를 하다보면 혼자 하기보다는 대부분 협업해서 할일이 많습니다. 파이썬, SQL, BI Tool 등 프로그래밍 언어와는 무관하게 협업을 하면서 코드 포매팅이 중구난방이면 서로 공유하기 힘들어지고 효율성이 떨어지게 될 것입니다. 게다가 코드 유지보수를 위한 가독성에도 꼭 필요한 요소입니다. 물론, 사람마다 각각의 코딩 스타일이 있으므로 완벽하게 코딩 스타일을 똑같이 정립하여 적용할 순 없겠지만, 최소한 가독성이 좋도록 일관적인 코딩 스타일을 정립하는 중요하다고 생각합니다.</p>

<h1 id="0-스타일-가이드와-pep8">0. 스타일 가이드와 PEP8</h1>
<p>  본격적으로 들어가기 전에 PEP8(Python Enhancement Proposal 8)에 대해 소개하겠습니다. <a href="https://peps.python.org/pep-0008/">PEP8</a>은 파이썬 코어 개발팀이 작성한 스타일 가이드 중 하나입니다. 비록 파이썬 코어 개발팀이 제안한 방식이지만 무조건적으로 받아들여야할 필요는 없습니다. 읽어보고 일반적인 코딩 스타일은 어떤지 파악해보시고 본인만의 코딩 스타일을 정립하는 데에 활용하시기 바랍니다.</p>

<h1 id="1-가로-간격">1. 가로 간격</h1>
<p>  가로 간격, 즉, 코드 한 줄 내의 빈 공간 배치에 대한 내용입니다. 들여쓰기와 띄어쓰기와 같은 공백을 적절하게 배치해야 가독성이 높은 코드를 작성할 수 있습니다.</p>

<h2 id="11-들여쓰기">1.1 들여쓰기</h2>
<p>  들여쓰기(indentation)란 코드 행의 시작부에 있는 공백을 의미합니다. 보통, ‘Tab’키 혹은 ‘Space’키를 사용하여 들여쓰기를 하는데 이 책에서는 ‘Space’(공백)를 활용하는 것을 권고합니다. 이유는 탭은 \t로 \가 포함된 문자열로 랜더링되는 반면, 공백은 ‘ ‘으로 랜더링 되므로 서로 다르게 인식되기 때문입니다. 따라서 탭은 공백 수가 가변적입니다. 예를 들어 다음을 보면 이해가 쉽습니다.</p>

<p><img src="/assets/image/cleancode_tabspace.png" alt="image" /></p>

<p>  첫 번째 셀은 공백으로 구분하고 두 번째 셀은 탭으로 구분한 것입니다. 탭을 사용하게 되면 보이는 것과 같이 다음 탭스톱(tab stop)에서 텍스트가 이어지게 되므로 공백이 가변적이게 됩니다. 따라서, 탭이 나타내는 공백 폭이 가변적이기 때문에 <strong>탭은 소스코드에서 사용해서는 안됩니다</strong>.<br /></p>

<p>  파이썬의 경우, 보편적인 들여쓰기 관례는 공백 4칸입니다. (대부분의 코드 에디터와 IDE에서 탭 키를 누르면 4개 혹은 8개의 공백 문자를 자동으로 삽입합니다.)
예를 들어, 다음 예제에서 마침표를 사용해 공백 문자를 표시했습니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">getCatAmount</span><span class="p">():</span>
<span class="p">....</span><span class="n">numCats</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">'How many cats do you have?'</span><span class="p">)</span>
<span class="p">....</span><span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">numCats</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
<span class="p">........</span><span class="k">print</span><span class="p">(</span><span class="s">'You should get more cats'</span><span class="p">)</span>
</code></pre></div></div>
<blockquote>
  <p>사실 저도 VCS를 활용해 코드 스크립트를 작성할 때, 무의식적으로 탭키를 사용하곤 했었습니다. 물론, VCS가 자동으로 탭키를 공백 4개로 삽입해주긴 합니다. 편의성이 있어서 탭키를 활용하지만 이 부분에 인지했으니 유의하여 사용할 수 있도록 하겠습니다.</p>
</blockquote>

<h2 id="12-코드-행-내의-공백-활용">1.2 코드 행 내의 공백 활용</h2>
<ol>
  <li><strong>연산자와 식별자 사이에 공백 한 칸</strong><br />
저도 가장 즐겨쓰는 코딩 스타일 중 하나입니다. 연산자와 식별자 사이에 공간이 없다면 답답하고 읽기 힘들어서 항상 공백을 넣어서 코드를 짭니다. 공백을 넣어주면 구분이 확연하게 잘 됩니다. 아래 잘된 예와 나쁜 예를 보면 확 와닿을 겁니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># 잘된 예
</span> <span class="n">blanks</span> <span class="o">=</span> <span class="n">blanks</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">secretWord</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">blanks</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
 <span class="c1"># 나쁜 예
</span> <span class="n">blanks</span><span class="o">=</span><span class="n">blanks</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">secreWord</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">blanks</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
</code></pre></div>    </div>
  </li>
  <li><strong>구분자는 뒤쪽에 공백 한 칸</strong><br />
 쉼표와 같은 구분자를 쓸 때틑 보통 구분자 뒤쪽에 공백을 줍니다. 역시 구분자를 기준으로 앞뒤 명확하게 구분을 잘 보이게 하기 위함입니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># 잘된 예
</span> <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">eggs</span><span class="p">,</span> <span class="n">bacon</span><span class="p">,</span> <span class="n">ham</span><span class="p">):</span>
     <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">42.0</span><span class="p">,</span> <span class="mf">3.1415</span><span class="p">,</span> <span class="mf">2.718</span><span class="p">]</span>
 <span class="c1"># 나쁜 예1
</span> <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">eggs</span><span class="p">,</span><span class="n">bacon</span><span class="p">,</span><span class="n">ham</span><span class="p">):</span>
     <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">42.0</span><span class="p">,</span><span class="mf">3.1415</span><span class="p">,</span><span class="mf">2.718</span><span class="p">]</span>
 <span class="c1"># 나쁜 예2
</span> <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">eggs</span> <span class="p">,</span> <span class="n">bacon</span> <span class="p">,</span> <span class="n">ham</span><span class="p">):</span>
     <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">42.0</span> <span class="p">,</span> <span class="mf">3.1415</span> <span class="p">,</span> <span class="mf">2.718</span><span class="p">]</span>
</code></pre></div>    </div>
    <p>나쁜 예2 같은 경우에도 구분은 잘 되는 편이지만 뭔가 지면을 낭비하는 것 같아 선호하는 스타일은 아닙니다.</p>
  </li>
  <li><strong>마침표 앞뒤에는 공백 X</strong><br />
 공백이 없으면 객체와 그 속성 간의 연결을 강조할 수 있습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># 잘된 예
</span> <span class="s">'Hello, world'</span><span class="p">.</span><span class="n">upper</span><span class="p">()</span>
 <span class="c1"># 나쁜 예
</span> <span class="s">'Hello, world'</span> <span class="p">.</span> <span class="n">upper</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li><strong>함수, 메소드, 컨테이너 이름 뒤에는 공백 X</strong><br />
 함수나 메소드 명 뒤에는 괄호 쌍이 바로 따라 붙어야 쉽게 식별할 수 있습니다. 따라서, 함수나 메소드명 뒤에는 공백을 넣지 않는 게 좋습니다. 마찬가지로 인덱스, 슬라이스, 키를 쓸 때에도 대괄호 앞에 공백을 넣지 않는게 좋습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># 잘된 예
</span> <span class="k">print</span><span class="p">(</span><span class="s">'Hello, World!'</span><span class="p">)</span>
 <span class="n">spam</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
 <span class="n">spam</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
 <span class="n">pet</span><span class="p">[</span><span class="s">'name'</span><span class="p">]</span>
 <span class="c1"># 나쁜 예
</span> <span class="k">print</span> <span class="p">(</span><span class="s">'Hello, World!'</span><span class="p">)</span>
 <span class="n">spam</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
 <span class="n">spam</span>   <span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
 <span class="n">pet</span> <span class="p">[</span><span class="s">'name'</span><span class="p">]</span>
</code></pre></div>    </div>
    <p>공백이 들어가있는 코드 행을 보면 어색한 것을 알 수 있습니다.</p>
  </li>
  <li><strong>여는 괄호와 닫는 괄호 앞에는 공백 X</strong><br />
 괄호, 대괄호, 중괄호와 괄호 안의 내용 사이에는 공백이 없는 게 좋습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># 잘된 예
</span> <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">eggs</span><span class="p">,</span> <span class="n">bacon</span><span class="p">,</span> <span class="n">ham</span><span class="p">):</span>
     <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">42.0</span><span class="p">,</span> <span class="mf">3.1415</span><span class="p">,</span> <span class="mf">2.718</span><span class="p">]</span>
 <span class="c1"># 나쁜 예
</span> <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span> <span class="n">eggs</span><span class="p">,</span> <span class="n">bacon</span><span class="p">,</span> <span class="n">ham</span> <span class="p">):</span>
     <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">42.0</span><span class="p">,</span> <span class="mf">3.1415</span><span class="p">,</span> <span class="mf">2.718</span> <span class="p">]</span>
</code></pre></div>    </div>
    <p>물론 나쁜 예처럼 코드를 작성하더라도 전혀 문제가 되진 않습니다. 다만, 가독성이 특별히 개선되지 않으므로 굳이 써야 할 이유는 없을 것 같습니다.</p>
  </li>
  <li><strong>코드행 끝 주석 앞에는 공백 2칸</strong><br />
 코드 행 끝에 주석을 추가할 경우, 코드가 끝 나는 지점 뒤 2칸의 공백을 넣어준 후 주석을 입력합니다. 공백이 없는 경우는 구분하기가 어렵고 가독성이 떨어집니다. 저는 코드 행 마다 길이가 다르므로 가장 긴 코드행의 맞춰 주석을 작성하곤 했습니다. 다만, 그런 경우에는 코드 행이 짧은 경우에는 코드와 주석이 너무 떨어져 보기가 힘든 경우가 많았습니다. 이 책을 읽은 이후로는 코드 행의 주석을 추가할 경우 공백 2칸을 넣어준 뒤에 작성하고 있습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># 잘된 예
</span> <span class="k">print</span><span class="p">(</span><span class="s">'Hello, world!'</span><span class="p">)</span>  <span class="c1"># 인사말 출력
</span></code></pre></div>    </div>
  </li>
</ol>

<h1 id="2-세로-간격">2. 세로 간격</h1>
<p>  코드를 짤 때 세로 간격을 적절하게 배치하는 것 또한 매우 중요합니다. 세로 간격(vertical spacing)은 코드 행 사이에 빈 행을 배치하는 것을 의미합니다. 책에서는 세로 간격에 대해서 가로 간격처럼 일반적인 권장사항들은 없습니다. 다만, 제가 프로그램을 짜면서 즐겨 사용하는 방식이 몇 가지 있습니다.</p>
<ol>
  <li><strong>클래스 내 메서드는 빈 행으로 구분하기</strong><br />
 클래스 내 메서드 간 빈 행으로 구분해줄 경우, 눈으로 식별하기가 한결 수월했습니다.</li>
  <li><strong>if문, 반복문, try문 등 시작 부분 빈 행으로 구분하기</strong><br />
 보통 한 if문, 반복문, try문 등 한 코드 단락부분에서 시작부분 앞 코드 행과 구별해주기 위하여 빈 행을 삽입하는 방식을 즐겨합니다. 코드가 긴 경우, 빈 행으로 구분되어 있으면 코드 단략을 한 눈에 쉽게 식별할 수 있기에 자주 사용합니다.</li>
  <li><strong>세미콜론(;)은 사용 X</strong><br />
 각자 개인의 취향이 있겠지만, 저는 세미콜론(;)을 거의 활용하지 않습니다. 저는 한 행의 한 코드만 들어가도록 작성하는 습관이 있어서 한 코드행의 여러 코드가 들어가는 것을 선호하지 않습니다.</li>
  <li><strong>모듈당 하나의 import문으로 작성</strong><br />
 모듈을 불러올 때에도 마찬가지로 하나의 모듈당 하나의 import 문을 사용하는 것을 선호합니다. PEP8에서는 import 문을 다음과 같이 세 그룹으로 묶어서 순서대로 배치할 것을 권장합니다.
    <blockquote>
      <ol>
        <li>math, os, sys등 파이썬 표준 라이브러리의 모듈</li>
        <li>selenium, requests, django 등 서드파티 모듈</li>
        <li>현재 작성중인 프로그램의 일부 로컬 모듈</li>
      </ol>
    </blockquote>

    <p>의식하진 않지만 보통 모듈을 불러올 때, 보통 위에 순서대로 작성하곤 했습니다. 사실 굳이 지켜야 할 정도로 의미있는 규칙이라 생각하진 않지만 어느정도 체계가 있으면 좋을 것 같다는 생각은 합니다.</p>
  </li>
</ol>

<h1 id="3-마치며">3. 마치며</h1>
<p>  코딩 스타일이란 정답이 있는 것은 아닙니다. 하지만 동일한 내용을 전달하더라도 읽기 쉬운 글이 있고 어려운 글이 있습니다. 당연히 내용이 동일하다면 읽기 수월한 글이 더 좋은 글이겠죠? 코드도 마찬가지라 생각합니다. 결국 중요한 것은 일관된 코딩 스타일을 유지하며 내가 작성한 코드를 남이 봤을 때에도 수월하게 이해할 수 있느냐는 점입니다. 코딩 스타일이 일관되지 않다면, 본인이 작성한 코드를 한참 지난 후에 보면 이해가 잘 안될 때가 많습니다. 본인이 작성한 코드도 읽기 어려운데 남이 작성한 코드는 오죽할까요😭. 답이 없기에 더 나은 스타일은 없는지 고민해보고 적용해보고 다듬어 나갈 수 밖에 없는 것이 코딩 스타일이라 생각합니다.</p>]]></content><author><name>박마토</name></author><category term="Python" /><category term="Python" /><category term="Coding" /><category term="Review" /><summary type="html"><![CDATA[이 포스트의 내용은 저자 Al Sweigart의 “클린 코드, 이제는 파이썬이다” 2부 내용임을 사전에 미리 밝힙니다!]]></summary></entry><entry><title type="html">[파이썬] 파이썬 준비하기: 기본 개념 알아보기</title><link href="http://localhost:4000/python/clean_code2/" rel="alternate" type="text/html" title="[파이썬] 파이썬 준비하기: 기본 개념 알아보기" /><published>2023-10-05T00:00:00+09:00</published><updated>2023-10-06T06:17:00+09:00</updated><id>http://localhost:4000/python/clean_code2</id><content type="html" xml:base="http://localhost:4000/python/clean_code2/"><![CDATA[<blockquote>
  <p>이 포스트의 내용은 저자 Al Sweigart의 “클린 코드, 이제는 파이썬이다” 1부 내용임을 사전에 미리 밝힙니다!</p>
</blockquote>

<p>안녕하세요. 우선 알아두면 좋을만한 기본 개념부터 짚어보고자 합니다.</p>

<h1 id="기본-개념">기본 개념</h1>
<h2 id="파일">파일</h2>
<p>  파일은 데이터의 모임으로 보조기억장치에 저장된 것을 말한다(Naver 지식백과). 파일에는 2가지 중요한 속성이 있는데 바로 <strong>파일명(filename)</strong>과 <strong>경로(path)</strong>입니다.</p>
<blockquote>
  <ul>
    <li><strong>파일명</strong>은 말그대로 파일의 이름과 확장자를 통해 파일의 유형을 나타낸다.</li>
    <li><strong>경로</strong>는 쉽게 말해서 컴퓨터에 파일의 위치를 지정한다.</li>
  </ul>
</blockquote>

<p>예를 들어, mac을 기준으로 경로는 보통 다음과 같습니다.<br /><br />
<strong><em>/Users/mato/Documents/post.docx</em></strong> <br /><br />
  좌측 ‘/’는 루트 디렉토리로 모든 파일 및 디렉토리의 시작점입니다. 그 아래 Users는 모든 사용자의 홈 디렉토리가 포함되어 있으며, 모든 파일, 문서 및 리소스를 저장하는데 사용됩니다. (윈도우의 경우 루트 폴더는 C:\이며, 홈 디렉토리는 C:\Users입니다) 경로에 Documents가 폴더를 의미하며 마지막 post.docx가 파일입니다.
<br /></p>

<h2 id="작업-디렉토리working-directory">작업 디렉토리(Working Directory)</h2>
<p>  컴퓨터에 실행되는 모든 프로그램에는 현재 작업 디렉토리(current working directory, cwd)가 있습니다. 정확한 의미는 아니지만 저는 현재 프로그램이 데이터를 읽어오고 출력하는 위치라고 이해하고 있습니다.</p>

<h2 id="절대-경로-vs-상대경로">절대 경로 vs 상대경로</h2>
<p>파일 경로를 지정하는 방법에는 2가지 방법이 있습니다.</p>
<blockquote>
  <ul>
    <li><strong>절대경로</strong>: 항상 루트 폴더에서 시작되는 절대 경로 ex) /Users/mato/Documents/post.docx</li>
    <li><strong>상대경로</strong>: 프로그램에 현재 작업 디렉토리에 따라 달라지는 상대 경로 ex) ./post.docx</li>
  </ul>
</blockquote>

<p>  실무에서 저는 주로 절대 경로를 지정하여 사용하는 편이긴 합니다. 상대 경로를 사용해야 할 필요성이 아직까진 없었습니다.</p>

<h2 id="프로그램과-프로세스">프로그램과 프로세스</h2>
<p>  프로그램(Program)은 게임, 워드, 피피티, 웹 브라우저 등 실행할 수 있는 소프트웨어 응용프로그램(application)을 의미합니다. 프로세스(process)는 프로그램 실행 인스턴스입니다. 예를 들면, 만약 우리가 여러 개의 구글 웹 브라우저를 띄어 놓은 상황을 생각해봅시다. 이것은 하나의 웹 브라우저 프로그램의 프로세스가 여러개 동작중인 상태입니다. 또한 동일한 구글 웹 브라우저이더라도 각각 프로세스는 서로 분리된 상태로 유지된다는 것을 알 수 있습니다.</p>

<h2 id="명령행-인수">명령행 인수</h2>
<p>  <strong>명령행 인수(command line argument)</strong>는 명령어 뒤에 입력하는 텍스트입니다. 파이썬 함수 호출에 전달되는 인수처럼, 명령어에 특정한 옵션이나 추가적인 지침을 제공합니다. <strong>명령행 옵션(command line option)</strong>은 단일 문자 또는 짧은 단어로 이뤄진 명령행 인수이며 명령어에 대해 옵션을 제공한다.</p>

<h2 id="필수-명령어-모음">필수 명령어 모음</h2>
<p>  알아두면 좋은 자주 사용하는 명령어들입니다.</p>
<h3 id="1-와일드카드">1. 와일드카드</h3>
<p>  폴더나 파일명을 명령행 인수로 받는 경우, 와일드카드 문자인 *과 ?을 허용합니다. *는 개수와 무관하게 문자를 받아들이고, ?는 문자 하나만을 의미합니다. 예를 들어 “*.py”는 .py로 끝나는 모든 텍스트 집합을 의미합니다.</p>

<h3 id="2-cd-디렉토리-변경">2. cd: 디렉토리 변경</h3>
<p>  cd [대상 폴더]를 실행하면 작업 디렉토리가 대상 폴더로 변경됩니다.</p>

<h3 id="3-dir-ls-폴더-내용-열거">3. dir, ls: 폴더 내용 열거</h3>
<p>  윈도우는 dir, mac은 ls 명령어는 현재 작업 디렉토리에 위치한 모든 폴더와 파일을 표시합니다. <br />
ls 명령어의 옵션 중 -l과 -a는 유용한 옵션입니다. -l은 파일 크기, 권한, 수정 시점 등 여러 정보를 포함하는 목록을 출력합니다. -a는 숨겨진 파일을 포함한 모든 파일 목록을 출력합니다. 두 옵션은 -al로 하나로 합쳐 사용할 수 있습니다.
<br /><br />
  윈도우에서 dir /s를 실행하면 현재 작업 디렉토리의 폴더와 하위 폴더가 모두 표시됩니다.</p>

<h3 id="4-copy-cp-복사하기">4. copy, cp: 복사하기</h3>
<p>  copy(cp) [원본 파일 또는 폴더] [대상 폴더] 명령어를 통해 파일이나 폴더의 복제본을 생성할 수 있습니다.</p>

<h3 id="5-move-mv-이동하기">5. move, mv: 이동하기</h3>
<p>  mv [원본 파일 또는 폴더] [대상 폴더] 명령어를 통해 파일이나 폴더를 대상폴더로 이동시킬 수 있습니다. 윈도우는 mv 대신 move를 사용하면 됩니다.</p>

<h3 id="6-ren-mv-이름-변경하기">6. ren, mv: 이름 변경하기</h3>
<p>  mv [파일 또는 폴더] [새 이름] 명령어를 통해 파일이나 폴더의 이름을 바꿀 수 있다. 유의해야 할 점은 mac에서 mv 명령어는 파일 이동과 파일명 변경 모두 가능합니다. 윈도우는 ren을 사용하면 됩니다.</p>

<h3 id="7-del-rm-파일-삭제하기">7. del, rm: 파일 삭제하기</h3>
<p>  rm [파일] 명령어를 통해 파일을 삭제할 수 있습니다. rm 명령어는 -r 옵션을 활용해야지만 폴더를 삭제할 수 있습니다. 윈도우는 del 을 사용하면 되지만 차이점이 있습니다. del 명령어의 경우 하위 폴더는 그대로 둔 채 파일만 삭제합니다. 만약 원본 폴더를 삭제하려면 rd 명령어를 사용해야 합니다. 그리고 하위 폴더 내에 폴더를 삭제하려면 del /s 명령어를 사용해야 합니다.</p>

<h3 id="8-md-mkdir-폴더-생성하기">8. md, mkdir: 폴더 생성하기</h3>
<p>  mkdir [새 폴더] 명령어를 통해 새 폴더를 생성할 수 있습니다. 윈도우에서는 md 명령어를 사용합니다.</p>

<h3 id="9-rd-rmdir-폴더-삭제하기">9. rd, rmdir: 폴더 삭제하기</h3>
<p>  폴더를 삭제하기 위해서는 rmdir(mac)와 rd(윈도우) 명령어를 사용해야 합니다.</p>

<h3 id="10-where-which-프로그램-위치-검색">10. where, which: 프로그램 위치 검색</h3>
<p>  mac에서는 which [프로그램], 윈도우에서는 where [프로그램] 명령어를 통헤 프로그램의 위치를 알 수 있다.</p>

<h3 id="11-clear-cls-터미널-내용-삭제">11. clear, cls: 터미널 내용 삭제</h3>
<p>  지저분한 터미널 창을 지울 떄 활용하는 명령어입니다.</p>]]></content><author><name>박마토</name></author><category term="Python" /><category term="Python" /><category term="Coding" /><category term="Review" /><summary type="html"><![CDATA[이 포스트의 내용은 저자 Al Sweigart의 “클린 코드, 이제는 파이썬이다” 1부 내용임을 사전에 미리 밝힙니다!]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이 후기</title><link href="http://localhost:4000/data/SQL_LeetCode_Final/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이 후기" /><published>2023-10-03T00:00:00+09:00</published><updated>2023-10-04T02:44:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode_Final</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode_Final/"><![CDATA[<p>안녕하세요. Leetcode SQL50 모든 문제를 풀어보고 정리까지 마쳤습니다. <br /><br />
  실무에서 Qlik Sense로 데이터 모델을 개발할 때 유사 SQL을 사용하지만 보통에 SQL과는 차이가 있었고, 그 외에는 SQL을 다룰 일이 없었습니다. 따라서, 한 번쯤은 SQL을 다시 한 번 공부해야 겠다고 생각하고 있었고 LeetCode를 선택해 풀어봤습니다. LeetCode를 선택한 이유는 일단 문제 수가 50문제로 적당했고 파트별로 나눠져 있어서 연습하기에 좋았습니다. 문제들을 풀어보면서 <strong><em>SQL을 이렇게 활용해서 데이터를 이렇게 뽑아내는구나</em></strong>하는 감을 잡을 수 있다는 점이 좋았습니다.
<br /><br />
  또 하나 느꼈던 점은 큰 틀에서 내가 실무에서 쓰고 있는 언어와 SQL이 유사하다는 것도 느낄 수 있어서 좋았습니다. DA에게 SQL 활용 능력이 매우 중요시 되는데, SQL 활용 능력이 떨어지진 않을까 걱정과 조바심이 있었는데 직접 다뤄보니 크게 걱정할 것은 아니란 생각이 들었습니다. 비록 부족할 순 있지만 중요한 것은 이렇게 부족한 것들은 꾸준히 채워넣을 수 있어야 하는 것이겠죠.<br /><br />
  마지막으로 문제를 풀면서 놓쳤던 것들은 지속적으로 공부할 예정입니다. 일회성으로 끝나지 않고 꾸준히 SQL 지식을 채워놔야 겠습니다. 이렇게 하다보면 언젠가는 SQL이 필요할 때 도움이 될 것이라 믿습니다. 후기는 이렇게 간단하게 마치겠습니다!</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[안녕하세요. Leetcode SQL50 모든 문제를 풀어보고 정리까지 마쳤습니다.   실무에서 Qlik Sense로 데이터 모델을 개발할 때 유사 SQL을 사용하지만 보통에 SQL과는 차이가 있었고, 그 외에는 SQL을 다룰 일이 없었습니다. 따라서, 한 번쯤은 SQL을 다시 한 번 공부해야 겠다고 생각하고 있었고 LeetCode를 선택해 풀어봤습니다. LeetCode를 선택한 이유는 일단 문제 수가 50문제로 적당했고 파트별로 나눠져 있어서 연습하기에 좋았습니다. 문제들을 풀어보면서 SQL을 이렇게 활용해서 데이터를 이렇게 뽑아내는구나하는 감을 잡을 수 있다는 점이 좋았습니다.   또 하나 느꼈던 점은 큰 틀에서 내가 실무에서 쓰고 있는 언어와 SQL이 유사하다는 것도 느낄 수 있어서 좋았습니다. DA에게 SQL 활용 능력이 매우 중요시 되는데, SQL 활용 능력이 떨어지진 않을까 걱정과 조바심이 있었는데 직접 다뤄보니 크게 걱정할 것은 아니란 생각이 들었습니다. 비록 부족할 순 있지만 중요한 것은 이렇게 부족한 것들은 꾸준히 채워넣을 수 있어야 하는 것이겠죠.   마지막으로 문제를 풀면서 놓쳤던 것들은 지속적으로 공부할 예정입니다. 일회성으로 끝나지 않고 꾸준히 SQL 지식을 채워놔야 겠습니다. 이렇게 하다보면 언젠가는 SQL이 필요할 때 도움이 될 것이라 믿습니다. 후기는 이렇게 간단하게 마치겠습니다!]]></summary></entry><entry><title type="html">[파이썬] 클린 코드, 깨끗한 코드 작성하기!</title><link href="http://localhost:4000/python/clean_code1/" rel="alternate" type="text/html" title="[파이썬] 클린 코드, 깨끗한 코드 작성하기!" /><published>2023-10-03T00:00:00+09:00</published><updated>2023-10-04T07:15:00+09:00</updated><id>http://localhost:4000/python/clean_code1</id><content type="html" xml:base="http://localhost:4000/python/clean_code1/"><![CDATA[<p>안녕하세요. 실무를 하다보면 종종 파이썬이나 R을 활용해 업무를 해야할 때가 있습니다. 특별한 체계없이 프로그램이 돌아갈 수 있을 정도로만 코드를 작성하고 개발해 왔습니다. 하지만 이러한 주먹구구식 방식으로는 한계가 분명했습니다. 프로그램을 작성한 본인도 읽기 힘든 코드, 성능을 고려하지 않은 코드, 주석과 설명이 부족한 코드, 그 외에 좋지 못한 프로그램 개발 습관까지… 더 이상 이렇게는 안되겠다는 생각이 들었습니다. 이제는 아마추어가 아닌 전문가로서 다른 누가 보더라도 인정할 수 있는 코드를 작성하고 싶었습니다. 주 목적은 내 코드에서 나는 악취를 줄여 가독성을 높이고 오류를 줄이고 성능을 개선하여 생산성을 높이고자 함입니다.<br /><br />
  우선 어떤 코드가 좋은 코드인지를 알기 위해서 프로그래밍 관련 책을 읽기로 했습니다. 워낙 정보가 많아서 구글링, 유투브로도 찾을 수 있었겠지만 한 권의 책으로 정리되어 있는 책을 읽어보는 것이 코드 작성에 대한 전체적인 그림을 파악할 수 있다고 생각했습니다. 따라서, 서점에 가서 이것저것 살펴보다가 다음 책은 골랐습니다.</p>
<blockquote>
  <p>클린 코드 이제는 파이썬이다. author by Al Sweigart</p>
</blockquote>

<p><img src="/assets/image/클린코드 이제는 파이썬이다.jpeg" alt="image" />
<br />
  이 책을 읽어보고 따라하고 정리해가면서 파이썬 초보 데이터 분석가에서 전문적이고 우수한 파이썬 데이터 분석가로 진화하고자 합니다. 추가로 항상 빈약하다고 느끼던 컴퓨터 관련 전문 지식도 채울 수 있으면 정말 좋겠네요 ㅎㅎ 여하튼, 앞으로 책을 읽고 블로그 포스팅을 작성하면서 공부한 내용들을 익히고 기록하고자 합니다😊</p>]]></content><author><name>박마토</name></author><category term="Python" /><category term="Python" /><category term="Coding" /><category term="Review" /><summary type="html"><![CDATA[안녕하세요. 실무를 하다보면 종종 파이썬이나 R을 활용해 업무를 해야할 때가 있습니다. 특별한 체계없이 프로그램이 돌아갈 수 있을 정도로만 코드를 작성하고 개발해 왔습니다. 하지만 이러한 주먹구구식 방식으로는 한계가 분명했습니다. 프로그램을 작성한 본인도 읽기 힘든 코드, 성능을 고려하지 않은 코드, 주석과 설명이 부족한 코드, 그 외에 좋지 못한 프로그램 개발 습관까지… 더 이상 이렇게는 안되겠다는 생각이 들었습니다. 이제는 아마추어가 아닌 전문가로서 다른 누가 보더라도 인정할 수 있는 코드를 작성하고 싶었습니다. 주 목적은 내 코드에서 나는 악취를 줄여 가독성을 높이고 오류를 줄이고 성능을 개선하여 생산성을 높이고자 함입니다.   우선 어떤 코드가 좋은 코드인지를 알기 위해서 프로그래밍 관련 책을 읽기로 했습니다. 워낙 정보가 많아서 구글링, 유투브로도 찾을 수 있었겠지만 한 권의 책으로 정리되어 있는 책을 읽어보는 것이 코드 작성에 대한 전체적인 그림을 파악할 수 있다고 생각했습니다. 따라서, 서점에 가서 이것저것 살펴보다가 다음 책은 골랐습니다. 클린 코드 이제는 파이썬이다. author by Al Sweigart]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이: Advanced String Functions / RegEx / Clause</title><link href="http://localhost:4000/data/SQL_LeetCode11/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이: Advanced String Functions / RegEx / Clause" /><published>2023-10-01T00:00:00+09:00</published><updated>2023-10-02T06:00:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode11</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode11/"><![CDATA[<p>안녕하세요. Leetcode SQL50 마지막 파트인 Advanced String Functions/RegEx/Clause 파트입니다. <br /></p>

<h1 id="7-advanced-string-functions--regex--clause">7. Advanced String Functions / RegEx / Clause</h1>
<h2 id="71-1667-fix-names-in-a-table">7.1 1667. Fix Names in a Table</h2>

<p>  Text 데이터의 첫 번째 글자는 대문자로 하고 그 다음 문자부터 소문자로 고치는 문제입니다.</p>

<h3 id="711-solution">7.1.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">user_id</span><span class="p">,</span>
  <span class="n">Concat</span><span class="p">(</span><span class="k">Upper</span><span class="p">(</span><span class="k">Left</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="k">Lower</span><span class="p">(</span><span class="n">Substr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span> <span class="k">as</span> <span class="n">name</span>
<span class="k">From</span> <span class="n">Users</span>
<span class="k">ORDER</span> <span class="k">BY</span>
  <span class="n">user_id</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  텍스트를 첫 번째 글자와 나머지로 나눈 다음 각각 대문자로, 소문자로 바꿔준 다음 다시 하나의 텍스트로 합쳐주면 됩니다.</p>
<blockquote>
  <ul>
    <li>Concat(): 텍스트를 합치는 함수</li>
    <li>Upper(): 텍스트를 대문자로 바꿔주는 함수</li>
    <li>Lower(): 텍스트를 소문자로 바꿔주는 함수</li>
    <li>Left(a: text, b: int) : a(text)를 좌측 기준으로 b(int)까지 반환하는 함수</li>
    <li>Substr(a: text, b: int, c: int) : a(text)를 b(int)부터 c(int) 길이만큼 반환하는 함수</li>
  </ul>
</blockquote>

<h2 id="72-1527-patients-with-a-condition">7.2 1527. Patients With a Condition</h2>
<p>  진단명이 DIAB1으로 시작하는 환자를 골라내는 문자입니다. 정규표현식을 활용하여 골라내면 됩니다.</p>

<h3 id="721-solution">7.2.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">patient_id</span><span class="p">,</span>
  <span class="n">patient_name</span><span class="p">,</span>
  <span class="n">conditions</span>
<span class="k">FROM</span>
  <span class="n">Patients</span>
<span class="k">Where</span>
  <span class="n">conditions</span> <span class="k">Like</span> <span class="s1">'% DIAB1%'</span> <span class="k">or</span> <span class="n">conditions</span> <span class="k">Like</span> <span class="s1">'DIAB1%'</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  진단명이 ‘DIAB1’으로 시작하는 Case만 골라와야합니다. 다만, 예시 테이블을 보면 DIAB1 앞에 다른 병명이 붙은 것을 확인할 수 있습니다. 따라서, 모든 Case를 고려하여 다음과 같이 조건을 적용하면 됩니다.</p>

<h2 id="73-196-delete-duplicate-emails">7.3 196. Delete Duplicate Emails</h2>
<p>  중복된 이메일을 제거합니다. 만약 중복된 이메일이 있다면 id가 큰 값을 제거해줍니다.</p>

<h3 id="731-solution">7.3.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DELETE</span> <span class="n">p1</span>
  <span class="k">FROM</span> <span class="n">Person</span> <span class="n">p1</span><span class="p">,</span> <span class="n">Person</span> <span class="n">p2</span>
  <span class="k">WHERE</span> <span class="n">p1</span><span class="p">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">p2</span><span class="p">.</span><span class="n">email</span> <span class="k">and</span> <span class="n">p1</span><span class="p">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">id</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  Self Table Join을 활용하여 중복된 이메일 중 id가 큰 값을 제거해줍니다.</p>

<h2 id="74-176-second-highest-salary">7.4 176. Second Highest Salary</h2>
<p>  Employee 중 Salary가 두번째로 높은 사람을 찾는 문제입니다.</p>

<h3 id="741-solution">7.4.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="k">distinct</span> <span class="n">salary</span> <span class="k">FROM</span> <span class="n">Employee</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">salary</span> <span class="k">desc</span> <span class="k">limit</span> <span class="mi">1</span> <span class="k">offset</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">As</span> <span class="n">SecondHighestSalary</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  Subquery를 활용헤 Salary가 두번째로 높은 salary를 찾아줍니다. <code class="language-plaintext highlighter-rouge">offset 1</code>을 통해 첫 번째 위치가 아닌 두번째 위치에서 데이터를 가져오도록 합니다.</p>

<h2 id="75-1484-group-sold-products-by-the-date">7.5 1484. Group Sold Products By The Date</h2>
<p>  sell_date 별로 제품 판매 수와 판매 제품들을 구하는 문제입니다.</p>

<h3 id="751-solution">7.5.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">a</span><span class="p">.</span><span class="n">sell_date</span><span class="p">,</span>
  <span class="k">count</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">product</span><span class="p">)</span>  <span class="k">as</span> <span class="n">num_sold</span><span class="p">,</span>
  <span class="n">group_concat</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">product</span> <span class="k">order</span> <span class="k">by</span> <span class="n">a</span><span class="p">.</span><span class="n">product</span><span class="p">)</span> <span class="k">as</span> <span class="n">products</span>
<span class="k">FROM</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Activities</span><span class="p">)</span> <span class="n">a</span>
<span class="k">GROUP</span> <span class="k">BY</span>
  <span class="n">a</span><span class="p">.</span><span class="n">sell_date</span>
<span class="k">ORDER</span> <span class="k">BY</span>
  <span class="n">a</span><span class="p">.</span><span class="n">sell_date</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  특별히 어려운 문제는 아닙니다. <code class="language-plaintext highlighter-rouge">Group_Concat()</code> 함수를 활용해 그룹 별로 텍스트를 하나의 텍스트로 합쳐줍니다.</p>

<h2 id="76-1327-list-the-products-ordered-in-a-period">7.6 1327. List the Products Ordered in a Period</h2>
<p>  2020년 2월 최소 100개의 물건을 판매한 제품을 구하는 문제입니다.</p>

<h3 id="761-solution">7.6.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">a</span><span class="p">.</span><span class="n">product_name</span><span class="p">,</span>
  <span class="k">Sum</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">unit</span><span class="p">)</span> <span class="k">as</span> <span class="n">unit</span>
<span class="k">FROM</span>
  <span class="n">Products</span> <span class="n">a</span>
  <span class="k">Left</span> <span class="k">Join</span> <span class="n">Orders</span> <span class="n">b</span>
  <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">product_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">product_id</span>
<span class="k">Where</span>
  <span class="n">order_date</span> <span class="k">LIKE</span> <span class="nv">"2020-02%"</span>
<span class="k">Group</span> <span class="k">By</span>
  <span class="n">a</span><span class="p">.</span><span class="n">product_name</span>
<span class="k">HAViNG</span>
  <span class="k">Sum</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">unit</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">100</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  2020년 2월 데이터를 가져오기 위해 “2020-02%”를 주면 2020-02로 시작하는 데이터만 가져오게 됩니다.</p>

<h2 id="77-1517-find-users-with-valid-e-mails">7.7 1517. Find Users With Valid E-Mails</h2>
<p>  유효한 이메일 형식을 가진 데이터를 불러옵니다.</p>
<blockquote>
  <ol>
    <li>prefix name은 문자로 시작함</li>
    <li>도메인은 ‘@leetcode.com’이어야함</li>
  </ol>
</blockquote>

<h3 id="771-solution">7.7.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
  <span class="n">user_id</span><span class="p">,</span>
  <span class="n">name</span><span class="p">,</span>
  <span class="n">mail</span>
<span class="k">FROM</span>
  <span class="n">Users</span>
<span class="k">Where</span>
  <span class="n">mail</span> <span class="n">REGEXP</span>  <span class="s1">'^[A-Za-z][A-Za-z0-9_.-]*@leetcode[.]com'</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  정규표현식을 활용하기 위해서 <code class="language-plaintext highlighter-rouge">mail REGEXP  '^[A-Za-z][A-Za-z0-9_.-]*@leetcode[.]com'</code>과 같이 REGEXP 구문을 활용합니다.</p>
<blockquote>
  <ul>
    <li><strong>^</strong>은 다음 문자열로 시작하는 문자열을 찾습니다.</li>
    <li><strong>[]</strong>은 []안에 나열된 패턴의 문자열을 찾습니다.</li>
  </ul>
</blockquote>

<p>  따라서 위 구문을 풀어보면 <code class="language-plaintext highlighter-rouge">^[A-Za-z]</code>은 알파벳 문자로 시작하는 문자열을 찾습니다. 그 다음 <code class="language-plaintext highlighter-rouge">[A-Za-z0-9_.-]</code>은 []안에 나열된 알파벳, 숫자, _, ., -의 문자열 조합을 가진 패턴을 찾습니다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[안녕하세요. Leetcode SQL50 마지막 파트인 Advanced String Functions/RegEx/Clause 파트입니다.]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이: Subqueries</title><link href="http://localhost:4000/data/SQL_LeetCode10/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이: Subqueries" /><published>2023-10-01T00:00:00+09:00</published><updated>2023-10-02T01:40:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode10</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode10/"><![CDATA[<p>안녕하세요. 이번 문제부터는 Subquery 파트입니다. <br />
 원하는 데이터를 추출하기 위해서는 Subquery를 능숙하게 다룰 줄 알아야 합니다. Subquery는 말 그대로 Query속 query입니다. 좀 더 자세하게 얘기하면 <strong><em>SELECT 문 안에 또 다른 SELECT 문</em></strong>을 의미합니다. Main query 안에서 괄호로 둘러쌓인 SELECT문입니다. Subquery는 어떤 값을 반환하는 곳에도 쓰이고, 테이블로 사용되거나 조건은 불러오는데 사용되기도 합니다.</p>

<h1 id="6-subqueries">6. Subqueries</h1>
<h2 id="61-1978-employees-whose-manager-left-the-company">6.1 1978. Employees Whose Manager Left the Company</h2>

<p>  이 문제는 $30000 이하의 salary를 받고 manager가 직원 중 존재하지 않는(퇴사한) 직원을 구하는 문제입니다.</p>

<h3 id="611-solution">6.1.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">employee_id</span>
<span class="k">FROM</span>
    <span class="n">Employees</span>
<span class="k">Where</span>
    <span class="n">salary</span> <span class="o">&lt;</span> <span class="mi">30000</span>
    <span class="k">and</span> <span class="n">manager_id</span> <span class="k">Not</span> <span class="k">in</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">employee_id</span> <span class="k">FROM</span> <span class="n">Employees</span><span class="p">)</span>
<span class="k">Order</span> <span class="k">By</span>
    <span class="n">employee_id</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  원하는 답을 구하기 위해서는 Where 절에 두 가지 조건이 필요합니다. 하나는 <strong>$30000 이하</strong>와 <strong>manager가 퇴사한</strong> 조건입니다. 2번째 조건을 만족시키기 위해서는 manager_id가 employer_id에 존재하는지 판변해야 합니다. Subquery를 사용해 Employee 테이블에서 employer_id를 가져온 다음, manager_id가 subquery를 통해 불러온 employer_id에 없는 지 <code class="language-plaintext highlighter-rouge">Not in ()</code> 구문을 활용해 필터링하면 manager가 퇴사한 employer를 필터링 할 수 있습니다.</p>

<h2 id="62-626-exchange-seats">6.2 626. Exchange Seats</h2>
<p>  학생들의 id가 연속하는 두명의 학생끼리 자리를 swap하는 문제이다. 마지막 id의 학생이 혼자일 경우 swap하지 않는다.</p>

<h3 id="621-solution">6.2.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">rank</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="k">order</span> <span class="k">by</span> <span class="n">group_n</span> <span class="k">asc</span><span class="p">,</span> <span class="n">id</span> <span class="k">desc</span><span class="p">)</span> <span class="k">as</span> <span class="n">id</span><span class="p">,</span>
    <span class="n">student</span>
<span class="k">FROM</span>
<span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">id</span><span class="p">,</span>
        <span class="n">student</span><span class="p">,</span>
        <span class="n">Round</span><span class="p">(</span><span class="n">id</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>   <span class="k">as</span> <span class="n">group_n</span>
    <span class="k">FROM</span>
    <span class="n">Seat</span>
<span class="p">)</span> <span class="n">a</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  문제를 풀기 위해서 2가지 step으로 나눠서 문제를 풀었다. 첫 번째는 id가 연속하는 2명의 학생끼리 그룹을 만들어 준 다음, 두번째로 두명씩 짝지어진 그룹 내에서 학생끼리 Swap을 해줬다. 단계별로 설명해보면 다음과 같다. <br />
  학생들을 두 명씩 그룹짓기 위해 학생들의 id를 2로 나눠준 다음 그 몫을 구했다. 예를 들면, 학생의 id가 1과 2인 학생들의 id를 2로 나눈 값을 반올림하면 1, 2와 3인 학생들의 id를 2로 나눈 값을 반올림하면 2이므로 2명씩 순차적으로 짝지어지게 된다. 이렇게 두 명씩 그룹화 할 수 있다. 이런 방식으로 그룹화를 하고 Subquery로 불러온다.<br />
  다음으로는 그룹 내에 학생들의 id의 순서를 바꿔주면 됩니다. 순서를 바꿔주기 위해서 window function 중 하나인 rank 함수를 활용했습니다. Order by 기능을 이용해 group_n을 오름차순 순으로, 그 다음 기존 id를 내림차순 순으로 정렬해 rank를 부여하면 자연스럽게 순서가 바뀐 id를 갖게 됩니다.</p>

<h2 id="63-1341-movie-rating">6.3 1341. Movie Rating</h2>
<p>  두 가지 답을 찾아야 하는 문제입니다.</p>
<blockquote>
  <ol>
    <li>가장 높은 평점을 부여한 사람</li>
    <li>2020년 2월 가장 높은 평균 평점을 받은 영화</li>
  </ol>
</blockquote>

<h3 id="631-solution">6.3.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">SELECT</span>
    <span class="n">u</span><span class="p">.</span><span class="n">name</span> <span class="k">As</span> <span class="n">results</span> 
<span class="k">FROM</span>
    <span class="n">MovieRating</span> <span class="k">As</span> <span class="n">m</span><span class="p">,</span> <span class="n">Users</span> <span class="k">as</span> <span class="n">u</span> 
<span class="k">WHERE</span>
    <span class="n">u</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">user_id</span> 
<span class="k">Group</span> <span class="k">By</span> 
    <span class="n">m</span><span class="p">.</span><span class="n">user_id</span> 
<span class="k">Order</span> <span class="k">by</span> 
    <span class="k">count</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span> <span class="k">desc</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">name</span> 
<span class="k">LIMIT</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="p">(</span><span class="k">SELECT</span> 
    <span class="n">m</span><span class="p">.</span><span class="n">title</span> <span class="k">As</span> <span class="n">results</span>
<span class="k">FROM</span>
    <span class="n">MovieRating</span> <span class="k">as</span> <span class="n">r</span><span class="p">,</span> <span class="n">Movies</span> <span class="k">as</span> <span class="n">m</span>
<span class="k">WHERE</span>
    <span class="n">m</span><span class="p">.</span><span class="n">movie_id</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">movie_id</span> <span class="k">and</span> <span class="n">r</span><span class="p">.</span><span class="n">created_at</span> <span class="k">like</span> <span class="nv">"2020-02-%"</span>
<span class="k">Group</span> <span class="k">By</span> 
    <span class="n">r</span><span class="p">.</span><span class="n">movie_id</span> 
<span class="k">Order</span> <span class="k">by</span> 
    <span class="k">avg</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">rating</span><span class="p">)</span> <span class="k">desc</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">title</span> 
<span class="k">LIMIT</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>
<p>  Subquery를 사용하지 않고도 간단하게 풀리는 문제입니다. 각각 답을 구한 후, <code class="language-plaintext highlighter-rouge">UNION ALL</code>을 활용해 테이블을 합쳐줍니다.</p>

<h2 id="64-1321-restaurant-growth">6.4 1321. Restaurant Growth</h2>
<p>  레스토랑에서 매일 지난 7일동안 평균 매출액을 구하는 문제입니다. 일별로 지난 7일동안 평균 매출액을 구해야 하기 때문에 window function을 활용했습니다.</p>

<h3 id="641-solution">6.4.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="k">c</span><span class="p">.</span><span class="n">visited_on</span><span class="p">,</span>
    <span class="k">c</span><span class="p">.</span><span class="n">amount</span><span class="p">,</span>
    <span class="n">round</span><span class="p">(</span><span class="k">c</span><span class="p">.</span><span class="n">amount</span> <span class="o">/</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="k">as</span> <span class="n">average_amount</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="k">DISTINCT</span>
        <span class="n">visited_on</span><span class="p">,</span>
        <span class="k">SUM</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="n">Over</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">visited_on</span> <span class="k">RANGE</span> <span class="k">BETWEEN</span> <span class="n">INTERVAL</span> <span class="mi">6</span> <span class="k">DAY</span> <span class="k">PRECEDING</span> <span class="k">AND</span> <span class="k">CURRENT</span> <span class="k">ROW</span><span class="p">)</span> <span class="k">as</span> <span class="n">amount</span><span class="p">,</span>
        <span class="k">MIN</span><span class="p">(</span><span class="n">visited_on</span><span class="p">)</span> <span class="n">OVER</span> <span class="p">()</span> <span class="k">as</span> <span class="mi">1</span><span class="n">st_date</span>
    <span class="k">FROM</span>
        <span class="n">Customer</span><span class="p">)</span> <span class="k">c</span>
<span class="k">WHERE</span>
    <span class="k">c</span><span class="p">.</span><span class="n">visited_on</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">&gt;=</span> <span class="k">c</span><span class="p">.</span><span class="mi">1</span><span class="n">st_date</span>
<span class="p">;</span>

</code></pre></div></div>
<p>  지난 7일간 평균 매출액을 구하기 위해 우선 지난 7일간 매출액 합계를 구하기 위해 window function을 활용했습니다. 지난 7일간을 어떻게 구현하면 될까요? 다음과 같은 구문을 활용했습니다. <br /></p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Sum(amount) Over (ORDER BY visited_on RANGE BETWEEN INTERVAL 6 DAY PRECEDING AND CURRENT ROW)</code></p>
</blockquote>

<p>  특정 구간을 구하기 위해서 보통 <code class="language-plaintext highlighter-rouge">BETWEEN A AND B</code>와 같이 BETWEEN 구문을 활용합니다. visited_on(방문일)을 기준으로 정렬하고, A에 <code class="language-plaintext highlighter-rouge">INTERVAL 6 DAY PRECEDING</code>는 현재로부터 6일전을 의미하고 B에 <code class="language-plaintext highlighter-rouge">CURRENT</code>는 현재를 의미합니다. 따라서 visited_on을 기준으로 6일 전 ~ 오늘까지를 의미하게 되며 그 기간동안의 합계를 구하는 구문이 됩니다. 복잡해 보일 수 있지만 하나하나 뜯어보면 어렵지 않게 이해할 수 있습니다.<br />
  그 다음 ‘1st_date’를 구해줍니다. 이는 visited_on을 기준으로 과거 6일치의 데이터가 없는 케이스를 제거해주기 위함입니다. 최종 테이블을 구현하기 위한 테이블 구문을 subquery로 미리 테이블을 불러온 다음 마지막으로 평균 매출액을 구하면 쉽게 최종 테이블을 구할 수 있습니다.</p>

<h2 id="65-602-friend-requests-ii-who-has-the-most-friends">6.5 602. Friend Requests II: Who Has the Most Friends</h2>
<p>  가장 많은 친구를 가진 사람과 가장 많은 사람과 친구인 사람을 구하는 문제입니다.</p>

<h3 id="651-solution">6.5.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
    <span class="k">Sum</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">num</span><span class="p">)</span>    <span class="k">as</span> <span class="n">num</span>
<span class="k">FROM</span>
<span class="p">((</span><span class="k">SELECT</span>
    <span class="n">requester_id</span>    <span class="k">as</span> <span class="n">id</span><span class="p">,</span>
    <span class="k">count</span><span class="p">(</span><span class="n">accepter_id</span><span class="p">)</span>  <span class="k">as</span> <span class="n">num</span>
<span class="k">FROM</span>
    <span class="n">RequestAccepted</span>
<span class="k">GROUP</span> <span class="k">BY</span>
    <span class="n">requester_id</span>
<span class="p">)</span> <span class="k">UNION</span> <span class="k">ALL</span>
<span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">accepter_id</span> <span class="k">as</span> <span class="n">id</span><span class="p">,</span>
        <span class="k">count</span><span class="p">(</span><span class="n">requester_id</span><span class="p">)</span> <span class="k">as</span> <span class="n">num</span>
    <span class="k">FROM</span>
        <span class="n">RequestAccepted</span>
    <span class="k">GROUP</span> <span class="k">BY</span>
        <span class="n">accepter_id</span>
<span class="p">))</span> <span class="n">a</span>
<span class="k">GROUP</span> <span class="k">BY</span> 
    <span class="n">a</span><span class="p">.</span><span class="n">id</span>
<span class="k">Order</span> <span class="k">By</span>
    <span class="n">num</span> <span class="k">desc</span>
<span class="k">LIMIT</span> <span class="mi">1</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  Subquery안에 UNION ALL 구문을 활용해 테이블을 불러왔습니다. 하나하나 뜯어보겠습니다.<br />
  첫 번째 테이블을 보면, requerster_id별로 accepter_id 수를 집계했습니다. 두 번째 테이블은 반대로 accepter_id별로 requester_id 수를 집계했습니다. 각각 수를 집계한 이유는 요청자와 수락자 한 쌍이 모두 친구이기 때문입니다. 예를 들어, 1번이 2번에게 요청한 경우 1과 2는 친구이고, 3번이 1번에게 친구를 요청한 경우도 1과 3은 친구입니다. 따라서 1번에게는 2, 3의 친구 즉 2명의 친구가 있는 것입니다. 따라서 모든 id별로 각각 수를 집계한 것입니다.
<br />
  id별로 requseter_id, accepter_id를 모두 집계한 다음 id별로 합계를 구한다면 총 친구 수를 구할 수 있습니다. 여기서 친구 수를 내림차순으로 정렬한 다음 가장 최상단에 값만 불러오면 가장 많은 친구를 가진 id를 찾을 수 있습니다.</p>

<h2 id="66-585-investments-in-2016">6.6 585. Investments in 2016</h2>
<p>  다음 조건을 만족하는 2016년 총 투자액을 구하는 문제입니다. 조건은 다음과 같습니다.</p>
<blockquote>
  <ol>
    <li>2개 이상의 정책의 tiv_2015가 동일해야함</li>
    <li>다른 policyholder와 지역이 겹치지 않아야 함</li>
  </ol>
</blockquote>

<h3 id="661-solution">6.6.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">Round</span><span class="p">(</span><span class="k">Sum</span><span class="p">(</span><span class="n">tiv_2016</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="k">as</span> <span class="n">tiv_2016</span>
<span class="k">FROM</span>
    <span class="n">Insurance</span> <span class="n">i</span>
    <span class="k">INNER</span> <span class="k">JOIN</span> <span class="p">(</span>
        <span class="k">SELECT</span>
            <span class="n">concat</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span> <span class="k">as</span> <span class="n">t</span>
        <span class="k">FROM</span>
            <span class="n">Insurance</span>
        <span class="k">GROUP</span> <span class="k">BY</span>
            <span class="n">t</span>
        <span class="k">HAVING</span>
            <span class="k">count</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">i2</span>
    <span class="k">On</span> <span class="n">concat</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lon</span><span class="p">)</span> <span class="o">=</span> <span class="n">i2</span><span class="p">.</span><span class="n">t</span>
<span class="k">WHERE</span>
    <span class="n">tiv_2015</span> <span class="k">in</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">tiv_2015</span> <span class="k">FROM</span> <span class="n">Insurance</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">tiv_2015</span> <span class="k">Having</span> <span class="k">count</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  이 문제를 풀기 위해 2개의 subquery를 활용했습니다. 우선 INNER JOIN 절에 있는 subquery부터 보겠습니다.<br />
  pid별로 지역이 겹치지 않는 pid만 남기기 위해 INNER JOIN을 수행한 사례입니다. lat과 lon을 concat(string을 결합)하여 t라는 컬럼을 생성하고 HAVING절을 통해 t가 1개인 경우만 불러옵니다. 이 테이블을 Insurance 테이블과 <code class="language-plaintext highlighter-rouge">On concat(i.lat, i.lon) = i2.t</code> 키를 활용해 결합한다면 i2 테이블의 t의 수가 1인 케이스만 결합되기에 지역이 겹치는 pid는 모두 제외되게 됩니다.
<br />
  그 다음 tiv_2015가 두 개 이상 동일한 케이스를 불러오기 위해 WHERE 절에도 subquery를 활용해줍니다. subquery를 활용해 tiv_2015별로 pid 수를 집계한다음 그 수가 2개 이상인 경우만 불러온 후, <code class="language-plaintext highlighter-rouge">tiv_2015 in ()</code>을 활용해 조건을 주면 원하는 최종 테이블을 추출할 수 있습니다.</p>

<h2 id="67-185-department-top-three-salaries">6.7 185. Department Top Three Salaries</h2>
<p>  부서 별로 연봉이 가장 높은 3명의 사람을 구하는 문제입니다.</p>

<h3 id="671-solution">6.7.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">Department</span><span class="p">,</span>
    <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">Employee</span><span class="p">,</span>
    <span class="n">a</span><span class="p">.</span><span class="n">salary</span> <span class="k">as</span> <span class="n">Salary</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span> 
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dense_rank</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">Partition</span> <span class="k">By</span> <span class="n">departmentId</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">salary</span> <span class="k">desc</span><span class="p">)</span> <span class="k">as</span> <span class="n">salary_rank</span>
    <span class="k">FROM</span>
        <span class="n">Employee</span>
    <span class="p">)</span> <span class="n">a</span>
    <span class="k">Left</span> <span class="k">Join</span> <span class="n">Department</span> <span class="n">b</span>
    <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">departmentId</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span>
<span class="k">Where</span>
    <span class="n">a</span><span class="p">.</span><span class="n">salary_rank</span> <span class="o">&lt;=</span> <span class="mi">3</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  어렵지 않게 푼 문제입니다. Window function 중 하나인 dense_rank() 함수를 활용해 부서별로 salary가 높은 순서를 구합니다. dense_rank는 중복된 것들은 하나로 처리하여 순서를 부여합니다.(2등이 2명일 경우 다음 등수를 4로 가지 않고 3으로 부여) 그 다음 Join 절을 이용해 부서명을 붙여주고 salary_rank가 3 이하인 경우를 구해주면 부서별로 salary가 높은 3명을 구할 수 있습니다!</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[안녕하세요. 이번 문제부터는 Subquery 파트입니다.  원하는 데이터를 추출하기 위해서는 Subquery를 능숙하게 다룰 줄 알아야 합니다. Subquery는 말 그대로 Query속 query입니다. 좀 더 자세하게 얘기하면 SELECT 문 안에 또 다른 SELECT 문을 의미합니다. Main query 안에서 괄호로 둘러쌓인 SELECT문입니다. Subquery는 어떤 값을 반환하는 곳에도 쓰이고, 테이블로 사용되거나 조건은 불러오는데 사용되기도 합니다.]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이: Advanced Select and Joins(2/2)</title><link href="http://localhost:4000/data/SQL_LeetCode9/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이: Advanced Select and Joins(2/2)" /><published>2023-09-18T00:00:00+09:00</published><updated>2023-09-19T06:30:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode9</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode9/"><![CDATA[<p>  안녕하세요. 바로 이어가겠습니다!</p>

<h1 id="5-advanced-and-select-joins">5. Advanced and Select Joins</h1>
<h2 id="54-180-consecutive-numbers">5.4 180. Consecutive Numbers</h2>

<p>  이 문제는 적어도 3번 이상 반복되는 숫자를 구하는 문제입니다. 다양한 방법이 있겠지만 저는 Window 함수를 사용해 풀었습니다.</p>

<h3 id="541-solution">5.4.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">Distinct</span>
    <span class="n">a</span><span class="p">.</span><span class="n">num</span>  <span class="k">as</span> <span class="n">ConsecutiveNums</span>
<span class="k">FROM</span>
<span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">id</span><span class="p">,</span>
        <span class="n">num</span><span class="p">,</span>
        <span class="n">lag</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="n">over</span><span class="p">()</span>   <span class="k">as</span> <span class="n">num_1</span><span class="p">,</span>
        <span class="n">lag</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="n">over</span><span class="p">()</span>   <span class="k">as</span> <span class="n">num_2</span>
    <span class="k">FROM</span> <span class="n">Logs</span>
<span class="p">)</span> <span class="n">a</span>
<span class="k">Where</span> <span class="n">a</span><span class="p">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">num_1</span> <span class="k">and</span> <span class="n">a</span><span class="p">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">num_2</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  Window 함수 중에서 lead와 lag 중 원하는 것을 활용하면 됩니다. lag 혹은 lead만 2번 써도 되고 두 함수 모두 사용해도 됩니다. <code class="language-plaintext highlighter-rouge">lag(num, 1) over()</code>은 num 컬럼에 바로 다음 순서의 데이터를 불러오고, <code class="language-plaintext highlighter-rouge">lag(num 2) over</code>은 그 다음 2번째 데이터를 불러옵니다. 그렇게 테이블을 만든 다음에 num, num_1과 num_2가 모두 데이터만 불러오면 3번 반복되는 숫자를 가져올 수 있습니다.</p>

<h3 id="542-good-to-know---window-function">5.4.2 Good to Know - Window Function</h3>
<p>  Window 함수는 group by 없이 집계함수를 쓰거나 순위, 행간의 데이터 전처리를 수행할 때 많이 사용됩니다. Window 함수에 대한 기본 양식은 다음과 같습니다.</p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Funcion(Column) over (Partition By A Order By B)</code></p>
</blockquote>

<p>  window로 활용할 수 있는 함수는 기본적인 aggregate function(sum, avg, count 등)과 nonaggregate function(rank, lead, lag 등)이 있습니다. 그리고 over 안에 Partition By는 Group By와 유사합니다. 예를 들어, 그룹 별 집계할 때 쓰이기도 하고, 그룹 내 Ranking을 찾을 때에도 쓰입니다. Order By는 말 그대로 정렬하는 기능이며 Order By와 동일합니다. <br />
  Window 함수는 내용이 많아 여기 다 적긴 어렵고 따로 자세하게 적을 예정입니다!</p>

<h2 id="55-1164-product-price-at-a-given-date">5.5 1164. Product Price at a Given Date</h2>
<p>  특정 시점(2019-08-16)에 모든 제품의 가격을 구하는 문제입니다. 하나 특이한 점은 Products 테이블에는 new_price 정보와 변경 날짜만 담겨있습니다. 변경 이전 금액은 모두 10으로 동일하다고 합니다. 따라서 케이스를 다음과 같이 2가지로 나눠야 합니다.</p>
<blockquote>
  <ol>
    <li>2019-08-16 이전에 가격이 바뀐 경우</li>
    <li>2019-08-16 이후에 가격이 바뀐 경우</li>
  </ol>
</blockquote>

<h3 id="551-solution">5.5.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">product_id</span><span class="p">,</span>
    <span class="n">new_price</span> <span class="k">as</span> <span class="n">price</span>
<span class="k">FROM</span>
    <span class="n">Products</span>
<span class="k">Where</span> 
    <span class="p">(</span><span class="n">product_id</span><span class="p">,</span> <span class="n">change_date</span><span class="p">)</span> <span class="k">in</span> <span class="p">(</span><span class="k">Select</span> <span class="n">product_id</span><span class="p">,</span> <span class="k">max</span><span class="p">(</span><span class="n">change_date</span><span class="p">)</span> <span class="k">From</span> <span class="n">Products</span> <span class="k">Where</span> <span class="n">change_date</span> <span class="o">&lt;=</span> <span class="s1">'2019-08-16'</span> <span class="k">Group</span> <span class="k">By</span> <span class="n">product_id</span><span class="p">)</span>
<span class="k">UNION</span>
<span class="k">SELECT</span>
    <span class="n">product_id</span><span class="p">,</span>
    <span class="mi">10</span>  <span class="k">as</span> <span class="n">price</span>
<span class="k">FROM</span>
    <span class="n">Products</span>
<span class="k">Group</span> <span class="k">By</span>
    <span class="n">product_id</span>
<span class="k">Having</span>
    <span class="k">Min</span><span class="p">(</span><span class="n">change_date</span><span class="p">)</span> <span class="o">&gt;</span> <span class="s1">'2019-08-16'</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  전 위 두가지 케이스 각각 해당하는 query를 질의하여 테이블을 불러오고 UNION을 활용하는 것으로 문제를 해결했습니다. 한 번에 처리하는 방법이 떠오르지 않더라구요. <br />
  첫 번째 케이스를 처리하기 위해서 변경 날짜가 2019-08-16 이전에 제품별로 가장 최근 가격 변경 날짜의 케이스만 불러왔습니다. 이 경우에는 2019-08-16 이전에 제품의 가격 변경이 있었고 new-price가 곧 price가 됩니다. <br />
  두 번째 케이스를 처리하기 위해서는 제품별로 첫 가격 변경 날짜가 2019-08-16 이후인 케이스만 불러오면 됩니다. 첫 가격 변경 날짜가 2019-08-16 이후인 케이스는 2019-08-16에는 price가 10이기 때문에, price 값을 10으로 설정해주면 됩니다.</p>

<h2 id="56-1204-last-person-to-fit-in-the-bus">5.6 1204. Last Person to Fit in the Bus</h2>
<p>  버스 탑승객의 총 무게가 1000km에 제한이 있고, 대기자들 중 가장 마지막으로 탑승하는 사람을 찾으면 되는 문제입니다. 저는 탑승대기자들을 순서대로 정렬한 후, 몸무게를 누적합해서 1000kg limit에 걸리는 사람을 찾았습니다.</p>

<h3 id="531-solution">5.3.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">person_name</span>
<span class="k">FROM</span>
<span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">turn</span><span class="p">,</span>
        <span class="n">person_id</span><span class="p">,</span>
        <span class="n">person_name</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">,</span>
        <span class="k">SUM</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="n">over</span> <span class="p">(</span><span class="k">order</span> <span class="k">by</span> <span class="n">turn</span><span class="p">)</span>    <span class="k">as</span> <span class="n">total_weight</span>
    <span class="k">FROM</span>
        <span class="n">Queue</span>
    <span class="k">ORDER</span> <span class="k">By</span> 
        <span class="n">turn</span> <span class="k">asc</span>
<span class="p">)</span> <span class="n">a</span>
<span class="k">WHERE</span> 
    <span class="n">total_weight</span> <span class="o">&lt;=</span> <span class="mi">1000</span>
<span class="k">ORDER</span> <span class="k">By</span> 
    <span class="n">total_weight</span> <span class="k">desc</span>
<span class="k">LIMIT</span> <span class="mi">1</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  누적합을 구하기 위해서 위 5.4 케이스처럼 window 함수를 활용했습니다. Partition by 는 필요없으니 쓰지 않고 순서대로 정렬(order by turn)해준 다음 합계를 구하면 순서대로 누적합을 구할 수 있습니다. 누적합을 구했다면 이제 1000kg가 넘기 직전 마지막 사람을 구하면 됩니다. 저는 total_weight를 내림차순하여 가장 윗(limit 1)사람을 불러왔습니다.</p>

<h2 id="56-1907-count-salary-categories">5.6 1907. Count Salary Categories</h2>
<p>  income을 category화 하는 문제입니다.</p>

<h3 id="531-solution-1">5.3.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span>
<span class="k">SELECT</span>
    <span class="s1">'Low Salary'</span>    <span class="k">as</span> <span class="n">category</span><span class="p">,</span>
    <span class="k">Sum</span><span class="p">(</span><span class="n">income</span> <span class="o">&lt;</span> <span class="mi">20000</span><span class="p">)</span>    <span class="k">as</span>  <span class="n">accounts_count</span>
<span class="k">FROM</span>
    <span class="n">Accounts</span>
<span class="p">)</span> <span class="k">UNION</span>
<span class="p">(</span>
<span class="k">SELECT</span>
    <span class="s1">'Average Salary'</span>    <span class="k">as</span> <span class="n">category</span><span class="p">,</span>
    <span class="k">Sum</span><span class="p">(</span><span class="n">income</span> <span class="k">Between</span> <span class="mi">20000</span> <span class="k">and</span> <span class="mi">50000</span><span class="p">)</span> <span class="k">as</span> <span class="n">accounts_count</span>
<span class="k">FROM</span>
    <span class="n">Accounts</span>
<span class="p">)</span> <span class="k">UNION</span>
<span class="p">(</span>
<span class="k">SELECT</span>
    <span class="s1">'High Salary'</span>   <span class="k">as</span> <span class="n">category</span><span class="p">,</span>
    <span class="k">Sum</span><span class="p">(</span><span class="n">income</span> <span class="o">&gt;</span> <span class="mi">50000</span><span class="p">)</span>    <span class="k">as</span> <span class="n">accounts_count</span>
<span class="k">FROM</span>
    <span class="n">Accounts</span>
<span class="p">)</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  union을 활용해 Low, Average, High Salary 별로 query를 질의한 다음 합쳤습니다. 보통 다수의 프로그래밍 언어에서 bool 형태의 데이터 타입은 int 타입과 매칭되는데 True -&gt; 1로, False -&gt; 0으로 치환됩니다. 따라서 Sum(조건 문)의 경우, 조건을 만족하는 수를 구하는 쿼리가 됩니다. <br />
  처음에 Union을 쓰지 않고 CASE 구문을 활용해서 그룹 별로 category화 한 다음 Count하여 집계하려 했는데 문제가 풀리지 않았습니다. 왜냐하면 Average 그룹에 해당하는 데이터가 없었기에 Count로 집계한 경우 Null로 제외되기 때문입니다. 단순히 문제를 푸는 것을 떠나서 실상황에서 데이터를 추출할 때 0값인 경우도 필요한지 아닌지에 따라 적절한 Query를 사용해야 합니다. 딱 보면 한눈에 결과가 그려지는 실력이면 좋겠지만, 이렇게 해보면서 경험을 쌓아가고 공부하는 수밖에 없을 것 같네요. 하다보면 언젠가는 고수의 경지에 오를 수 있겠죠!ㅎㅎ</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[  안녕하세요. 바로 이어가겠습니다!]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이: Advanced Select and Joins(1/2)</title><link href="http://localhost:4000/data/SQL_LeetCode8/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이: Advanced Select and Joins(1/2)" /><published>2023-09-16T00:00:00+09:00</published><updated>2023-09-13T06:00:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode8</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode8/"><![CDATA[<p>  안녕하세요. 이번 Section은 Advanced Select and Joins입니다.</p>

<h1 id="5-advanced-and-select-joins">5. Advanced and Select Joins</h1>
<h2 id="51-1731-the-number-of-employees-which-report-to-each-employee">5.1 1731. The Number of Employees Which Report to Each Employee</h2>
<p>  모든 manager에 이름과 다이렉트로 보고하는 employee에 수, 그리고 employee의 평균 나이를 구하는 문제입니다.
단계를 나눠보면,</p>
<blockquote>
  <ol>
    <li>manager 알아내기</li>
    <li>manager에게 리포트하는 employee 수 집계하기</li>
    <li>manager에게 리포트하는 employee의 평균 나이 집계하기</li>
  </ol>
</blockquote>

<p>순으로 정리하면 될 것 같습니다.</p>

<h3 id="511-solution">5.1.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">employee_id</span>             <span class="k">as</span> <span class="n">employee_id</span><span class="p">,</span>
    <span class="n">a</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
    <span class="k">count</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">employee_id</span><span class="p">)</span>      <span class="k">as</span> <span class="n">reports_count</span><span class="p">,</span>
    <span class="n">round</span><span class="p">(</span><span class="k">avg</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">age</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>      <span class="k">as</span> <span class="n">average_age</span>
<span class="k">FROM</span>
    <span class="n">Employees</span> <span class="n">a</span>
<span class="k">INNER</span> <span class="k">Join</span> <span class="n">Employees</span> <span class="n">b</span>
    <span class="k">on</span> <span class="n">a</span><span class="p">.</span><span class="n">employee_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">reports_to</span>
<span class="k">GROUP</span> <span class="k">BY</span>
    <span class="n">a</span><span class="p">.</span><span class="n">employee_id</span>
<span class="k">ORDER</span> <span class="k">By</span>
    <span class="n">a</span><span class="p">.</span><span class="n">employee_id</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  manager를 찾아내기 위해 Self Table Join을 활용했습니다. Join Key를 a 테이블에서는 employee_i와 b 테이블에서 reports_to로 설정해 줍니다. 게다가 INNER Join을 했기 때문에 a.employee_id와 b.reports_to가 두 테이블에 모두 있는 케이스만 Join이 됩니다. 그려보면 a 테이블에는 매니저만 남고, b 테이블이 employee가 join되는 그림입니다. 따라서 최종 테이블에 manager만 남게 됩니다.<br />
  그 다음부터는 집계함수를 이용하여 집계하면 문제는 풀립니다!</p>

<h2 id="52-1789-primary-department-for-each-employee">5.2 1789. Primary Department for Each Employee</h2>
<p>  Employee 별로 primary department를 구하는 문제입니다. 이 문제에서 고려해야 할 점은 employee가 속한 department가 꼭 1개가 아니라 1개 이상인 경우가 있다는 것입니다.</p>

<h3 id="521-solution">5.2.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">employee_id</span><span class="p">,</span>
    <span class="n">department_id</span>
<span class="k">FROM</span> 
    <span class="n">Employee</span>
<span class="k">WHERE</span>
    <span class="n">primary_flag</span> <span class="o">=</span> <span class="s1">'Y'</span>
<span class="k">UNION</span>
<span class="k">SELECT</span>
    <span class="n">employee_id</span><span class="p">,</span>
    <span class="n">department_id</span>
<span class="k">FROM</span>
    <span class="n">Employee</span>
<span class="k">Where</span>
    <span class="n">employee_id</span> <span class="k">in</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">employee_id</span> <span class="k">FROM</span> <span class="n">Employee</span> 
                    <span class="k">Group</span> <span class="k">By</span> <span class="n">employee_id</span> <span class="k">Having</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">;</span>

</code></pre></div></div>
<p>  Employee 별로 속한 department수가 상이하기 때문에 아예 나눠서 처리하는 게 적절해 보입니다. 1. department가 2개 이상인 경우, primary_flag = ‘Y’인 조건으로 primary department를 구하고 2. 1개일 경우는 그 department가 primary department이기에 department수가 1개인 경우만 조건으로 걸어서 primary department를 구해줍니다. 그 다음에는 Union을 활용해 두 결과를 하나의 테이블로 구해주면 됩니다!</p>

<h3 id="522-good-to-know---union">5.2.2 Good to Know - UNION</h3>
<p>  SQL에서는 UNION과 UNION ALL을 활용해 두 테이블을 하나의 테이블로 합칠 수 있습니다. 파이썬에서 pd.concat()과 유사한 것으로 생각하면 되겠네요. 사용법은 간단합니다.
<code class="language-plaintext highlighter-rouge">(A 테이블) UNION (ALL) (B 테이블)</code> 입니다. 컬럼명을 기준으로 union되는 것 같으니 컬럼명에 주의하고 활용하면 됩니다. UNION의 경우에는 중복값을 제거하는 반면, UNION ALL은 중복값을 제거해주지 않으므로 상황에 맞게 사용하시면 됩니다!</p>

<h2 id="53-610-triangle-judgement">5.3 610. Triangle Judgement</h2>
<p>  x, y와 z 변의 길이로 삼각형을 그릴 수 있는지를 판변하는 문제입니다. 3변의 길이가 주어졌을 때, 삼각형임을 판별하는 식은 다음과 같습니다.</p>
<blockquote>
  <p>가장 큰 변의 길이가 다른 두 변의 길이의 합보다 작아야 함</p>
</blockquote>

<h3 id="531-solution">5.3.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span>
    <span class="k">case</span>
        <span class="k">WHEN</span> 
        <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="k">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span> <span class="k">and</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
        <span class="k">Then</span> <span class="s1">'Yes'</span>
        <span class="k">ELSE</span> <span class="s1">'No'</span> 
        <span class="k">END</span> <span class="k">as</span> <span class="n">triangle</span>
<span class="k">FROM</span>
    <span class="n">Triangle</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  Case 구문을 활용해서 삼각형을 판별할 수 있는 조건을 줍니다. 다만, x, y와 z 중, 가장 큰 변의 길이가 무엇인지 모르기 때문에 x, y와 z 각각 판별해줘야 합니다. 만약, x, y와 z 중 하나라도 위 조건을 만족하지 못한다면 삼각형을 형성할 수 없습니다. 따라서 위 조건을 모두 만족하는 경우 ‘Yes’, 하나라도 만족하지 못하는 경우에는 ‘No’로 판별해주기 위에 각 조건들을 And로 연결했습니다!</p>

<h3 id="532-good-to-know---case구문">5.3.2 Good to Know - CASE구문</h3>
<p>  CASE 구문은 주로 여러 조건에 따라 구분해야 할 때 사용합니다. 필요한 조건이 하나인 경우에는 If()를 사용할 수 있지만 여러개인 경우 CASE 구문을 사용하는게 적절합니다. 그리고 직관적으로 이해할 수 있고 사용법도 쉽습니다. 기본적인 사용법은 다음과 같습니다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CASE</span>
    <span class="k">WHEN</span> <span class="n">A</span> <span class="k">THEN</span> <span class="n">AA</span>
    <span class="k">WHEN</span> <span class="n">B</span> <span class="k">THEN</span> <span class="n">BB</span>
    <span class="k">WHEN</span> <span class="k">C</span> <span class="k">THEN</span> <span class="n">CC</span>
    <span class="k">ELSE</span> <span class="n">DD</span>
    <span class="k">END</span> <span class="k">as</span> <span class="n">CASE_EXAMPLE</span>
</code></pre></div></div>
<p>  A를 만족하는 경우 AA를 할당하고 B를 만족하는 경우 BB, C를 만족하는 경우 CC, A,B와 C 어디에도 해당하지 않는 경우에 DD를 할당합니다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[  안녕하세요. 이번 Section은 Advanced Select and Joins입니다.]]></summary></entry><entry><title type="html">[SQL] LeetCode 풀이: Sorting and Grouping(2/2)</title><link href="http://localhost:4000/data/SQL_LeetCode7/" rel="alternate" type="text/html" title="[SQL] LeetCode 풀이: Sorting and Grouping(2/2)" /><published>2023-09-12T00:00:00+09:00</published><updated>2023-09-13T06:00:00+09:00</updated><id>http://localhost:4000/data/SQL_LeetCode7</id><content type="html" xml:base="http://localhost:4000/data/SQL_LeetCode7/"><![CDATA[<p>  안녕하세요. 드디어 문제는 다 풀었습니다! 문제 풀었던 것들 정리하면서 부족한 부분은 채우고자 합니다. 문제를 어떻게 풀었는지와 공부한 것들만 적고 필요없는 부분은 굳이 안 적으려고 합니다.</p>

<h1 id="4-sorting-and-grouping">4. Sorting and Grouping</h1>
<h2 id="46-1729-find-followers-count">4.6 1729 Find Followers Count</h2>
<p>  각 user 별로 follower가 몇 명인지를 구하는 문제입니다. 쉬운 문제네요.</p>

<h3 id="461-solution">4.6.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">user_id</span><span class="p">,</span>
    <span class="k">count</span><span class="p">(</span><span class="n">follower_id</span><span class="p">)</span>  <span class="k">as</span> <span class="n">followers_count</span>
<span class="k">FROM</span>
    <span class="n">Followers</span>
<span class="k">Group</span> <span class="k">By</span>
    <span class="n">user_id</span>
<span class="k">Order</span> <span class="k">By</span>
    <span class="n">user_id</span> <span class="k">asc</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  user 별로 follwer 수를 집계하면 됩니다!</p>

<h2 id="47-619-biggest-single-number">4.7 619. Biggest Single Number</h2>
<p>  MyNumbers Table에 num 중 오직 한 번만 나타난 것 중 가장 큰 값을 구하는 문제입니다. num 별로 수를 count로 집계하여 그 값이 1인 num만 가져오는 조건을 주면 될 것 같습니다.</p>
<h3 id="471-solution">4.7.1 Solution</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="k">Max</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>    <span class="k">as</span> <span class="n">num</span>
<span class="k">FROM</span>
    <span class="n">MyNumbers</span>
<span class="k">WHERE</span>
    <span class="n">num</span> <span class="k">in</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">num</span> <span class="k">FROM</span> <span class="n">MyNumbers</span> <span class="k">Group</span> <span class="k">By</span> <span class="n">num</span> <span class="k">HAVING</span> <span class="k">count</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">;</span>
</code></pre></div></div>
<p>  문제를 보고 떠올렸던 것은 우선 NyNumbers에서 중복되지 않은 값만 추려서 가져오자였습니다. 그래서 HAVING을 사용해서 <code class="language-plaintext highlighter-rouge">count(num) = 1</code> 조건을 걸어서 중복된 값들은 제거했습니다.
그 다음에 <code class="language-plaintext highlighter-rouge">in</code>을 사용해 해당 num만 가져온 후, <code class="language-plaintext highlighter-rouge">max</code>값을 구했습니다.</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="SQL" /><category term="LeetCode" /><summary type="html"><![CDATA[  안녕하세요. 드디어 문제는 다 풀었습니다! 문제 풀었던 것들 정리하면서 부족한 부분은 채우고자 합니다. 문제를 어떻게 풀었는지와 공부한 것들만 적고 필요없는 부분은 굳이 안 적으려고 합니다.]]></summary></entry><entry><title type="html">[회고록] 23년 9월 1주차: 에너지 절감(2/2)</title><link href="http://localhost:4000/data/weekly_memoir_9/" rel="alternate" type="text/html" title="[회고록] 23년 9월 1주차: 에너지 절감(2/2)" /><published>2023-09-04T00:00:00+09:00</published><updated>2023-09-05T07:24:00+09:00</updated><id>http://localhost:4000/data/weekly_memoir_9</id><content type="html" xml:base="http://localhost:4000/data/weekly_memoir_9/"><![CDATA[<p>  안녕하세요. 지난 <a href="https://mato-park.github.io/data/weekly_memoir_5/">회고록</a>에서 적었던 에너지 절감 프로젝트가 마무리되어 가고 있습니다. 프로젝트를 진행하면서 <a href="https://mato-park.github.io/data/weekly_memoir_7/">분석 모델링</a>도 수행하기도 했고 이 얘기에 이어서 마무리 짓지 못했던 회고록을 이어서 작성해보겠습니다. 
<br /><br /></p>

<h2 id="4-에너지-절감-포인트-도출">4. 에너지 절감 포인트 도출</h2>
<p>  앞의 과정이 끝났다면 에너지 별로 문제점 진단이 끝났을 것입니다. 그럼 데이터 분석을 통한 에너지 절감이 가능한 경우는 다음과 같이 정리가 될 것입니다.</p>
<blockquote>
  <ol>
    <li>에너지 사용량의 산포(범위, 표준편차, 분산, 사분위 범위 등)가 큰 경우</li>
    <li>과거 설비 운전 패턴이 다양한 경우</li>
    <li>공정 품질 수준이 관리선 대비 여유가 큰 경우</li>
    <li>에너지 관련 관리 지표의 변동이 있는 경우</li>
  </ol>
</blockquote>

<p>  각 상황 별로 분석한 내용에 대해서 간략하게 정리하겠습니다.</p>

<h3 id="41-에너지-사용량-산포-원인분석">4.1 에너지 사용량 산포 원인분석</h3>
<p>  말 그대로 에너지 사용량 산포가 큰 이유를 찾아내는 것입니다. 어떤 공정, 품질 인자로 인하여 에너지 사용량의 변동이 큰지 탐색해 나갑니다. 우선 공정 별로 <strong>공정 메커니즘 이해</strong>가 중요합니다. 왜냐하면 공정 별로 중요한 외생 변수는 무엇인지, 후보인자를 선별해야 하기 때문입니다. 중요 외생변수를 통제해가면서 에너지 사용량과 상관성이 높은 변수들을 탐색해 나갑니다. 주로 EDA를 하면서 인자들을 탐색하고 필요하다면 분석 모델링을 통해 다변량이 에너지 사용량에 미치는 효과를 추정해내기도 합니다.<br /><br />
  주요 인자들을 통제했음에도 불구하고 산포가 남아있는 경우가 바로 에너지 절감 포인트입니다. 공정 최적화가 되지 못해 에너지 사용량의 낭비가 있거나, 너무 과도하게 품질을 관리하고 있는 경우기 있을 수 있습니다. 주요 인자들을 제외한 공정 인자의 변동이 에너지 사용량의 영향을 미친다면 최적화를 통해 에너지 절감이 가능합니다.<br /><br />
  에너지 사용량의 산포가 있음에도 공정 인자와 매치되지 않는 경우는 설비 이상을 의심해봐야 합니다. 하지만 이 부분은 데이터로 볼 수 있는 부분이 아니기에, 우리는 문제점만 전달하고 현업 담당자에게 뒷 일은 맡겨야 합니다.</p>

<h3 id="42-최적-설비-운전-패턴-도출">4.2 최적 설비 운전 패턴 도출</h3>
<p>  특정 공정 관리 인자의 온도를 맞추기 위해서 열매의 온도와 유량을 조정하면서 열교환을 합니다. 이때 다양한 운전 패턴이 있을 수 있습니다. 그렇다면 이 운전 패턴 간 에너지 사용량을 비교해보고 어떤 운전 패턴이 최적인지 탐색해볼 수 있습니다. 쉽게 예를 들면, 여름에 더울 때 에어컨 온도를 낮추고 바람 세기를 적게 하는 것이 더 효율적인지 혹은 온도를 조금 높이고 바람 세기를 세게 하는 것이 효율적인지를 비교해보는 것이라 생각하면 될 것 같습니다. <br /><br />
  너무 쉽고 당연한 얘기죠? 하지만 의외로 이런 곳에서 절감포인트가 나옵니다. 데이터 인프라가 약한 조직이라면 과거 긴 시간의 데이터를 활용하지 못하기 때문에 분명히 놓치고 있는 것이 있을 수 있기 때문에 확인하면 좋은 포인트입니다.</p>

<h3 id="43-공정-품질-수준이-관리선-대비-여유가-큰-경우">4.3 공정 품질 수준이 관리선 대비 여유가 큰 경우</h3>
<p>  공정 관리 수준이 너무 타이트할 수 있습니다. 공정의 여유가 있다면 품질 수준을 조금 낮추고 에너지 사용량을 줄이는 방안도 고려해 볼 수 있습니다. 다만 이 부분도 분석가의 역할은 현황만 진단하고 나머지 판단은 현업에 맡겨야 합니다.</p>

<h3 id="44-에너지-관리-지표의-변동이-있는-경우">4.4 에너지 관리 지표의 변동이 있는 경우</h3>
<p>  예를 들어, 냉수 온도를 일정하게 유지해야 하는데 계절 별로 온도가 변동하는 경우가 있습니다. 이 경우, 데이터를 확인해 특별한 이유가 있는지 혹은 연관된 인자의 변동을 살펴보고 특별한 이유가 없다면 모종의 이유로 에너지가 낭비되고 있을 수 있습니다. 이 부분도 확인해보면 에너지 절감 포인트를 도출하는데 도움이 될 수 있습니다.</p>

<h2 id="5-개선안-도출">5. 개선안 도출</h2>
<p>  분석을 통해 도출한 에너지 절감 포인트를 활용하여 에너지 사용량 개선안을 내야 합니다. 사실 이 부분부터는 분석가의 역할이 아니라 현업 담당자의 역할입니다. 분석을 통해 발견한 인자를 최적화하거나 혹은 분석 결과를 기반으로 아이디어를 도출해 개선안을 수립하고 실제 공정에 Test해보고 결과를 비교해봅니다. <br /><br /> 
  뻔한 얘기지만 좋은 개선안을 내기 위해서는 좋은 분석의 선행이 필수인 것 같습니다. 왜냐하면 현업 담당자들을 에너지 절감을 위해 이미 다양한 아이디어를 내고 개선 활동을 하고 있기에, 새로운 것을 제시하고 설득하기 위해서는 철저한 논리와 데이터 기반의 객관적인 근거가 필요하기 때문입니다.</p>

<h2 id="6-모니터링-시스템-구축">6. 모니터링 시스템 구축</h2>
<p>  분석하고 개선안 내서 적용하면 끝일까요? 아닙니다. 에너지 사용량이 잘 관리되고 있는지 모니터링 할 수 있는 시스템이 필요합니다. 이번 프로젝트에서는 BI Tool을 활용해 향후 일별로 에너지 사용량을 모니터링 할 수 있는 시각화 대시보드 App을 개발하여 활용할 수 있게 했습니다. 앞으로는 과거 데이터와 비교하여 현재 에너지 사용량이 적절한지 판단할 수 있는 시스템이 갖춰졌습니다. 조직원 모두가 에너지 사용량을 확인할 수 있고 분석할 수 있습니다. 어쩌면 데이터 기반 의사결정 문화에도 큰 도움이 되리라 생각합니다.</p>

<h2 id="7-프로젝트를-마치며">7. 프로젝트를 마치며..</h2>
<p>  에너지 절감 분석 프로젝트를 해보니 <strong>현업 담당자들이 놓치고 있던 부분을 데이터를 활용해 짚어내는 것</strong>이 주효했던 것 같습니다. 생각보다(?) 현업 담당자들은 다 잘하고 있고 문제없다 얘기하지만, 데이터를 까보면 아닌 경우가 허다했습니다. 그리고 분석의 난이도가 높아서 어렵다기보다는 공장의 모든 설비와 에너지를 살펴봐야 했기에 힘들었던 분석이었습니다. 그래도 에너지 별로 낭비요소를 찾아내고 개선이 이뤄지는 것을 보면서 역시 뿌듯하고 즐거웠던 프로젝트였습니다. 물론 아직 끝나지 않았습니다…</p>]]></content><author><name>박마토</name></author><category term="Data" /><category term="Data" /><category term="Memoir" /><summary type="html"><![CDATA[  안녕하세요. 지난 회고록에서 적었던 에너지 절감 프로젝트가 마무리되어 가고 있습니다. 프로젝트를 진행하면서 분석 모델링도 수행하기도 했고 이 얘기에 이어서 마무리 짓지 못했던 회고록을 이어서 작성해보겠습니다.]]></summary></entry></feed>